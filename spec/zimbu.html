<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Zimbu Language Specification</title>
<meta name="Generator" content="Vim/7.4">
<style type="text/css">
<!--
body {
  font-family: arial,sans-serif;
  color: #000000;
  background-color: #ffffff;
}
pre {
  white-space: pre-wrap;
  font-family: monospace;
  color: #000000;
  font-size: 1em;
  padding: 4px;
}
hr {
  border-color: #eeeeee;
  border-width: 3px;
}
table {
  border-collapse: collapse;
}
ul, ol {
  margin-top: -1em;
}
a:link {
  color: #0000ff;
  text-decoration: none;
}
a:visited {
  color: #0000ff;
}
a:hover {
  color: #800080;
  text-decoration: underline;
}
.topItem, .topItem a:link, .topItem a:visited {
  color: #000000;
  font-size: 24px;
}
.topItem a:hover {
  color: #800080;
}
.contItem {
  color: #0000ff;
  margin-left: 20px;
}
.contLead {
  line-height: 12px;
  margin-bottom: 5px;
  margin-left: 60px;
}
.contSub {
  color: #000000;
  font-size: 12px;
  margin-right: 12px;
}
.contSub a:link, .contSub a:visited {
  color: #000000;
  font-size: 12px;
}
.contSub a:hover {
  color: #800080;
}
.vimCodeElement {
  background-color: #eeffcc;
  border-color: #88aa66;
  border-style: solid none;
  border-width: 1px medium;
}
h3 {
  display: inline-block;
}
h4 {
  display: inline-block;
}
h5 {
  display: inline-block;
}
.rationale {
  background-color: #ddddff;
  border-color: #6666dd;
  border-style: solid none;
  border-width: 1px medium;
  padding: 0 8px;
}
.openclose {
  display: inline-block;
  font-size: 12px;
  margin-left: 20px;
}
.firstrow {
  font-weight: bold;
}
.firstcol {
}
.col {
  padding-left: 10px;
}
.Type { color: #008000; }
.Ignore { color: #ffffff; }
.Statement { color: #8b0000; }
.Comment { color: #0000c0; }
.Constant { color: #c00000; }
.PreProc { color: #c000c0; }
.Todo { color: #000000; background-color: #ffff00; padding-bottom: 1px; }
-->
</style>
<script>
function showHide(name) {
  var el = document.getElementById(name);
  if (el.style.display == "none") {
    el.style.display = "block";
  } else {
    el.style.display = "none";
  }
}
</script>
</head>
<body>
<h1>Zimbu Language Specification</h1>

<p>Last Change: 2014 Nov 17
</p>

<img src="underconstruction.png">&nbsp;UNDER CONSTRUCTION

<p>This page contains both an informal explanation and a formal specification of
the Zimbu programming language.<br>
More information on <a href="https://sites.google.com/site/zimbuweb/language-specification">the Zimbu website</a>.
</p>

<p>The notation used to specify the exact syntax can be found <a href="#Exact%32Syntax%32Notation">near the end</a>.
</p>


<hr>
<h2>Contents</h2>
<div class="topItem"><a href="#Zimbu%32File">Zimbu File</a></div>
<div class="contItem"><a href="#Preprocessing">Preprocessing</a></div>
<div class="contItem"><a href="#File%32Level">File Level</a></div>
<div class="contLead">
<span class="contSub"><a href="#File%32Level_Main%40%41">Main()</a></span>
<span class="contSub"><a href="#File%32Level_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#IMPORT">IMPORT</a></div>
<div class="contLead">
<span class="contSub"><a href="#IMPORT_IMPORT%32AS">IMPORT AS</a></span>
<span class="contSub"><a href="#IMPORT_IMPORT%32plugin">IMPORT plugin</a></span>
<span class="contSub"><a href="#IMPORT_IMPORT%46PROTO">IMPORT.PROTO</a></span>
<span class="contSub"><a href="#IMPORT_IMPORT%46ZUT">IMPORT.ZUT</a></span>
<span class="contSub"><a href="#IMPORT_IMPORT%46ZWT">IMPORT.ZWT</a></span>
<span class="contSub"><a href="#IMPORT_IMPORT%46CHEADER">IMPORT.CHEADER</a></span>
<span class="contSub"><a href="#IMPORT_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="topItem"><a href="#Declarations">Declarations</a></div>
<div class="contItem"><a href="#MODULE">MODULE</a></div>
<div class="contLead">
<span class="contSub"><a href="#MODULE_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#CLASS">CLASS</a></div>
<div class="contLead">
<span class="contSub"><a href="#CLASS_Rationale">Rationale</a></span>
<span class="contSub"><a href="#CLASS_EXTEND">EXTEND</a></span>
<span class="contSub"><a href="#CLASS_IMPLEMENTS">IMPLEMENTS</a></span>
<span class="contSub"><a href="#CLASS_INCLUDE">INCLUDE</a></span>
<span class="contSub"><a href="#CLASS_SHARED">SHARED</a></span>
<span class="contSub"><a href="#CLASS_Constructor">Constructor</a></span>
<span class="contSub"><a href="#CLASS_Destructor">Destructor</a></span>
<span class="contSub"><a href="#CLASS_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#INTERFACE">INTERFACE</a></div>
<div class="contLead">
<span class="contSub"><a href="#INTERFACE_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#PIECE">PIECE</a></div>
<div class="contLead">
<span class="contSub"><a href="#PIECE_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#ENUM">ENUM</a></div>
<div class="contLead">
<span class="contSub"><a href="#ENUM_Enum%32value%32methods">Enum value methods</a></span>
<span class="contSub"><a href="#ENUM_Enum%32methods">Enum methods</a></span>
<span class="contSub"><a href="#ENUM_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#BITS">BITS</a></div>
<div class="contLead">
<span class="contSub"><a href="#BITS_Assignment">Assignment</a></span>
<span class="contSub"><a href="#BITS_Values">Values</a></span>
<span class="contSub"><a href="#BITS_Expressions">Expressions</a></span>
<span class="contSub"><a href="#BITS_Methods">Methods</a></span>
<span class="contSub"><a href="#BITS_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#Method%32Declaration">Method Declaration</a></div>
<div class="contLead">
<span class="contSub"><a href="#Method%32Declaration_Function%32Overloading">Function Overloading</a></span>
<span class="contSub"><a href="#Method%32Declaration_NEW">NEW</a></span>
<span class="contSub"><a href="#Method%32Declaration_PROC">PROC</a></span>
<span class="contSub"><a href="#Method%32Declaration_FUNC">FUNC</a></span>
<span class="contSub"><a href="#Method%32Declaration_Lambda%32expression">Lambda expression</a></span>
<span class="contSub"><a href="#Method%32Declaration_LAMBDA%32method">LAMBDA method</a></span>
<span class="contSub"><a href="#Method%32Declaration_Optional%32arguments">Optional arguments</a></span>
<span class="contSub"><a href="#Method%32Declaration_Variable%32number%32of%32arguments%32%40varargs%41">Variable number of arguments (varargs)</a></span>
<span class="contSub"><a href="#Method%32Declaration_Closure%32and%32USE%32arguments">Closure and USE arguments</a></span>
<span class="contSub"><a href="#Method%32Declaration_Predefined%32methods">Predefined methods</a></span>
<span class="contSub"><a href="#Method%32Declaration_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#Variable%32Declaration">Variable Declaration</a></div>
<div class="contLead">
<span class="contSub"><a href="#Variable%32Declaration_VAR">VAR</a></span>
<span class="contSub"><a href="#Variable%32Declaration_STATIC">STATIC</a></span>
<span class="contSub"><a href="#Variable%32Declaration_Simplified%32Syntax">Simplified Syntax</a></span>
<span class="contSub"><a href="#Variable%32Declaration_Exact%32syntax">Exact syntax</a></span>
<span class="contSub"><a href="#Variable%32Declaration_Variable%32Names">Variable Names</a></span>
<span class="contSub"><a href="#Variable%32Declaration_Attributes">Attributes</a></span>
<span class="contSub"><a href="#Variable%32Declaration_Initializer">Initializer</a></span>
</div>
<div class="topItem"><a href="#Types">Types</a></div>
<div class="contItem"><a href="#Value%32types">Value types</a></div>
<div class="contItem"><a href="#Reference%32types">Reference types</a></div>
<div class="contLead">
<span class="contSub"><a href="#Reference%32types_Reference%32to%32a%32variable">Reference to a variable</a></span>
<span class="contSub"><a href="#Reference%32types_Reference%32to%32a%32method">Reference to a method</a></span>
</div>
<div class="contItem"><a href="#Template%32types">Template types</a></div>
<div class="contItem"><a href="#Runtime%32type%32checking">Runtime type checking</a></div>
<div class="contLead">
<span class="contSub"><a href="#Runtime%32type%32checking_dyn">dyn</a></span>
</div>
<div class="contItem"><a href="#Identity">Identity</a></div>
<div class="contItem"><a href="#Builtin%32Types">Builtin Types</a></div>
<div class="contLead">
<span class="contSub"><a href="#Builtin%32Types_Value%32types">Value types</a></span>
<span class="contSub"><a href="#Builtin%32Types_String%32types">String types</a></span>
<span class="contSub"><a href="#Builtin%32Types_Container%32types">Container types</a></span>
<span class="contSub"><a href="#Builtin%32Types_Tuple%32type">Tuple type</a></span>
<span class="contSub"><a href="#Builtin%32Types_Thread%32related%32types">Thread related types</a></span>
<span class="contSub"><a href="#Builtin%32Types_Other%32types">Other types</a></span>
</div>
<div class="contItem"><a href="#ALIAS%32and%32TYPE">ALIAS and TYPE</a></div>
<div class="contLead">
<span class="contSub"><a href="#ALIAS%32and%32TYPE_Simplified%32Syntax">Simplified Syntax</a></span>
<span class="contSub"><a href="#ALIAS%32and%32TYPE_ALIAS">ALIAS</a></span>
<span class="contSub"><a href="#ALIAS%32and%32TYPE_TYPE">TYPE</a></span>
</div>
<div class="topItem"><a href="#Statements">Statements</a></div>
<div class="contItem"><a href="#Block%32Statements">Block Statements</a></div>
<div class="contLead">
<span class="contSub"><a href="#Block%32Statements_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#Assignment">Assignment</a></div>
<div class="contLead">
<span class="contSub"><a href="#Assignment_Simple%32Assignment">Simple Assignment</a></span>
<span class="contSub"><a href="#Assignment_Multiple%32Assignment">Multiple Assignment</a></span>
<span class="contSub"><a href="#Assignment_Multiple%32Assignment%32with%32declaration">Multiple Assignment with declaration</a></span>
<span class="contSub"><a href="#Assignment_Operator%32Assignment">Operator Assignment</a></span>
<span class="contSub"><a href="#Assignment_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#Method%32call">Method call</a></div>
<div class="contLead">
<span class="contSub"><a href="#Method%32call_Passing%32arguments%32by%32name">Passing arguments by name</a></span>
<span class="contSub"><a href="#Method%32call_Selecting%32the%32method%32to%32be%32called">Selecting the method to be called</a></span>
<span class="contSub"><a href="#Method%32call_Automatic%32argument%32conversion">Automatic argument conversion</a></span>
<span class="contSub"><a href="#Method%32call_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#RETURN">RETURN</a></div>
<div class="contLead">
<span class="contSub"><a href="#RETURN_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#EXIT">EXIT</a></div>
<div class="contLead">
<span class="contSub"><a href="#EXIT_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#IF">IF</a></div>
<div class="contLead">
<span class="contSub"><a href="#IF_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#IFNIL">IFNIL</a></div>
<div class="contItem"><a href="#SWITCH">SWITCH</a></div>
<div class="contLead">
<span class="contSub"><a href="#SWITCH_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#WHILE">WHILE</a></div>
<div class="contLead">
<span class="contSub"><a href="#WHILE_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#DO%32%45%32UNTIL">DO - UNTIL</a></div>
<div class="contLead">
<span class="contSub"><a href="#DO%32%45%32UNTIL_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#FOR">FOR</a></div>
<div class="contLead">
<span class="contSub"><a href="#FOR_Looping%32over%32more%32than%32one%32iterable">Looping over more than one iterable</a></span>
<span class="contSub"><a href="#FOR_Loop%32variable">Loop variable</a></span>
<span class="contSub"><a href="#FOR_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#DEFER">DEFER</a></div>
<div class="contLead">
<span class="contSub"><a href="#DEFER_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#TRY%32%45%32CATCH%32%45%32ELSE%32%45%32FINALLY">TRY - CATCH - ELSE - FINALLY</a></div>
<div class="contLead">
<span class="contSub"><a href="#TRY%32%45%32CATCH%32%45%32ELSE%32%45%32FINALLY_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#THROW">THROW</a></div>
<div class="contItem"><a href="#Native%32code">Native code</a></div>
<div class="contLead">
<span class="contSub"><a href="#Native%32code_Using%32a%32C%32type">Using a C type</a></span>
<span class="contSub"><a href="#Native%32code_IMPORT%46CHEADER">IMPORT.CHEADER</a></span>
<span class="contSub"><a href="#Native%32code_Using%32a%32C%32expression">Using a C expression</a></span>
<span class="contSub"><a href="#Native%32code_Native%32code%32block">Native code block</a></span>
</div>
<div class="contItem"><a href="#Conditional%32Compilation">Conditional Compilation</a></div>
<div class="contLead">
<span class="contSub"><a href="#Conditional%32Compilation_GENERATE_IF">GENERATE_IF</a></span>
<span class="contSub"><a href="#Conditional%32Compilation_BUILD_IF">BUILD_IF</a></span>
<span class="contSub"><a href="#Conditional%32Compilation_GENERATE_ERROR">GENERATE_ERROR</a></span>
<span class="contSub"><a href="#Conditional%32Compilation_Compile%32time%32expression">Compile time expression</a></span>
</div>
<div class="topItem"><a href="#Expressions">Expressions</a></div>
<div class="contItem"><a href="#Operator%32precedence">Operator precedence</a></div>
<div class="contItem"><a href="#Operators">Operators</a></div>
<div class="contLead">
<span class="contSub"><a href="#Operators_%63%58%32If%45nil">?: If-nil</a></span>
<span class="contSub"><a href="#Operators_%63%32%58%32Ternary%32operator">? : Ternary operator</a></span>
<span class="contSub"><a href="#Operators_%38%38%32Boolean%32AND">&amp;&amp; Boolean AND</a></span>
<span class="contSub"><a href="#Operators_%61%61%44%32%33%61%32equal%32and%32unequal">==, != equal and unequal</a></span>
<span class="contSub"><a href="#Operators_%62%44%32%62%61%44%32%60%44%32%60%61%32Comperators">&gt;, &gt;=, &lt;, &lt;= Comperators</a></span>
<span class="contSub"><a href="#Operators_IS%44%32ISNOT">IS, ISNOT</a></span>
<span class="contSub"><a href="#Operators_ISA%44%32ISNOTA">ISA, ISNOTA</a></span>
<span class="contSub"><a href="#Operators_%46%46%32String%32concatenation">.. String concatenation</a></span>
<span class="contSub"><a href="#Operators_%38%44%32%124%44%32%94%32Logical%32operators">&amp;, |, ^ Logical operators</a></span>
<span class="contSub"><a href="#Operators_%60%60%44%32%62%62%32bitwise%32shift">&lt;&lt;, &gt;&gt; bitwise shift</a></span>
<span class="contSub"><a href="#Operators_%43%44%32%45%32add%32and%32subtract">+, - add and subtract</a></span>
<span class="contSub"><a href="#Operators_%42%44%32%47%44%32%37%32multiply%44%32divide%32and%32remainder">*, /, % multiply, divide and remainder</a></span>
<span class="contSub"><a href="#Operators_%43%43%44%32%45%45%32Increment%32and%32decrement">++, -- Increment and decrement</a></span>
<span class="contSub"><a href="#Operators_Unary%32operators">Unary operators</a></span>
<span class="contSub"><a href="#Operators_%46member">.member</a></span>
<span class="contSub"><a href="#Operators_%46member%40%41%32object%32call">.member() object call</a></span>
<span class="contSub"><a href="#Operators_%63%46member">?.member</a></span>
<span class="contSub"><a href="#Operators_%63%46member%40%41">?.member()</a></span>
<span class="contSub"><a href="#Operators_name%91%93%32get%32item">name[] get item</a></span>
<span class="contSub"><a href="#Operators_%61name%32Bits%32item%32value">=name Bits item value</a></span>
<span class="contSub"><a href="#Operators_%60Type%62%32Template">&lt;Type&gt; Template</a></span>
<span class="contSub"><a href="#Operators_%46%60Typecast%62">.&lt;Typecast&gt;</a></span>
<span class="contSub"><a href="#Operators_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#Composite%32Names">Composite Names</a></div>
<div class="contLead">
<span class="contSub"><a href="#Composite%32Names_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#Identifiers">Identifiers</a></div>
<div class="contLead">
<span class="contSub"><a href="#Identifiers_Reserved%32names">Reserved names</a></span>
<span class="contSub"><a href="#Identifiers_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#Values">Values</a></div>
<div class="contLead">
<span class="contSub"><a href="#Values_Numbers">Numbers</a></span>
<span class="contSub"><a href="#Values_Strings">Strings</a></span>
<span class="contSub"><a href="#Values_String%32Expressions">String Expressions</a></span>
<span class="contSub"><a href="#Values_Lists">Lists</a></span>
<span class="contSub"><a href="#Values_Dicts">Dicts</a></span>
<span class="contSub"><a href="#Values_Objects">Objects</a></span>
<span class="contSub"><a href="#Values_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="topItem"><a href="#Execution">Execution</a></div>
<div class="contItem"><a href="#Default%32Values">Default Values</a></div>
<div class="contLead">
<span class="contSub"><a href="#Default%32Values_Rationale">Rationale</a></span>
<span class="contSub"><a href="#Default%32Values_Default%32values%32for%32types">Default values for types</a></span>
</div>
<div class="contItem"><a href="#Startup%32Sequence">Startup Sequence</a></div>
<div class="contItem"><a href="#Object%32Initialization%32Sequence">Object Initialization Sequence</a></div>
<div class="contItem"><a href="#Object%32Destruction">Object Destruction</a></div>
<div class="topItem"><a href="#Syntax">Syntax</a></div>
<div class="contItem"><a href="#White%32Space%32and%32Comments">White Space and Comments</a></div>
<div class="contLead">
<span class="contSub"><a href="#White%32Space%32and%32Comments_Comments">Comments</a></span>
<span class="contSub"><a href="#White%32Space%32and%32Comments_White%32space">White space</a></span>
<span class="contSub"><a href="#White%32Space%32and%32Comments_Notes%32on%32the%32exact%32syntax">Notes on the exact syntax</a></span>
<span class="contSub"><a href="#White%32Space%32and%32Comments_Exact%32syntax">Exact syntax</a></span>
</div>
<div class="contItem"><a href="#Exact%32Syntax%32Notation">Exact Syntax Notation</a></div>
<div class="topItem"><a href="#Copyright">Copyright</a></div>


<hr>
<a name="Zimbu%32File"></a><h1>Zimbu File</h1>

<p>A Zimbu file is always UTF-8 encoded.
</p>

<p>The file name must end in ".zu".
</p>

<p>For an imported file the file name up to ".zu" must match the toplevel item in
the file (class, module, enum, etc.) exactly.
</p>


<hr>
<a name="Preprocessing"></a><h2>Preprocessing</h2>

<p>Before a file is parsed the following operations are performed:
</p>

<ul>
<li>All CR characters (ASCII 0x0d) are silently discarded.
</li>
<li>All Unicode BOM characters are silently discarded.
</li>
<li>All ASCII control characters, except for NL (ASCII 0x0a) cause an error.
   This implies that NUL (ASCII 0x00) and TAB characters (ASCII 0x09) are not
   allowed.
</li>
<li>Invalid UTF-8 causes an error.
</li>
</ul>


<hr>
<a name="File%32Level"></a><h2>File Level</h2>

<p>A Zimbu file usually starts with comments.  You should describe what is in the
file, what the code is intended to do. You can also add a copyright statement
and license.  The Apache license is recommended.
</p>

<p>IMPORT statements come next. They must appear before any other items, except
comments.  It is recommended to group imports by directory and sort them
alphabetically.
</p>

<p>The main program file must define the Main() method somewhere.
Other items can come before and after it, in any order.
There is no requirement to define an item before using it in the file scope.
</p>

<p>The Main program file will look like this:
<pre class='vimCodeElement'>
<span class="Comment"># Description of what this program does, arguments, etc.</span>
<span class="Comment"># Copyright, license.</span>

<span class="Statement">IMPORT</span> <span class="Constant">&quot;SomeClass.zu&quot;</span>

<span class="Comment"># Methods and other things go here.</span>

<span class="Statement">FUNC</span> Main() <span class="Type">int</span>
  <span class="Comment"># your code goes here</span>
  <span class="Statement">RETURN</span> exitVal
<span class="Statement">}</span>

<span class="Comment"># More methods and other things go here.</span>
</pre>
</p>


<a name="File%32Level_Main%40%41"></a><div><h3>Main()</h3></div>

<p>The Main() method is the entry point to the program.  It will be called after
initializations are done, see the <a href="#Startup%32Sequence">Startup Sequence</a> section.
</p>

<p>Command line arguments are not passed to Main(), they can be obtained with
the <a href="https://zimbu.googlecode.com/hg/docs/ARG.html">ARG module</a>.
</p>

<p>The Main method returns an int, which is the exit code for the program.  The
convention is that zero is returned for success and a positive number for
failure.  Alternatively the program ends with an EXIT statement or when an
exception is thrown that is not caught.
</p>

<a name="File%32Level_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<p>MAINFILE is the starting point for a Zimbu program file.
IMPORTFILE is the starting point for an imported file.
</p>

<pre>
MAINFILE        -&gt;  skip
                    import*
                    file-item*
                    main
                    file-item*
                    ;
IMPORTFILE      -&gt;  skip
                    import*
                    common-item
                    ;
file-item       -&gt;  ( common-item | var-def | method-def ) ;
common-item     -&gt;  ( module-def | class-def | interface-def | piece-def | enum-def | bits-def )
main            -&gt;  "FUNC"  sep  "Main()"  sep  "int"  sep-with-eol
                      block-item+
                    block-end  ;
</pre>


<hr>
<a name="IMPORT"></a><h2>IMPORT</h2>

<p>An IMPORT specifies a file to include.
</p>

<p>The imported file must define exacly one item, usually a class or module.  The
name of this item must match the file name up to the ".zu".  Thus when defining
a class "FooBar" the file name must be "FooBar.zu".  This way, at every place
where the file is imported, you know exactly what symbol is going to be defined
by that import.
</p>

<p>Zimbu files can import each other, the compiler takes care of cyclic
dependencies.
</p>

<p>There is no need to import builtin modules, such as IO, ARG and E.  The
compiler will take care of that automatically.
</p>

<a name="IMPORT_IMPORT%32AS"></a><div><h3>IMPORT AS</h3></div>

<p>If the symbol that the IMPORT defines conflicts with another symbol, the AS
part can be used to give the imported symbol another name in this file only.
The name after "AS" must follow the naming rules of what is being imported: it
must start with an upper case letter and have a lower case letter somewhere.
</p>

<p>This example uses the name OldParser for the Parser defined in the second
imported file.  Thus both Parser and OldParser can be used.
</p>

<pre class='vimCodeElement'>
<span class="Statement">IMPORT</span> <span class="Constant">&quot;Parser.zu&quot;</span>
<span class="Statement">IMPORT</span> <span class="Constant">&quot;old/Parser.zu&quot;</span> <span class="Statement">AS</span> OldParser
</pre>

<a name="IMPORT_IMPORT%32plugin"></a><div><h3>IMPORT plugin</h3></div>

<p>An IMPORT can specify a plugin to use.  A Zimbu plugin converts the specified
file and turns it into Zimbu code.  The Zimbu code is then what gets imported.
</p>

<p>NOTE: Custom plugins have not been implemented yet.
</p>

<p>At the start of the filename $PLUGIN can be used.  This refers to the "plugin"
directory.  This can be used by plugins to find files imported in the generated
Zimbu file, for example:
<pre class='vimCodeElement'>
<span class="Statement">IMPORT</span> <span class="Constant">&quot;$PLUGIN/proto/Message.zu&quot;</span>
</pre>
</p>

<p>Imports using a plugin should be put before other imports, so that they are
easy to spot.
</p>


<a name="IMPORT_IMPORT%46PROTO"></a><div><h3>IMPORT.PROTO</h3></div>

<p>A builtin plugin is PROTO, it generates Zimbu code from a .proto file.  This is
used in the Zimbu compiler:
</p>

<pre class='vimCodeElement'>
<span class="Statement">IMPORT</span>.<span class="PreProc">PROTO</span> <span class="Constant">&quot;zui.proto&quot;</span>
</pre>

<p>How the PROTO plugin works is specified elsewhere.
TODO: add a link
</p>


<a name="IMPORT_IMPORT%46ZUT"></a><div><h3>IMPORT.ZUT</h3></div>

<p>Another builtin plugin is ZUT, which stands for Zimbu Templates and can be
used to create active web pages.  This uses CSS and HTML, mixed with Zimbu code
to create them dynamically and controllers to make them interactive. More
information can be found in the separate zut.html document.
</p>


<a name="IMPORT_IMPORT%46ZWT"></a><div><h3>IMPORT.ZWT</h3></div>

<p>Another builtin plugin is ZWT, which stands for Zimbu Web Toolkit and can be
used to built a GUI.  This is specified
&lt;/p&gt;
&lt;a href="https://sites.google.com/site/zimbuweb/documentation/zwt-a-javascript-ui"&gt;on the ZWT page&lt;/a&gt;.


<a name="IMPORT_IMPORT%46CHEADER"></a><div><h3>IMPORT.CHEADER</h3></div>

<p>The CHEADER plugin can be used to directly include a C header file in the
program.  See the <a href="#Native%32code_IMPORT%46CHEADER">native code section</a>.
</p>

<p>When using a plugin the OPTIONS part can be used to pass command line arguments
to the plugin.  Example:
</p>

<pre class='vimCodeElement'>
<span class="Statement">IMPORT</span>.WavToBytes <span class="Constant">&quot;poing.wav&quot;</span> <span class="Statement">OPTIONS</span> <span class="Constant">&quot;--multiline --name=poingSound&quot;</span>
</pre>

<a name="IMPORT_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
import          -&gt;  "IMPORT"  plugin?  sep
                      ( """  file-name  """ | "&lt;"  file-name  "&gt;" )
                      ( import-as?  import-options? | import-options? import-as? )
                      sep-with-eol ;
plugin          -&gt;  "." ( var-name | "PROTO" | "ZWT" | "ZUT" | "CHEADER" )  ;
import-as       -&gt;  sep  "AS"  sep  var-name  ;
import-options  -&gt;  sep  "OPTIONS"  sep  \(g  ;
</pre>


<hr>
<a name="Declarations"></a><h1>Declarations</h1>

<hr>
<a name="MODULE"></a><h2>MODULE</h2>

<p>TODO
</p>

<p>The module name must start with an upper case character and must be followed by
at least one lower case letter.
</p>

<a name="MODULE_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
module-def  -&gt;  "MODULE"  sep  group-name  sep-with-eol
                  block-item*
                block-end  ;
</pre>


<hr>
<a name="CLASS"></a><h2>CLASS</h2>

<p>The Zimbu CLASS is much like C++ and Java, but not exactly the same:
</p>
<ul>
<li>Single inheritance is supported with EXTEND.
</li>
<li>Composition is supported with INCLUDE.
</li>
<li>Interfaces implemented by the class are explicitly listed with IMPLEMENTS.
</li>
<li>Every class implicitly defines its own interface.
</li>
<li>Templated classes are supported.  
</li>
</ul>

<div class="rationale">
<a name="CLASS_Rationale"></a><div onclick="showHide('r1')"><h3>Rationale</h3><div class="openclose">click to open/close</div></div><div onclick="showHide('r1')" style="display: none" id="r1">

<p>Programmers often get confused by thinking that objects in a computer program
are real-world objects.  They are not!  For example, a real-world book cannot
read.  You need a person to read a book.  A book only has properties, it cannot
do anything by itself.  On the other hand, a person can do lots of things, but
most of them are irrelevant in a computer program.  You most likely want to
store a persons name and address, not implement a method for a person to read a
book.  Not because it's not possible, but because your program doesn't need
that functionality.
</p>

<p>In a computer program an object is a data type.  You can store data in it and
implement methods to manipulate that data.  Thus you can create a book object,
implement methods to write text in it and to read back that text.  Although
there are analogies with a real-world book, it's different: a book object can
read the text that it stores, a real-world book cannot.
</p>

<p>So, even though we talk about objects, keep in mind they are actually data
types.  This is important when designing a class hierarchy: The data fields and
methods of a child class must add something.  That's why we have the EXTEND
keyword, the child class extends the parent class.  Avoid the pointless
discussion of whether a rectangle is a kind of square or the other way around.
In practice it depends on what is inside the classes.  Don't start by deciding
what you call something, first find out what data it stores and what methods
you need, then decide what it should be called.
</div></div>
</p>

<p>The class name must start with an upper case letter and must be followed by at
least one lower case letter.  The second character cannot be an underscore.
Builtin types start with a lower case letter, that nicely creates two
namespaces and allows for adding more builtin types later.
</p>

<a name="CLASS_EXTEND"></a><div><h3>EXTEND</h3></div>

<p>TODO
</p>


<a name="CLASS_IMPLEMENTS"></a><div><h3>IMPLEMENTS</h3></div>

<p>TODO
</p>


<a name="CLASS_INCLUDE"></a><div><h3>INCLUDE</h3></div>

<p>An INCLUDE block can be used to compose a CLASS from other classes and pieces.
</p>

<pre class='vimCodeElement'>
<span class="Statement">CLASS</span> Address
  <span class="Type">string</span> $street
  <span class="Type">string</span> $city
<span class="Statement">}</span>
<span class="Statement">PIECE</span> Locator
  <span class="Statement">FUNC</span> $location() <span class="Type">string</span>
    <span class="Statement">RETURN</span> $street .. <span class="Constant">&quot;, &quot;</span> .. $city
  <span class="Statement">}</span>
<span class="Statement">}</span>
<span class="Statement">CLASS</span> Person
  <span class="Type">string</span> $name
  <span class="Statement">INCLUDE</span>
    Address   $address
    Locator   $locator
  <span class="Statement">}</span>
<span class="Statement">}</span>
Person p = <span class="PreProc">NEW</span>()
p.name = <span class="Constant">&quot;John Doe&quot;</span>
p.street = <span class="Constant">&quot;Langstraat 42&quot;</span>  <span class="Comment"># equivalent to setting p.address.street</span>
p.city = <span class="Constant">&quot;Amsterdam&quot;</span>
<span class="PreProc">IO</span>.print(p.location())      <span class="Comment"># prints: &quot;Langstraat 42, Amsterdam&quot;</span>
</pre>


<a name="CLASS_SHARED"></a><div><h3>SHARED</h3></div>

<p>Fields and methods declared in the SHARED section are available to all objects,
they are shared between all objects.  In C++ and Java these are called "static"
(which is a weird name).
</p>

<p>Fields and methods in the SHARED section do not start with a $, that makes them
easy to recognize.
</p>

<p>The methods in the SHARED section cannot directly access members of an object
or call object methods.  Thus members that start with a $.  They can be
accessed if the object reference is passed in:
</p>

<pre class='vimCodeElement'>
<span class="Statement">CLASS</span> Foo
  <span class="Type">int</span> $nr
  <span class="Statement">SHARED</span>
    <span class="Statement">FUNC</span> right(Foo f) <span class="Type">int</span>
      <span class="Statement">RETURN</span> f.nr
    <span class="Statement">}</span>
    <span class="Statement">FUNC</span> wrong() <span class="Type">int</span>
      <span class="Statement">RETURN</span> $nr  <span class="Comment"># ERROR!</span>
    <span class="Statement">}</span>
  <span class="Statement">}</span>
<span class="Statement">}</span>
</pre>

<p>There can be multiple SHARED sections in a CLASS. This is convenient for
keeping the shared members close to where they are used.
</p>

<p>Calling a method that is defined in the SHARED section of a class
does not require specifying the class name:
</p>
<ul>
<li>in the class itself
</li>
<li>in its SHARED section of the class
</li>
<li>in child classes
</li>
</ul>

<p>But not in the SHARED section of an inner class (a class defined in the scope
of the class).
</p>

<a name="CLASS_Constructor"></a><div><h3>Constructor</h3></div>

<p>An object is constructed from a class by calling a NEW() method.  Before the
statements in NEW() are executed the object is initialized.  This may involve
an $Init() method defined in the class.  This is explained in the section
<a href="#Object%32Initialization%32Sequence">Object Initialization Sequence</a>.
</p>

<p>There can be several NEW() methods with different types of arguments.
Which one is used is explained at the section <a href="#Method%32call">Method call</a>.
</p>

<p>If a class does not define a NEW() method then invoking NEW() on that class
will create an object with all members set to their default values.
</p>

<p>If a class defines a NEW() method that accepts a list it is used when a list is assigned to a variable of this class.  Similarly for a dict.  Examples:
</p>

<pre class='vimCodeElement'>
<span class="Statement">CLASS</span> MyList
  <span class="Type">list</span>&lt;<span class="Type">string</span>&gt; $items
  <span class="PreProc">NEW</span>(<span class="Type">list</span>&lt;<span class="Type">string</span>&gt; l)
    $items = l
  <span class="Statement">}</span>
<span class="Statement">}</span>
<span class="Statement">CLASS</span> MyDict
  <span class="Type">dict</span>&lt;<span class="Type">string</span>, <span class="Type">int</span>&gt; $lookup
  <span class="PreProc">NEW</span>(<span class="Type">dict</span>&lt;<span class="Type">string</span>, <span class="Type">int</span>&gt; d)
    $lookup = d
  <span class="Statement">}</span>
<span class="Statement">}</span>
...
MyList foo = [<span class="Constant">&quot;one&quot;</span>, <span class="Constant">&quot;two&quot;</span>, <span class="Constant">&quot;three&quot;</span>]            <span class="Comment"># Invokes MyList NEW()</span>
MyDict bar = [<span class="Constant">&quot;one&quot;</span>: 1, <span class="Constant">&quot;two&quot;</span>: 2, <span class="Constant">&quot;three&quot;</span>: 3]   <span class="Comment"># Invokes MyDict NEW()</span>
</pre>


<a name="CLASS_Destructor"></a><div><h3>Destructor</h3></div>

<p>See <a href="#Object%32Destruction">Object Destruction</a>.
</p>


<a name="CLASS_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
class-def   -&gt;  "CLASS"  sep  group-name  sep-with-eol
                   block-item*
                block-end  ;
</pre>


<hr>
<a name="INTERFACE"></a><h2>INTERFACE</h2>

<p>TODO
</p>

<p>The interface name must start with "I_" and must be followed by at least one
lower case letter.
</p>

<a name="INTERFACE_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
interface-def  -&gt;  "INTERFACE"  sep  group-name  sep-with-eol
                     block-item*
                   block-end  ;
</pre>

<hr>
<a name="PIECE"></a><h2>PIECE</h2>

<p>TODO
</p>

<p>The piece name must start with an upper case character and must be followed by
at least one lower case letter.
</p>

<a name="PIECE_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
piece-def      -&gt;  "PIECE"  sep  group-name  sep-with-eol
                      block-item*
                    block-end  ;
include-block  -&gt;  "INCLUDE" sep-with-eol
                     block-item*
                   block-end  ;
</pre>


<hr>
<a name="ENUM"></a><h2>ENUM</h2>

<p>TODO
</p>

<p>Example:
</p>

<pre class='vimCodeElement'>
<span class="Statement">ENUM</span> Color
  black
  white
  red
  green
<span class="Statement">}</span>
Color one = Color.green
<span class="PreProc">IO</span>.print(<span class="Constant">&quot;Color: \(</span>one<span class="Constant">)&quot;</span>)  <span class="Comment"># invokes one.ToString()</span>
</pre>

<p>The enum name must start with an upper case character and must be followed by
at least one lower case letter.
</p>

<p>The enum values must start with a lower case character and can be followed by
letters, numbers and an underscore (not two together).
</p>

<a name="ENUM_Enum%32value%32methods"></a><div><h3>Enum value methods</h3></div>

<p>Using the ToString() method on an enum value returns the name as specified in
the enum declaration as a string, as illustrated in the above example.
To do the opposite use FromString() on the Enum, see below.
</p>

<p>Using the value() method on an enum value returns the integer that is used for
that value.  The values are numbered sequentially, starting with zero.  Note
that this means that the values change whenever the list of values is changed.
</p>


<a name="ENUM_Enum%32methods"></a><div><h3>Enum methods</h3></div>

<p>Using the FromString(name) method on the enum returns the associated enum
value.  The name must match excactly.  When the name does not have a match the
first value is returned.  Example:
<pre class='vimCodeElement'>
Color red = Color.FromString(<span class="Constant">&quot;red&quot;</span>)
Color fail = Color.FromString(<span class="Constant">&quot;xxx&quot;</span>)  <span class="Comment"># will return Color.black</span>
</pre>
</p>

<p>Using FromStringOrThrow(name) is similar to FromString(name), but when the name
does not have a match then it throws E.BadValue.  Example:
<pre class='vimCodeElement'>
Color c
<span class="Type">string</span> name = <span class="Constant">&quot;xxx&quot;</span>
<span class="Statement">TRY</span>
  c = Color.FromStringOrThrow(name)
<span class="Statement">CATCH</span> <span class="PreProc">E</span>.BadValue e
  <span class="PreProc">IO</span>.print(<span class="Constant">&quot;There is no Color called &quot;</span> .. name)
<span class="Statement">}</span>
</pre>
</p>

<p>The Type() method returns a type describing the Enum.
</p>

<p>Not implemented yet: Define a method in the ENUM.
</p>

<a name="ENUM_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
enum-def   -&gt;  "ENUM"  sep  group-name  sep-with-eol
                  (( var-name sep )*  var-name  sep-with-eol )?
               block-end ;
</pre>

<hr>
<a name="BITS"></a><h2>BITS</h2>

<p>BITS is an integer where each bit or group of bits is given a specific meaning.
It's an efficient way to store several flags and small values in one value,
with the convenience of accessing them as if they were individual items.
</p>

<p>BITS is a value type, thus a copy is made when it is passed around.  It does
not need to be allocated, which makes it as efficient as an int.
</p>

<p>A BITS is often used to pass settings to a chain of functions, and allows the
fields to be changed when it is passed to another function.  For example, to
specify how a file is to be written:
<pre class='vimCodeElement'>
<span class="Statement">BITS</span> WriteFlags
  <span class="Type">bool</span>     $create           <span class="Comment"># create file when it does not exist</span>
  <span class="Type">bool</span>     $overwrite        <span class="Comment"># truncate an existing file</span>
  OnError  $errorHandling    <span class="Comment"># what to do on an error</span>
  <span class="Type">nat4</span>     $threads          <span class="Comment"># number of threads to be used for writing</span>
<span class="Statement">}</span>
<span class="Statement">FUNC</span> write(<span class="Type">string</span> name) <span class="Type">status</span>
  <span class="Statement">RETURN</span> write(name, create + overwrite + errorHandling=return)
<span class="Statement">}</span>
<span class="Statement">FUNC</span> writeFast(<span class="Type">string</span> name, WriteFlags flags) <span class="Type">status</span>
  <span class="Statement">RETURN</span> write(name, flags + threads=8)
<span class="Statement">}</span>
<span class="Statement">FUNC</span> write(<span class="Type">string</span> name, WriteFlags flags) <span class="Type">status</span>
  ...
</pre>
</p>

<p>These types are supported in a BITS:
</p>
<ul>
<li>bool
</li>
<li>int1  ...  int32
</li>
<li>nat1  ...  nat32
</li>
<li>EnumType
</li>
</ul>

<p>The current limitation is that up to 64 bits can be used.
</p>

<a name="BITS_Assignment"></a><div><h3>Assignment</h3></div>

<p>The assignment to a BITS variable is just like an assignment to any other value
type variable.  The expression on the right must evaluate to the correct BITS
type.
</p>

<p>There is one special value: Assigning zero to a BITS type resets all the fields
to their default value.
</p>

<a name="BITS_Values"></a><div><h3>Values</h3></div>

<p>The value of an individual field is assigned with the equal sign and followed
by the value, without any white space.  Examples:
<pre class='vimCodeElement'>
create=<span class="Constant">TRUE</span>
errorHandling=return
threads=3
</pre>
</p>

<p>The values of fields are combined with the plus sign, which must be surrounded
by white space.  Example:
<pre class='vimCodeElement'>
create=<span class="Constant">TRUE</span> + errorHandling=no + threads=3
</pre>
</p>

<a name="BITS_Expressions"></a><div><h3>Expressions</h3></div>

<p>The plus operator can be used to set fields to a value, using a field value as
specified above.  Example:
<pre class='vimCodeElement'>
WriteFlags wf1 = create + threads=2
WriteFlags wf2 = wf2 + threads=4    <span class="Comment"># assign 4 to wf2.threads</span>
</pre>
</p>

<p>The value of individual fields can be accessed like with object members:
variable-name dot field-name.
</p>

<a name="BITS_Methods"></a><div><h3>Methods</h3></div>

<p>The Standard method ToString() returns a string representation of the BITS.
NOT IMPLEMENTED YET, currently returns the int value.
</p>

<p>Methods can be defined inside the BITS.  This mostly works like methods defined in a CLASS.
NOT IMPLEMENTED YET.
</p>

<a name="BITS_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
bits-def  -&gt;  "BITS"  sep  group-name  sep-with-eol
                block-item*
              block-end  ;
</pre>

<p>The bits name must start with an upper case character and must be followed by
at least one lower case letter.
</p>


<hr>
<a name="Method%32Declaration"></a><h2>Method Declaration</h2>

<p>A method name used with PROC or FUNC must start with a lower case character,
unless it is a <a href="#Method%32Declaration_Predefined%32methods">predefined method</a>.
</p>

<a name="Method%32Declaration_Function%32Overloading"></a><div><h3>Function Overloading</h3></div>

<p>A method can be defined multiple times with the same name if the arguments are
different.  When there are optional arguments the arguments before them must be
different. When the last argument has "..." (varargs) then the arguments before
it must be different.  In short: the non-optional arguments must be different.
</p>

<p>What is considered to be different arguments depends on the rules for automatic
conversion.  This is explained at the section <a href="#Method%32call">Method call</a>.
</p>

<p>It is recommended to use the same name for methods that do almost the same
thing.  When the intention of the functions is different it's better to use a
different name than just using different arguments.
For example, if there is a method "append(int x)" there should not be a method
"append(int x, bool insert)", which inserts instead of appends.
</p>


<a name="Method%32Declaration_NEW"></a><div><h3>NEW</h3></div>

<p>NEW() is used to create an object from a class.  It is the object constructor.
This is not a normal method, it does not contain a RETURN statement, but the
caller will get the newly created object as if it was returned.
</p>

<p>See <a href="#CLASS_Constructor">Constructor</a>.
</p>


<a name="Method%32Declaration_PROC"></a><div><h3>PROC</h3></div>

<p>A procedure is declared like this:
<pre class='vimCodeElement'>
<span class="Statement">PROC</span> write(<span class="Type">string</span> text)
  fd.write(text)
<span class="Statement">}</span>
</pre>
</p>

<p>A procedure can also be defined in an expression.
In that case the name is omitted:
<pre class='vimCodeElement'>
<span class="Type">proc</span>&lt;<span class="Type">int</span>&gt; <span class="Type">callback</span> = <span class="Statement">PROC</span> (<span class="Type">int</span> result)
  <span class="PreProc">IO</span>.print(<span class="Constant">&quot;Received: &quot;</span> .. result)
<span class="Statement">}</span>
</pre>
Only use this for short methods, for longer ones it's better to define them
elsewhere.  When the argument types can be figured out from the context it is
possible to use a Lambda expression or method, see the sections below.
</p>


<a name="Method%32Declaration_FUNC"></a><div><h3>FUNC</h3></div>

<p>A function is just like a procedure, but additionally returns a value.  The
type of the return value goes after the arguments:
<pre class='vimCodeElement'>
<span class="Statement">FUNC</span> write(<span class="Type">string</span> text) <span class="Type">status</span>
  <span class="Statement">RETURN</span> fd.write(text)
<span class="Statement">}</span>
</pre>
</p>

<p>The RETURN statement with an expression of the specified return type is the
only way a FUNC may end.
</p>

<p>Multiple values can be returned at once.  The types are listed separated with a
comma.  And the RETURN statement has a comma separated list of expressions.
Example:
<pre class='vimCodeElement'>
<span class="Statement">FUNC</span> $read() <span class="Type">string</span>, <span class="Type">status</span>
  <span class="Statement">IF</span> $closed
    <span class="Statement">RETURN</span> <span class="Constant">&quot;&quot;</span>, <span class="Constant">FAIL</span>
  <span class="Statement">}</span>
  <span class="Statement">RETURN</span> $fd.read(), <span class="Constant">OK</span>
<span class="Statement">}</span>
</pre>
</p>

<p>It is recommended to add a comment about what is returned, especially if this
is not obvious:
<pre class='vimCodeElement'>
<span class="Statement">FUNC</span> minMax() <span class="Type">int</span> <span class="Comment">/* minimum */</span>, <span class="Type">int</span> <span class="Comment">/* maximum */</span>
  ...
  <span class="Statement">RETURN</span> min, max
<span class="Statement">}</span>
</pre>
</p>

<p>To use only one of the returned values add a subscript:
<pre class='vimCodeElement'>
<span class="Statement">FUNC</span> tryIt() <span class="Type">int</span>, <span class="Type">string</span>
  <span class="Statement">RETURN</span> 33, <span class="Constant">&quot;yes&quot;</span>
<span class="Statement">}</span>
...
<span class="PreProc">IO</span>.print(tryIt()[0])  <span class="Comment"># prints &quot;33&quot;</span>
<span class="PreProc">IO</span>.print(tryIt()[1])  <span class="Comment"># prints &quot;yes&quot;</span>
</pre>
</p>

<p>Do not return more than a few values, otherwise it may be difficult to
understand what the code is doing.
</p>

<p>A function can also be defined in an expression.
In that case the name is omitted:
<pre class='vimCodeElement'>
<span class="Type">func</span>&lt;<span class="Type">int</span> =&gt; <span class="Type">int</span>&gt; nextNr = <span class="Statement">FUNC</span> (<span class="Type">int</span> increment) <span class="Type">int</span>
  counter += increment
  <span class="Statement">RETURN</span> counter
<span class="Statement">}</span>
</pre>
Only use this for short methods, for longer ones it's better to define them
elsewhere.  When the argument and return types can be figured out from the
context it is possible to use a Lambda expression or method, see the next
sections.
</p>


<a name="Method%32Declaration_Lambda%32expression"></a><div><h3>Lambda expression</h3></div>

<p>This is shorthand for defining a PROC or a FUNC that only evaluates one
expression.  Lambda functions are especially useful for the map() and keyMap()
methods of containers:
<pre class='vimCodeElement'>
intDict.map({ v =&gt; v + 3 <span class="Statement">}</span>)                    <span class="Comment"># add 3 to every item</span>
stringDict.keyMap({ k, v =&gt; k .. <span class="Constant">&quot;: &quot;</span> .. v <span class="Statement">}</span>)  <span class="Comment"># every items becomes &quot;key: value&quot;</span>
</pre>
The types of the arguments and the return type are inferred from the context.
Therefore the context must have these types.  Illustration:
<pre class='vimCodeElement'>
<span class="Type">VAR</span> <span class="Type">callback</span> = { a, b =&gt; a * b <span class="Statement">}</span>                  <span class="Comment"># ERROR: types can't be inferred.</span>
<span class="Type">func</span>&lt;<span class="Type">int</span>, <span class="Type">int</span> =&gt; <span class="Type">int</span>&gt; <span class="Type">callback</span> = { a, b =&gt; a * b <span class="Statement">}</span>  <span class="Comment"># OK</span>
</pre>
</p>

<p>Before the => is the comma separated list of arguments.  This is like in a
method declaration, but without types.  If there are no arguments use white
space.
</p>

<p>After the => goes a single expression.  For a FUNC this is what is returned.
For a PROC it must have a side effect to be useful.
</p>


<a name="Method%32Declaration_LAMBDA%32method"></a><div><h3>LAMBDA method</h3></div>

<p>This is shorthand for defining a nameless PROC or a FUNC.  Lambda methods are
especially useful for the map() and keyMap() methods of containers that consist
of a few statements:
<pre class='vimCodeElement'>
intDict.map(<span class="Statement">LAMBDA</span> (v); count(); <span class="Statement">RETURN</span> v + 3; <span class="Statement">}</span>)      <span class="Comment"># add 3 to every item</span>
stringDict.keyMap(<span class="Statement">LAMBDA</span> (k, v)
    <span class="PreProc">IO</span>.print(<span class="Constant">&quot;processing &quot;</span> .. k)
    <span class="Statement">RETURN</span> k .. <span class="Constant">&quot;: &quot;</span> .. v  <span class="Comment"># every items becomes &quot;key: value&quot;</span>
  <span class="Statement">}</span>)
</pre>
The types of the arguments and the return type are inferred from the context.
Therefore the context must have these types.  Illustration:
<pre class='vimCodeElement'>
<span class="Type">VAR</span> <span class="Type">callback</span> = <span class="Statement">LAMBDA</span> (a, b); <span class="Statement">RETURN</span> a * b; <span class="Statement">}</span>    <span class="Comment"># ERROR: types can't be inferred.</span>
<span class="Type">func</span>&lt;<span class="Type">int</span>, <span class="Type">int</span> =&gt; <span class="Type">int</span>&gt; <span class="Type">callback</span> = <span class="Statement">LAMBDA</span> (a, b); <span class="Statement">RETURN</span> a * b; <span class="Statement">}</span>  <span class="Comment"># OK</span>
</pre>
</p>

<p>Inside the parenthesis after LAMBDA is the list of arguments.  This is like in
a method declaration, but without types.  If there are no arguments use "()".
</p>

<p>The statements can either be on a separate line, or separated with a semicolon.
</p>

<a name="Method%32Declaration_Optional%32arguments"></a><div><h3>Optional arguments</h3></div>

<p>Arguments can be declared to have a default value.  In that case the argument can be omitted and the default value will be used.
</p>

<p>When an argument has a default value, all following arguments must have a default value.
</p>

<pre class='vimCodeElement'>
<span class="Statement">PROC</span> foo(<span class="Type">int</span> x, <span class="Type">int</span> y = 0, <span class="Type">int</span> z = 0)
  <span class="PreProc">IO</span>.print(<span class="Constant">&quot;x:\(</span>x<span class="Constant">) y:\(</span>y<span class="Constant">) z:\(</span>z<span class="Constant">)&quot;</span>)
<span class="Statement">}</span>
foo(3)         <span class="Comment"># prints &quot;x:3 y:0 z:0&quot;</span>
foo(3, 7)      <span class="Comment"># prints &quot;x:3 y:7 z:0&quot;</span>
foo(3, 7, 11)  <span class="Comment"># prints &quot;x:3 y:7 z:11&quot;</span>
</pre>


<a name="Method%32Declaration_Variable%32number%32of%32arguments%32%40varargs%41"></a><div><h3>Variable number of arguments (varargs)</h3></div>

<p>The last argument may have "..." between the type and the name.  This means
this argument can be present zero or more times in the call.
</p>

<p>Example:
<pre class='vimCodeElement'>
<span class="Statement">FUNC</span> add(<span class="Type">int</span> ... numbers) <span class="Type">int</span>
  <span class="Type">int</span> result
  <span class="Statement">FOR</span> nr <span class="Statement">IN</span> numbers.values
    result += nr
  <span class="Statement">}</span>
  <span class="Statement">RETURN</span> result
<span class="Statement">}</span>
<span class="PreProc">IO</span>.print(add(1, 2, 3))   <span class="Comment"># prints 6</span>
<span class="PreProc">IO</span>.print(add())          <span class="Comment"># prints 0</span>
</pre>
</p>

<p>When using the argument in the method the type is a tuple with two arrays:
tuple&lt;array&lt;string&gt; names, array&lt;arg-type&gt; values&gt;.
This tuple and the arrays cannot be changed.
</p>

<p>A short name for the tuple is varargs&lt;arg-type&gt;.
</p>

<p>Example:
<pre class='vimCodeElement'>
<span class="Statement">PROC</span> show(<span class="Type">int</span> ... numbers)
  <span class="Statement">FOR</span> idx <span class="Statement">IN</span> 0 <span class="Statement">UNTIL</span> numbers.values.Size()
    <span class="PreProc">IO</span>.print(<span class="Constant">&quot;\(</span>numbers.names[idx]<span class="Constant">) is \(</span>numbers.values[idx]<span class="Constant">)&quot;</span>)
  <span class="Statement">}</span>
<span class="Statement">}</span>
show(one = 1, five = 5)   <span class="Comment"># prints &quot;one is 1&quot;, &quot;five is 5&quot;</span>
</pre>
</p>

<p>To pass the varargs to another method, or to pass a tuple as the varargs
argument, pass it by name.  Example using the show() function from above:
<pre class='vimCodeElement'>
  varargs&lt;<span class="Type">int</span>&gt; tup = [[<span class="Constant">&quot;a&quot;</span>, <span class="Constant">&quot;b&quot;</span>], [3, 9]]
  show(numbers = tup)
</pre>
Note that "numbers" is the name of the varargs argument.
</p>

<p>A function cannot have both optional arguments and varargs.
</p>


<a name="Method%32Declaration_Closure%32and%32USE%32arguments"></a><div><h3>Closure and USE arguments</h3></div>

<p>A method can pick up variables from its context.  The method is then called a
closure.
</p>

<p>Let's start with an example for USE by value:
<pre class='vimCodeElement'>
<span class="Type">string</span> m = <span class="Constant">&quot;one&quot;</span>
<span class="Statement">PROC</span> display(<span class="Type">USE</span> m)
  <span class="PreProc">IO</span>.print(m)
<span class="Statement">}</span>
display()  <span class="Comment"># displays &quot;one&quot;</span>
m = <span class="Constant">&quot;two&quot;</span>
display()  <span class="Comment"># displays &quot;one&quot;</span>
<span class="Type">proc</span>&lt;&gt; p = display
m = <span class="Constant">&quot;three&quot;</span>
p()        <span class="Comment"># displays &quot;one&quot;</span>
</pre>
</p>

<p>You can see that the value of "m" is taken at the moment when the PROC is
defined.  Changing "m" later has no effect.
</p>

<p>To use the changed value of "m" it has to be a USE by reference:
<pre class='vimCodeElement'>
<span class="Type">string</span> m = <span class="Constant">&quot;one&quot;</span>
<span class="Statement">PROC</span> display(<span class="Type">USE</span> &amp;m)
  <span class="PreProc">IO</span>.print(m)
<span class="Statement">}</span>
display()  <span class="Comment"># displays &quot;one&quot;</span>
m = <span class="Constant">&quot;two&quot;</span>
display()  <span class="Comment"># displays &quot;two&quot;</span>
<span class="Type">proc</span>&lt;&gt; p = display
m = <span class="Constant">&quot;three&quot;</span>
p()        <span class="Comment"># displays &quot;three&quot;</span>
</pre>
</p>

<p>If the variable is not a simple name, it must be given one with AS:
<pre class='vimCodeElement'>
<span class="Statement">CLASS</span> Foo
  <span class="Statement">SHARED</span>
    <span class="Type">string</span> foo = <span class="Constant">&quot;foo&quot;</span>
    <span class="Type">string</span> bar = <span class="Constant">&quot; bar&quot;</span>
  <span class="Statement">}</span>
<span class="Statement">}</span>
Foo.foo = <span class="Constant">&quot;two&quot;</span>
<span class="Statement">PROC</span> display(<span class="Type">USE</span> Foo.foo <span class="Statement">AS</span> f, Foo.bar <span class="Statement">AS</span> b)
  <span class="PreProc">IO</span>.print(f .. b)
<span class="Statement">}</span>
display()  <span class="Comment"># displays &quot;two bar&quot;</span>
</pre>
</p>

<p>The USE keyword must come after the normal arguments.  There must be a space
before and after USE. When there is no normal argument there must be a space
after it only.  There is no comma before USE.
</p>

<p>An example that has a bit more usefulness (translated from the Python example on Wikipedia):
<pre class='vimCodeElement'>
<span class="Statement">FUNC</span> getCounter() <span class="Type">proc</span>&lt;<span class="Type">int</span>&gt;
  <span class="Type">int</span> x
  <span class="Statement">PROC</span> increment(<span class="Type">int</span> y <span class="Type">USE</span> &amp;x)
    x += y
    <span class="PreProc">IO</span>.print(<span class="Constant">&quot;total: &quot;</span> .. x)
  <span class="Statement">}</span>
  <span class="Statement">RETURN</span> increment
<span class="Statement">}</span>
<span class="Type">VAR</span> increment1 = getCounter()
<span class="Type">VAR</span> increment2 = getCounter()
increment1(1)     <span class="Comment"># prints 1</span>
increment1(7)     <span class="Comment"># prints 8</span>
increment2(1)     <span class="Comment"># prints 1</span>
increment1(1)     <span class="Comment"># prints 9</span>
increment2(1)     <span class="Comment"># prints 2</span>
</pre>
</p>

<p>What happens here is that the variable "x" in getCounter() is referenced by the
callback stored in increment1, even though the function itself has returned and
the scope no longer exists.  Zimbu recognizes this situation and puts "x" into
allocated memory.  This happens every time getCounter() is called, thus
increment1 and increment2 each have their own instance of "x".
</p>

<p>The USE arguments can also be used with lambda functions.
Here is an example with a lambda function and a thread:
<pre class='vimCodeElement'>
<span class="Type">string</span> m = <span class="Constant">&quot;world&quot;</span>
<span class="Type">pipe</span>&lt;<span class="Type">string</span>&gt; sp = Z.<span class="Type">evalThread</span>&lt;<span class="Type">string</span>&gt;.<span class="PreProc">NEW</span>().eval({ <span class="Type">USE</span> m =&gt; <span class="Constant">&quot;hello &quot;</span> .. m <span class="Statement">}</span>)
<span class="PreProc">IO</span>.print(sp.read())
</pre>
</p>

<a name="Method%32Declaration_Predefined%32methods"></a><div><h3>Predefined methods</h3></div>

<p>Method names starting with an upper case letter are reserved for predefined
methods.  You can define these methods in your class or module. They must
behave as specified, have the specified arguments and return type.
</p>

<pre class='vimCodeElement'>
    <span class="Statement">FUNC</span> Main() <span class="Type">int</span>
</pre>
<p>Main() is the program entrance point.  It can only appear at the toplevel of
the main program file.  Also see <a href="#File%32Level_Main%40%41">File Level</a>.
</p>

<pre class='vimCodeElement'>
    <span class="Statement">FUNC</span> Init() <span class="Type">status</span>
</pre>
<p>Used in a module or shared section of a class.  Invoked during the
<a href="#Startup%32Sequence">startup sequence</a>.
</p>

<pre class='vimCodeElement'>
    <span class="Statement">FUNC</span> EarlyInit() <span class="Type">status</span>
</pre>
<p>Used in a module or shared section of a class.  Invoked during the
<a href="#Startup%32Sequence">startup sequence</a>.
</p>

<pre class='vimCodeElement'>
    <span class="Statement">FUNC</span> $ToString() <span class="Type">string</span>
</pre>
<p>Returns a string representation of the object.  If a class does not define a
ToString method, one is generated that lists the value of every member, using
curly braces, similar to an initializer for the object.
<pre class='vimCodeElement'>
    <span class="Statement">CLASS</span> NoToString
      <span class="Type">int</span> $value
      <span class="Type">string</span> $name
    <span class="Statement">}</span>
    NoToString nts = <span class="PreProc">NEW</span>()
    nts.value = 555
    nts.name = <span class="Constant">&quot;foobar&quot;</span>
    <span class="PreProc">IO</span>.print(nts.ToString())  <span class="Comment"># result: {value: 555, name: &quot;foobar&quot;}</span>
</pre>
</p>

<pre class='vimCodeElement'>
    <span class="Statement">FUNC</span> $Type() <span class="Type">type</span>
</pre>
<p>Returns a type object, which contains information about the type.
Especially useful to find out what a "dyn" variable contains.
</p>

<pre class='vimCodeElement'>
    <span class="Statement">FUNC</span> $Size() <span class="Type">int</span>
</pre>
<p>Returns the number of items.  For a primitive type (int, nat, float, etc.) this
can be the number of bytes.  For a string it is the number of characters, for a byteString it is the number of bytes.
</p>

<pre class='vimCodeElement'>
    <span class="Statement">FUNC</span> $Equal(Titem other) <span class="Type">bool</span>
</pre>
<p>Makes it possible to compare the value of two objects. It must return TRUE when
the value of the object is equal to "other".
</p>

<p>This does not necessarily mean all members of the object have the same value.
For example, cached results of computations can be ignored.
</p>

<p>Defining the $Equal() method on an object makes it possible to use the "==" and
"!=" operators.
</p>

<pre class='vimCodeElement'>
    <span class="Statement">FUNC</span> $Compare(Titem other) <span class="Type">int</span>
</pre>
<p>Must return zero when the object value is equal to "other", smaller than zero
when the object value is smaller than "other", and larger than zero when the
object value is larger than "other".
</p>

<p>If the relevant value of the object is "int $value", it can be implemented like this:
<pre class='vimCodeElement'>
<span class="Statement">FUNC</span> $Compare(Titem other) <span class="Type">int</span>
  <span class="Statement">RETURN</span> $value - other.value
<span class="Statement">}</span>
</pre>
</p>

<p>Defining the $Compare() method on an object makes it possible to use the "&gt;",
"&gt;=", "&lt;" and "&lt;=" operators.
</p>

<pre class='vimCodeElement'>
    <span class="Statement">FUNC</span> $Init() <span class="Type">status</span>
</pre>
<p>Used for initializing an object.
See <a href="#Object%32Initialization%32Sequence">Object Initialization Sequence</a>.
</p>

<pre class='vimCodeElement'>
    <span class="Statement">FUNC</span> $Finish() <span class="Type">status</span>
    <span class="Statement">FUNC</span> $Finish(Z.FinishReason fr) <span class="Type">status</span>
</pre>
<p>Used when an object is about to be destructed.
</p>

<p>When the Z.FinishReason is <b>unused</b> or <b>called</b>, and the method
returns OK it will not be called again.  When it returns FAIL it will be called
again the next time when the object is about to be destructed.
</p>

<p>When the Z.FinishReason is <b>leave</b> or <b>exit</b> Finish() is only called
once.  The return value is ignored.
</p>

<p>See <a href="#Object%32Destruction">Object Destruction</a>.
</p>


<a name="Method%32Declaration_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<p>TODO: lambda method
</p>

<p>TODO: PROC and FUNC without a name, used in an expression
</p>

<pre>
method-def     -&gt;  func-def | proc-def | new-def ;
func-def       -&gt;  "FUNC"  sep  var-name  method-args  ":"  sep  type  method-common ;
proc-def       -&gt;  "PROC sep var-name  method-args method-common  ;
new-def        -&gt;  "NEW"  method-args  method-common  ;
method-args    -&gt;  "(" sep-with-eol?  arg-defs? ")"
arg-defs       -&gt;  arg-def  ( ","  sep  arg-def ) *  skip  ;
arg-def        -&gt;  type  sep  "&amp;"?  var-name ;
arguments      -&gt;  "&amp;"?  expr  ( ","   sep   "&amp;"?  expr )*  ;
method-common  -&gt;  sep-with-eol
                     block-item*
                   block-end  ;
</pre>


<hr>
<a name="Variable%32Declaration"></a><h2>Variable Declaration</h2>

<p>Variables can be declared in these scopes:
</p>
<ol>
<li>Inside a method.  The variable is then available for use until the end of
    the statement block.  It cannot be used before the declaration.
</li>
<li>In the scope of a class, with $ prepended to the name.  The variable
    becomes a member of the class and can be used before its declaration.
</li>
<li>Inside a module.  The variable becomes a member of the module and can also
    be used before its declaration.
</li>
<li>Inside a SHARED section in a class.  The variable becomes a member of the
    class and can also be used before its declaraiton.
</li>
<li>In the main program file.  It can be used in that file, also before its
    declaration.
</li>
</ol>

<p>It is not allowed to declare a variable with the same name as a method.
</p>

<p>It is not allowed to declare a variable with the same name, where it could be
used.
</p>

<p>Variables can be declared with these statements:
<pre class='vimCodeElement'>
Type varName         <span class="Comment"># simple variable declaration</span>
Type varName = expr  <span class="Comment"># simple variable declaration with initialization</span>
Type var1, var2      <span class="Comment"># declare multiple variables of the same type</span>
</pre>
Note that when declaring multiple variables it is not possible to initialize
any of them.
</p>


<a name="Variable%32Declaration_VAR"></a><div><h3>VAR</h3></div>

<p>In a variable declaration <b>VAR</b> can be used instead of the type.  The type will
then be inferred from the first assignment.  If the variable has an
initializer that is the first assignment.
<pre class='vimCodeElement'>
    <span class="Type">VAR</span> s = <span class="Constant">&quot;string&quot;</span>  <span class="Comment"># type inferred from initializer</span>
    <span class="Type">VAR</span> n
    n = 15 * 20       <span class="Comment"># int type inferred from first assignment</span>
    n = <span class="Constant">&quot;string&quot;</span>      <span class="Comment"># ERROR, n is an int</span>
</pre>
</p>

<p>Note that <b>VAR</b> and the <b>dyn</b> type are very different.  <b>VAR</b> gets it type at
runtime, the compiler infers it from how the variable is used.  A variable of
the <b>dyn</b> type can store any type of value.
<pre class='vimCodeElement'>
    <span class="Type">dyn</span> s = <span class="Constant">&quot;string&quot;</span>  <span class="Comment"># type of s is a string</span>
    s = 15 * 20       <span class="Comment"># type of s is now an int</span>
    s = <span class="Constant">&quot;string&quot;</span>      <span class="Comment"># type of s is a string again</span>
</pre>
</p>

<p>When the initialization value is a constant or a computation of constants, and
the value does not fit in the variable the compiler produces an error.  When
the initialization is an expression this does not happen.
</p>

<a name="Variable%32Declaration_STATIC"></a><div><h3>STATIC</h3></div>

<p>A variable declared inside a method normally only exists while executing the
method, it is located on the stack.
To have a variable exist forever, prepend STATIC.  The variable will then be
located in static memory.
<pre class='vimCodeElement'>
<span class="Statement">PROC</span> printStartTime()
  <span class="Statement">STATIC</span> <span class="Type">int</span> startTime
  <span class="Statement">IF</span> startTime == 0
    startTime = <span class="PreProc">TIME</span>.current()
  <span class="Statement">}</span>
  <span class="PreProc">IO</span>.print(<span class="PreProc">TIME</span>.Values.<span class="PreProc">NEW</span>(startTime).ToString())
<span class="Statement">}</span>
printStartTime()  <span class="Comment"># prints the current time</span>
<span class="PreProc">TIME</span>.sleepSec(3)
printStartTime()  <span class="Comment"># prints the same time again</span>
</pre>
</p>

<p>Variables declared with STATIC are shared by all calls to the method.
Only one variable exists, no matter how often the method is called.
Still, the variable can only be accessed inside the method, it is not visible
outside the method.
</p>

<p>The static variable can be initialized.  The expression must evaluate to a
constant.
</p>

<p>There is no thread safety, all methods share the same variable.
</p>


<a name="Variable%32Declaration_Simplified%32Syntax"></a><div><h3>Simplified Syntax</h3></div>

<pre>
[STATIC] type name [attribute-list] [= expression]
</pre>
<table cellpadding=0 cellspacing=0 border=0>
<tr valign="top"><td class="firstcol">[STATIC]      </td><td class="col"></td><td class="col">optional</td></tr>
<tr valign="top"><td class="firstcol">type          </td><td class="col"></td><td class="col">The type name, such as "int", "string" or "MyClass".  VAR
                      can also be used here.</td></tr>
<tr valign="top"><td class="firstcol">name          </td><td class="col"></td><td class="col">The variable name, e.g., "$foo" or "foo".</td></tr>
<tr valign="top"><td class="firstcol">attribute-list</td><td class="col"></td><td class="col">Optional attributes, such as @public.</td></tr>
<tr valign="top"><td class="firstcol">= expression  </td><td class="col"></td><td class="col">Initializer.  When using the VAR type also infers the
                      variable type.</td></tr>
</td></tr></table>

<p>Examples:
<pre class='vimCodeElement'>
<span class="Type">int</span> i
<span class="Type">string</span> hello = <span class="Constant">&quot;Hello&quot;</span>
<span class="Type">VAR</span> ref <span class="PreProc">@public</span>
<span class="Statement">STATIC</span> <span class="Type">int</span> startTime
</pre>
</p>

<a name="Variable%32Declaration_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
var-def   -&gt;  type  sep  var-decl ( skip  ","  sep  var-decl )*  line-sep ;
var-decl  -&gt;  var-name  attribute*  var-init? ;
var-init  -&gt;  sep  "="  sep  expr ;
</pre>

<a name="Variable%32Declaration_Variable%32Names"></a><div><h3>Variable Names</h3></div>

<p>In a class, not in the SHARED section, all variable names start with a dollar
and then a lower case letter.  Example:
</p>

<pre class='vimCodeElement'>
<span class="Statement">CLASS</span> Foo
  <span class="Type">string</span> $name
<span class="Statement">}</span>
</pre>

<p>Everywhere else the variable names start with a lower case letter. Example:
</p>

<pre class='vimCodeElement'>
<span class="Statement">PROC</span> foo()
  <span class="Type">string</span> name
<span class="Statement">}</span>
</pre>


<a name="Variable%32Declaration_Attributes"></a><div><h3>Attributes</h3></div>

<p>TODO
</p>

<p>The @local attribute can be used on members and methods of a class and a piece.
The effect is that the declaration is local to the scope where it is defined.
It is not visible in child classes, interfaces and, for a piece, the class
where it is included.
</p>

<p>For example, this piece keeps $done and $maxVal local.  A class that includes
this piece may define $done and $maxVal without causing a conflict.
<pre class='vimCodeElement'>
<span class="Statement">PIECE</span> Max
  <span class="Type">bool</span> $done <span class="PreProc">@local</span>
  <span class="Type">int</span>  $maxVal <span class="PreProc">@local</span>
       = <span class="PreProc">T</span>.<span class="Type">int</span>.min

  <span class="Statement">FUNC</span> $max() <span class="Type">int</span>
    <span class="Statement">IF</span> !$done
      $done = <span class="Constant">TRUE</span>
      <span class="Statement">FOR</span> n <span class="Statement">IN</span> $Iterator()
        <span class="Statement">IF</span> n &gt; $maxVal
          $maxVal = n
        <span class="Statement">}</span>
      <span class="Statement">}</span>
    <span class="Statement">}</span>
    <span class="Statement">RETURN</span> $maxVal
  <span class="Statement">}</span>
<span class="Statement">}</span>
</pre>
</p>


<a name="Variable%32Declaration_Initializer"></a><div><h3>Initializer</h3></div>

<p>TODO
</p>


<hr>
<a name="Types"></a><h1>Types</h1>

<p>Although Zimbu does not follow the "everything is an object" concept, you can
use every type like it was an object.  For example, you can invoke a method on
a value type:
</p>

<pre class='vimCodeElement'>
<span class="Type">bool</span> nice
<span class="PreProc">IO</span>.print(nice.ToString())
<span class="PreProc">IO</span>.print(1234.toHex())
</pre>


<hr>
<a name="Value%32types"></a><h2>Value types</h2>

<p>Value types, such as int and bool, are passed around by value.  Every time it
is passed as an argument to a method and when assigned to another variable a
copy is made.  When changing the original value the copy remains unchanged.
</p>

<pre class='vimCodeElement'>
<span class="Type">int</span> aa = 3       <span class="Comment"># </span><span class="Ignore">|</span><span class="Constant">aa</span><span class="Ignore">|</span><span class="Comment"> is assigned the value 3</span>
someMethod(aa)   <span class="Comment"># </span><span class="Ignore">|</span><span class="Constant">aa</span><span class="Ignore">|</span><span class="Comment"> is still 3, no matter what someMethod() does.</span>
<span class="Type">int</span> bb = aa      <span class="Comment"># the value of </span><span class="Ignore">|</span><span class="Constant">aa</span><span class="Ignore">|</span><span class="Comment"> is copied to </span><span class="Ignore">|</span><span class="Constant">bb</span><span class="Ignore">|</span>
bb = 8           <span class="Comment"># </span><span class="Ignore">|</span><span class="Constant">aa</span><span class="Ignore">|</span><span class="Comment"> is still 3, changing </span><span class="Ignore">|</span><span class="Constant">bb</span><span class="Ignore">|</span><span class="Comment"> has no effect on that.</span>
</pre>

<p>Value types always have a valid value, there is no "undefined" state.  There is
a default value, but you can't tell whether that was from an assignment or not.
</p>

<p>See <a href="#Builtin%32Types_Value%32types">below</a> for the list of builtin value types.
</p>

<p><a href="#BITS">BITS</a> is a special kind of value type. It contains several small
fields, like a class.  But it is passed by value, unlike objects.
</p>


<hr>
<a name="Reference%32types"></a><h2>Reference types</h2>

<p>Reference types, such as string, list and objects, are passed around by
reference.  When two variables reference to the same item, changing one also
changes the other.
</p>

<pre class='vimCodeElement'>
<span class="Type">list</span>&lt;<span class="Type">string</span>&gt; aa = [<span class="Constant">&quot;one&quot;</span>]
someMethod(aa)            <span class="Comment"># </span><span class="Ignore">|</span><span class="Constant">aa</span><span class="Ignore">|</span><span class="Comment"> may have been changed by someMethod()</span>
<span class="Type">list</span>&lt;<span class="Type">string</span>&gt; bb = aa      <span class="Comment"># </span><span class="Ignore">|</span><span class="Constant">bb</span><span class="Ignore">|</span><span class="Comment"> refers to the same list as </span><span class="Ignore">|</span><span class="Constant">aa</span><span class="Ignore">|</span>
bb.add(<span class="Constant">&quot;two&quot;</span>)             <span class="Comment"># </span><span class="Ignore">|</span><span class="Constant">aa</span><span class="Ignore">|</span><span class="Comment"> is now [&quot;one&quot;, &quot;two&quot;], as is </span><span class="Ignore">|</span><span class="Constant">bb</span><span class="Ignore">|</span>
</pre>

<p>However, the reference itself is a value that is copied.  Example:
</p>

<pre class='vimCodeElement'>
<span class="Type">list</span>&lt;<span class="Type">string</span>&gt; aa = [<span class="Constant">&quot;one&quot;</span>]
<span class="Type">list</span>&lt;<span class="Type">string</span>&gt; bb = aa
bb = [<span class="Constant">&quot;two&quot;</span>]            <span class="Comment"># </span><span class="Ignore">|</span><span class="Constant">aa</span><span class="Ignore">|</span><span class="Comment"> is unchanged</span>
</pre>

<p>The default value for all reference types is NIL.  That means it refers to
nothing.  Trying to use the NIL value usually leads to an E.NilAccess
exception.  You usually call NEW() to create an instance of a reference type.
</p>

<p>See <a href="#Builtin%32Types_String%32types">below</a> for the list of builtin reference
types: <a href="#Builtin%32Types_String%32types">string types</a>,
<a href="#Builtin%32Types_Container%32types">container types</a> and
<a href="#Builtin%32Types_Other%32types">other types</a>.
</p>

<a name="Reference%32types_Reference%32to%32a%32variable"></a><div><h3>Reference to a variable</h3></div>

<p>Any variable, also value typed variables, can be referred to with the "&"
operator.  This results in a reference to the variable and must be declared as
such.
</p>

<pre class='vimCodeElement'>
<span class="Type">int</span> aa = 4
someMethod(&amp;aa)    <span class="Comment"># </span><span class="Ignore">|</span><span class="Constant">aa</span><span class="Ignore">|</span><span class="Comment"> may have been changed by someMethod()</span>
</pre>

<p>Use this with care, it can be confusing.  Especially when referencing a
variable of reference type.  For returning more than one value from a function
you can do this directly.  It is useful for passing a variable both for input
and output, e.g. a counter.
</p>


<a name="Reference%32types_Reference%32to%32a%32method"></a><div><h3>Reference to a method</h3></div>

<p>There are three method reference types:
</p>

<table cellpadding=3 cellspacing=0 border=1>
<tr valign="top"><td class="firstcol">proc    </td><td class="col">reference to a PROC </td></tr>
<tr valign="top"><td class="firstcol"> func    </td><td class="col">reference to a FUNC </td></tr>
<tr valign="top"><td class="firstcol"> callback</td><td class="col">reference to a PROC or FUNC with extra arguments </td></tr>
</td></tr></table>

<p>Type declaration examples:
<pre class='vimCodeElement'>
<span class="Type">proc</span>&lt;<span class="Type">string</span>&gt;       <span class="Comment"># A reference to a PROC taking one string argument.</span>
<span class="Type">proc</span>&lt;&gt;             <span class="Comment"># A reference to a PROC without arguments.</span>
<span class="Type">func</span>&lt;<span class="Type">int</span> =&gt; <span class="Type">int</span>&gt;   <span class="Comment"># A reference to a FUNC taking one int argument and returning an int.</span>
<span class="Type">func</span>&lt; =&gt; <span class="Type">string</span>&gt;   <span class="Comment"># A reference to a FUNC without arguments and returning a string.</span>
<span class="Type">callback</span>&lt;<span class="Type">proc</span>&lt;<span class="Type">int</span>&gt;, <span class="Type">int</span>&gt;  <span class="Comment"># A reference to a PROC with two int arguments, one of which is stored in the callback.</span>
</pre>
Note the use of "=>" between arguments and the return type of a FUNC.
You can pronounce "=>" as "gives".
There is always a space before and after the "=>".
</p>

<p>Calling a method using the reference is just like a method call:
<pre class='vimCodeElement'>
<span class="Type">func</span>&lt;<span class="Type">int</span> =&gt; <span class="Type">string</span>&gt; f = { n =&gt; <span class="Constant">&quot;number &quot;</span> .. n <span class="Statement">}</span>
<span class="PreProc">IO</span>.print(f(3))
<span class="Comment"># output: number 3</span>
</pre>
</p>

<p>A callback has two method type specifications:
</p>
<ol>
<li>The inner method, the type specification used when passing around the
   callback and when invoking the method.
</li>
<li>The outer method, the actually called method, using the arguments of the
   inner method plus the other types in the callback.
</li>
</ol>

<p>Example:
<pre class='vimCodeElement'>
<span class="Statement">PROC</span> add(<span class="Type">int</span> val, <span class="Type">int</span> inc)
  <span class="PreProc">IO</span>.print(val + inc)
<span class="Statement">}</span>
<span class="Type">callback</span>&lt;<span class="Type">proc</span>&lt;<span class="Type">int</span>&gt;, <span class="Type">int</span>&gt; addFive = <span class="PreProc">NEW</span>(add, 5)
<span class="Type">callback</span>&lt;<span class="Type">proc</span>&lt;<span class="Type">int</span>&gt;, <span class="Type">int</span>&gt; addEight = <span class="PreProc">NEW</span>(add, 8)
addFive(10)   <span class="Comment"># prints 15</span>
addEight(10)  <span class="Comment"># prints 18</span>
</pre>
</p>

<p>Once a callback is created, it can be passed around as if it is reference to
the inner method.  That the callback stores the extra argument is transparent,
it has the type of the inner method.  The argumens stored inside the callback
only become visible when the callback is invoked.
</p>

<p>Continuing the example above:
<pre class='vimCodeElement'>
<span class="Type">proc</span>&lt;<span class="Type">int</span>&gt; p = addFive
p(20)  <span class="Comment"># prints 25</span>
</pre>
</p>

<p>Note that the extra arguments of the outer method always come after the
arguments of the innter method.  There is no way to change that.
</p>

<p>A method reference for a method with USE arguments is very similar to a
callback but the way it is created is different.  See
<a href="#Method%32Declaration_Closures%32and%32USE%32arguments">Closures</a>.
</p>


<hr>
<a name="Template%32types"></a><h2>Template types</h2>

<p>Classes, interfaces and methods can be defined with template types.  The type
is declared by adding the actual types in angle brackets:
<pre class='vimCodeElement'>
<span class="Type">list</span>&lt;<span class="Type">string</span>&gt;          <span class="Comment"># list with string items</span>
<span class="Type">dict</span>&lt;<span class="Type">int</span>, <span class="Type">bool</span>&gt;       <span class="Comment"># dict with int key and bool items</span>
MyContainer&lt;Address&gt;  <span class="Comment"># MyContainer class with Address objects</span>
I.Iterable&lt;<span class="Type">int</span>&gt;       <span class="Comment"># I.Iterable interface for iterating over ints</span>
</pre>
</p>


<hr>
<a name="Runtime%32type%32checking"></a><h2>Runtime type checking</h2>

<p>For most code types should be specified at compile time and will be checked at
compile time.  This catches mistakes as early as possible.  E.g., if you
declare a <b>string</b> variable and pass it to a method that requires
an <b>int</b> the compiler will tell you this is wrong.
<pre class='vimCodeElement'>
  <span class="Type">string</span> word = <span class="Constant">&quot;hello&quot;</span>
  increment(word)         <span class="Comment"># Compile time error: int required.</span>
</pre>
</p>

<a name="Runtime%32type%32checking_dyn"></a><div><h3>dyn</h3></div>

<p>For more flexibility, at the cost of performance and causing mistakes to be
discovered only when the program is being executed, the <b>dyn</b> type can be used.
A variable of this type can contain any kind of value or reference.  Assignment
to a <b>dyn</b> variable never fails.  However, using the variable where a specific
type is expected will invoke a runtime type check.  For this purpose
the <b>dyn</b> type stores information about the actual type.
</p>

<p>The <b>dyn</b> type is most useful in containers.  This example stores key-value
pairs where the value can be any type:
<pre class='vimCodeElement'>
<span class="Type">dict</span>&lt;<span class="Type">string</span>, <span class="Type">dyn</span>&gt; keyValue = <span class="PreProc">NEW</span>()
parseFile(<span class="Constant">&quot;keyvalue.txt&quot;</span>, keyValue)
<span class="Statement">FOR</span> key <span class="Statement">IN</span> keyValue.keys()
  <span class="Type">dyn</span> value = keyValue[key]
  <span class="Statement">SWITCH</span> value.Type()
    <span class="Statement">CASE</span> <span class="PreProc">T</span>.<span class="Type">int</span>;     <span class="PreProc">IO</span>.print(key .. <span class="Constant">&quot; is number &quot;</span> .. value)
    <span class="Statement">CASE</span> <span class="PreProc">T</span>.<span class="Type">string</span>;  <span class="PreProc">IO</span>.print(key .. <span class="Constant">&quot; is string '&quot;</span> .. value .. <span class="Constant">&quot;'&quot;</span>)
    <span class="Statement">DEFAULT</span>;        <span class="PreProc">IO</span>.print(key .. <span class="Constant">&quot; is not a number or string&quot;</span>)
  <span class="Statement">}</span>
<span class="Statement">}</span>
</pre>
</p>

<p>Methods for the <b>dyn</b> type are documented in
the <a href="https://zimbu.googlecode.com/hg/docs/DYN.dyn.html">dyn class</a>.
</p>

<hr>
<a name="Identity"></a><h2>Identity</h2>

<p>Value typed variables have no identity, only a value.  You can not tell one
FALSE from another.
</p>

<p>Reference typed variables can have exactly the same value and still reference
to another instance.  Therefore we have different operators to compare the
value and the identity:
</p>

<pre class='vimCodeElement'>
<span class="Type">string</span> a = <span class="Constant">&quot;one1&quot;</span>
<span class="Type">string</span> b = <span class="Constant">&quot;one&quot;</span> .. 1
<span class="PreProc">IO</span>.print(a == b)    <span class="Comment"># TRUE</span>
<span class="PreProc">IO</span>.print(a <span class="Statement">IS</span> b)    <span class="Comment"># FALSE</span>
</pre>

<p>Note: String constants are de-duplicated.  Also when the compiler can perform
concatenation at compile time:
<pre class='vimCodeElement'>
<span class="Type">string</span> a = <span class="Constant">&quot;one&quot;</span>
<span class="Type">string</span> b = <span class="Constant">&quot;o&quot;</span> .. <span class="Constant">&quot;ne&quot;</span>
<span class="PreProc">IO</span>.print(a == b)   <span class="Comment"># TRUE</span>
<span class="PreProc">IO</span>.print(a <span class="Statement">IS</span> b)   <span class="Comment"># TRUE !</span>
</pre>
</p>


<hr>
<a name="Builtin%32Types"></a><h2>Builtin Types</h2>

<p>All builtin type names start with a lower case letter.
The types defined in Zimbu code must start with an upper case letter.
That way new types can be added later without breaking an existing program.
</p>

<p>When used in an expression the standard types need to be preceded with "T.":
<pre class='vimCodeElement'>
<span class="Type">thread</span> t = <span class="PreProc">T</span>.<span class="Type">thread</span>.<span class="PreProc">NEW</span>()
</pre>
It's rarely needed though, in the example you would normally leave out
"T.thread." and NEW() would work with the inferred type.
</p>

<a name="Builtin%32Types_Value%32types"></a><div><h3>Value types</h3></div>

<table cellpadding=0 cellspacing=0 border=0>
<tr class="firstrow" valign="top"><td class="firstcol">type name</td><td class="col"> contains </td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/BOOL.bool.html">bool</a>
   </td><td class="col">TRUE or FALSE</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/STATUS.status.html">status</a>
   </td><td class="col">FAIL or OK</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/INT.int.html">int</a>
   </td><td class="col">64 bit signed number</td></tr>
<tr valign="top"><td class="firstcol">int8      </td><td class="col">8 bit signed number</td></tr>
<tr valign="top"><td class="firstcol">int16     </td><td class="col">16 bit signed number</td></tr>
<tr valign="top"><td class="firstcol">int32     </td><td class="col">32 bit signed number</td></tr>
<tr valign="top"><td class="firstcol">int64     </td><td class="col">64 bit signed number, identical to int</td></tr>
<tr valign="top"><td class="firstcol">nat       </td><td class="col">64 bit unsigned number</td></tr>
<tr valign="top"><td class="firstcol">nat8      </td><td class="col">8 bit unsigned number</td></tr>
<tr valign="top"><td class="firstcol">nat16     </td><td class="col">16 bit unsigned number</td></tr>
<tr valign="top"><td class="firstcol">nat32     </td><td class="col">32 bit unsigned number</td></tr>
<tr valign="top"><td class="firstcol">nat64     </td><td class="col">64 bit unsigned number, identical to nat</td></tr>
<tr valign="top"><td class="firstcol">float     </td><td class="col">64 bit floating point number</td></tr>
<tr valign="top"><td class="firstcol">float32   </td><td class="col">32 bit floating point number</td></tr>
<tr valign="top"><td class="firstcol">float64   </td><td class="col">64 bit floating point number, identical to float</td></tr>
<tr valign="top"><td class="firstcol">float80   </td><td class="col">80 bit floating point number</td></tr>
<tr valign="top"><td class="firstcol">float128  </td><td class="col">128 bit floating point number</td></tr>
<tr valign="top"><td class="firstcol">fixed1    </td><td class="col">64 bit signed number with one decimal: 1.1</td></tr>
<tr valign="top"><td class="firstcol">fixed2    </td><td class="col">64 bit signed number with two decimals: 1.12</td></tr>
<tr valign="top"><td class="firstcol">...       </td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol">fixed15   </td><td class="col">64 bit signed number with 15 decimals: 1.123456789012345</td></tr>
</td></tr></table>

<p>See <a href="#Default%32Values">Default Values</a> for what value a variable has when not
explicitly initialzed.
</p>

<p>status is similar to bool, but with clearer meaning for success/failure. It is
often used as return value for methods.
</p>

<p>NOTE: fixed types have not been implemented yet
</p>

<p>fixed1, fixed2, ... fixed15 are used for computations where the number of
digits behind the point needs to be fixed.  fixed2 is specially useful for
money, fixed3 for meters, etc.
</p>


<a name="Builtin%32Types_String%32types"></a><div><h3>String types</h3></div>

<p>Use the link under the type name to go to the type documentation.
</p>

<table cellpadding=0 cellspacing=0 border=0>
<tr class="firstrow" valign="top"><td class="firstcol">type name</td><td class="col"> functionality </td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/STRING.string.html">string</a>
   </td><td class="col">a sequence of utf-8 encoded Unicode characters, immutable</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/BYTESTRING.byteString.html">byteString</a>
   </td><td class="col">a sequence of 8-bit bytes, immutable</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/VARSTRING.varString.html">varString</a>
   </td><td class="col">a sequence of utf-8 encoded Unicode characters, mutable</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/VARBYTES.varByteString.html">varBytesString</a>
   </td><td class="col">a sequence of 8-bit bytes, mutable</td></tr>
</td></tr></table>

<p>All string types can contain a NUL character.  The length is remembered,
getting the length of a very long string is not slow, like it is with NUL
terminated strings.
</p>

<p>String and byteString use the same storage format and can be typecast to each
other without conversion.  Same for varString and varByteString.
</p>

<p>Varstring and varByteString are mutable.  They are implemented in a way that does
not require reallocating memory and copying text for every mutation.
</p>

<p>When using a varString where a string is expected, the varString is
automatically converted using the ToString() method.  And the other way around, using the toVarstring() method.
</p>

<p>When using a varByteString where a byteString is expected, the varByteString is automatically
converted using the toBytes() method.  And the other way around, using the
toVarbytes() method.
</p>

<p>These conversions also work for NIL, so that this works:
<pre class='vimCodeElement'>
<span class="Type">varString</span> vs    <span class="Comment"># NIL by default</span>
<span class="Type">string</span> s = vs   <span class="Comment"># no problem.</span>
</pre>
Most other operations on string types fail when the value is NIL.
</p>


<a name="Builtin%32Types_Container%32types"></a><div><h3>Container types</h3></div>

<p>Use the link under the type name to go to the type documentation.
</p>

<table cellpadding=0 cellspacing=0 border=0>
<tr class="firstrow" valign="top"><td class="firstcol">type name </td><td class="col"> functionality </td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/ARRAY.array.html">array</a>
  </td><td class="col">multi-dimentional vector of known size</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/LIST.list.html">list</a> 
  </td><td class="col">one-dimensional, can insert</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/SORTEDLIST.SortedList.html">sortedList</a>
  </td><td class="col">one-dimensional, can insert, ordered</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/DICT.dict.html">dict</a>
  </td><td class="col">lookup by key, no duplicate keys</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/MULTIDICT.MultiDict.html">multiDict</a>
  </td><td class="col">lookup by key, duplicate keys allowed</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/SET.Set.html">set</a>
  </td><td class="col">lookup by key, no duplicate keys</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/MULTISET.MultiSet.html">multiSet</a>
  </td><td class="col">lookup by key, duplicate keys allowed</td></tr>
</td></tr></table>

<p>All containers contain items of the same type.
However, the type can be <b>dyn</b>, in which case the container can hold items
of any type.
</p>

<a name="Builtin%32Types_Tuple%32type"></a><div><h3>Tuple type</h3></div>

<table cellpadding=0 cellspacing=0 border=0>
<tr class="firstrow" valign="top"><td class="firstcol">type name</td><td class="col"> functionality </td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/TUPLE.tuple.html">tuple</a>
  </td><td class="col">structure with one or more items of a specified type</td></tr>
</td></tr></table>

<p>A tuple requires the type of every item it contains to be specified.  It is
convenient for when a function returns more than one thing:
<pre class='vimCodeElement'>
<span class="Comment"># Read a line. Returns a tuple with:</span>
<span class="Comment"># </span><span class="Ignore">|</span><span class="Constant">status</span><span class="Ignore">|</span><span class="Comment"> OK or FAIL</span>
<span class="Comment"># </span><span class="Ignore">|</span><span class="Constant">string</span><span class="Ignore">|</span><span class="Comment"> the text when </span><span class="Ignore">|</span><span class="Constant">status</span><span class="Ignore">|</span><span class="Comment"> is OK, an error message when </span><span class="Ignore">|</span><span class="Constant">status</span><span class="Ignore">|</span><span class="Comment"> is FAIL</span>
<span class="Statement">FUNC</span> readLine() <span class="Type">tuple</span>&lt;<span class="Type">status</span>, <span class="Type">string</span>&gt;
</pre>
</p>

<p>The items in a tuple can be accessed with an index, starting at zero, like with
a list.  With square brackets on the left side of an assignment all items can
be obtained at once:
<pre class='vimCodeElement'>
<span class="Type">tuple</span>&lt;<span class="Type">int</span>, <span class="Type">string</span>&gt; tup = <span class="PreProc">NEW</span>()   <span class="Comment"># sets all values to their default</span>
tup = [5, <span class="Constant">&quot;foo&quot;</span>]                 <span class="Comment"># Create tuple and initialize from a list.</span>
tup[0] = 7
tup[1] = <span class="Constant">&quot;bar&quot;</span>
<span class="Type">int</span> i = tup[0]                   <span class="Comment"># get 7</span>
<span class="Type">string</span> s = tup[1]                <span class="Comment"># get &quot;bar&quot;</span>
[i, s] = tup                     <span class="Comment"># unpack the tuple, get 7 and &quot;bar&quot; at once</span>
</pre>
</p>

<p>To make clear what each item in the tuple is for names can be added.  The items
can then be accessed by that name, like a class member:
<pre class='vimCodeElement'>
<span class="Type">tuple</span>&lt;<span class="Type">int</span> x, <span class="Type">int</span> y, <span class="Type">string</span> title&gt; tup = <span class="PreProc">NEW</span>(5, 10, <span class="Constant">&quot;hello&quot;</span>)
<span class="Type">int</span> xval = tup.x           <span class="Comment"># same as int xval = tup[0]</span>
<span class="Type">string</span> title = tup.title   <span class="Comment"># same as string title = tup[2]</span>
t.y = 3                    <span class="Comment"># same as t[1] = 3</span>
t.title = <span class="Constant">&quot;there&quot;</span>          <span class="Comment"># same as t[2] = &quot;there&quot;</span>
</pre>
</p>

<p>It is not possible to add a method to a tuple.
If you need that use a CLASS instead.
</p>

<a name="Builtin%32Types_Thread%32related%32types"></a><div><h3>Thread related types</h3></div>

<p>Use the link under the type name to go to the type documentation.
</p>

<table cellpadding=0 cellspacing=0 border=0>
<tr class="firstrow" valign="top"><td class="firstcol">type name</td><td class="col"> functionality </td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/PIPE.Pipe.html">pipe</a>
  </td><td class="col">synchronized stream</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/THREAD.Thread.html">thread</a>
  </td><td class="col">unit of execution</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/THREAD.EvalThread.html">evalThread</a>
  </td><td class="col">unit of execution to evaluate an expression</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/THREAD.Lock.html">lock</a>
  </td><td class="col">object used to get exclusive access</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/THREAD.Cond.html">cond</a>
  </td><td class="col">condition to wait on</td></tr>
</td></tr></table>

<a name="Builtin%32Types_Other%32types"></a><div><h3>Other types</h3></div>


<p>The standard libraries define many useful types, but they do not have a short
type name, e.g.
</p>

<table cellpadding=0 cellspacing=0 border=0>
<tr class="firstrow" valign="top"><td class="firstcol">type name</td><td class="col"> functionality </td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/IO.File.html">IO.File</a>
  </td><td class="col">opened file</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/IO.Stat.html">IO.Stat</a>
  </td><td class="col">information about a file</td></tr>
<tr valign="top"><td class="firstcol"><a href="https://zimbu.googlecode.com/hg/docs/Z.Pos.html">Z.Pos</a>
  </td><td class="col">position in a file</td></tr>
</td></tr></table>

<p>Use the link under the type name to go to the type documentation.
</p>


<hr>
<a name="ALIAS%32and%32TYPE"></a><h2>ALIAS and TYPE</h2>

<p>Some type declarations can become long and using a short name instead makes
code easier to read.  Zimbu offers two ways for this: ALIAS and TYPE.  ALIAS is
nothing else than a different name for the same type.  The name still stands
for the same type and can be used instead of that type.  TYPE defines a new
type and restricts how that type can be used.
</p>

<a name="ALIAS%32and%32TYPE_Simplified%32Syntax"></a><div><h3>Simplified Syntax</h3></div>

<pre>
TYPE type name
ALIAS type name
</pre>
<table cellpadding=0 cellspacing=0 border=0>
<tr valign="top"><td class="firstcol">type          </td><td class="col"></td><td class="col">The type name, such as "int", "string" or "MyClass".</td></tr>
<tr valign="top"><td class="firstcol">name          </td><td class="col"></td><td class="col">The declared name, e.g., "BirdName" or "Length".</td></tr>
</td></tr></table>

<a name="ALIAS%32and%32TYPE_ALIAS"></a><div><h3>ALIAS</h3></div>

<p>ALIAS is used to give a short name to a type, method or variable. Example:
</p>

<pre class='vimCodeElement'>
  <span class="Statement">ALIAS</span> Token.Type TType
</pre>

<p>Here the name TType stands for Token.Type.
</p>

<p>This can also be used to define a name in a module or class as if it
is part of that module or class, while it is actually defined elsewhere.
For example, the ZWT library defines items that are actually defined in another file.
</p>

<pre class='vimCodeElement'>
<span class="Statement">IMPORT</span> <span class="Constant">&quot;zwt/PanelModule.zu&quot;</span>
...
<span class="Statement">MODULE</span> <span class="PreProc">ZWT</span>
...
    <span class="Statement">ALIAS</span> PanelModule.Panel    <span class="PreProc">@public</span> Panel
<span class="Statement">}</span>
</pre>

<p>Now the Panel class defined in PanelModule can be used as ZWT.Panel.
</p>

<a name="ALIAS%32and%32TYPE_TYPE"></a><div><h3>TYPE</h3></div>

<p>TYPE is used to define a new type from another type. There are two reasons to
do this:
</p>
<ol>
<li>Improve type checking. The compiler will give an error when passing a wrong
   type.  This avoids mistakes.
</li>
<li>Define a short name for a complex type. This makes the code easier to read
   and the type can be changed without having to change all the code that
   uses it.
</li>
</ol>

<p>Example for the first reason:
<pre class='vimCodeElement'>
  <span class="Statement">TYPE</span> <span class="Type">int</span> WeightPerMeter
  <span class="Statement">TYPE</span> <span class="Type">int</span> Length
  <span class="Statement">TYPE</span> <span class="Type">int</span> Weight
  WeightPerMeter w = 8
  Length         l = 100
  Weight         t = w * l
  w = l  <span class="Comment"># Error!</span>
</pre>
</p>

<p>Here WeightPerMeter, Length and WeightPerMeter are all integers, but they are a
different type.  When assigning l (which is Length) to w (which is
WeightPerMeter) the compiler will generate an error.
</p>

<p>When operating on a typedef'ed type it loses its special meaning and the type
it stands for is used instead.  Therefore the result of multiplying w and l can
be assigned to t, even though its type is different.
</p>

<p>Also, the typedef'ed type can be assigned to and from the type it stands for.
This is more apparent when using container types:
</p>

<pre class='vimCodeElement'>
  <span class="Statement">TYPE</span> <span class="Type">dict</span>&lt;<span class="Type">string</span>, <span class="Type">int</span>&gt; KeyValue
  <span class="Statement">TYPE</span> <span class="Type">dict</span>&lt;<span class="Type">string</span>, <span class="Type">int</span>&gt; NameNumber
  KeyValue   kv = <span class="PreProc">NEW</span>()
  NameNumber nn = <span class="PreProc">NEW</span>()
  <span class="Type">dict</span>&lt;<span class="Type">string</span>, <span class="Type">int</span>&gt; xx = kv
  nn = [<span class="Constant">&quot;hello&quot;</span>: 5]
  kv = nn  <span class="Comment"># Error!</span>
</pre>



<hr>
<a name="Statements"></a><h1>Statements</h1>

<hr>
<a name="Block%32Statements"></a><h2>Block Statements</h2>

<p>In a block it is possible to declare a class, method, enum, etc.  These items
will then only be visible inside the block.  Just like other items declared in
the block.
</p>

<p>A nested block can be used to restrict the visibility of declared items.
</p>

<p>The NOP statement does nothing.
</p>

<a name="Block%32Statements_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
block-item     -&gt;  ( file-item
                   | assignment
                   | method-call
                   | conditional
                   | switch
                   | try
                   | while
                   | do-until
                   | for-in
                   | break
                   | continue
                   | nop
                   | block
                   ) ;
nop          -&gt;  "NOP"  line-sep  ;
block        -&gt;  "{"  line-sep
                    block-item+
                 block-end  ;
</pre>

<hr>
<a name="Assignment"></a><h2>Assignment</h2>

<a name="Assignment_Simple%32Assignment"></a><div><h3>Simple Assignment</h3></div>

<p>A simple assignment has the form:
<pre class='vimCodeElement'>
variable = expression
</pre>
</p>

<p>The type of the expression must match the type of the variable, or it must be
possible to convert the value without loss of information.  E.g. you can assign
a byte to an int variable, but not the other way around.  The same applies to
the other kinds of assignment below.
</p>

<p>When the expression is a constant or a computation using only constants, and
the value does not fit in the variable the compiler produces an error.
</p>

<a name="Assignment_Multiple%32Assignment"></a><div><h3>Multiple Assignment</h3></div>

<p>It is possible to assign multiple values at the same time:
<pre class='vimCodeElement'>
var1, var2 = multiFunc()
var3, var4 = someTuple
</pre>
Here multiFunc() returns two values and someTuple results in a tuple type with
two values.
</p>

<p>It is also possible to swap two variables, rotate three or do related
assignments at the same time:
<pre class='vimCodeElement'>
x, y = y, x
a, b, c = b, c, a
r, g, b = red, green, blue
</pre>
There is no limit on the number of variables, but it quickly becomes unreadable
with more than three.  Only use this when it makes sense, otherwise split into
multiple assignments.
</p>

<a name="Assignment_Multiple%32Assignment%32with%32declaration"></a><div><h3>Multiple Assignment with declaration</h3></div>

<p>It is possible to do multiple assignments and declare some variables at the
same time:
<pre class='vimCodeElement'>
<span class="Type">string</span> var1, <span class="Type">status</span> var2 = getStringWithStatus()
var3, <span class="Type">list</span>&lt;<span class="Type">int</span>&gt; var4 = getCountAndList()
</pre>
</p>

<p>Note that there cannot be a line break between the type and the variable name,
because the compiler would see this as a declaration and an assignment:
<pre class='vimCodeElement'>
<span class="Type">string</span> var1, <span class="Type">status</span>
var2 = someFunction()
</pre>
</p>

<p>This declares a variable named status as a string and assigns the result of
someFunction() to var2.
</p>

<a name="Assignment_Operator%32Assignment"></a><div><h3>Operator Assignment</h3></div>

<pre class='vimCodeElement'>
lhs += expr     <span class="Comment"># add expr to lhs (numbers only)</span>
lhs -= expr     <span class="Comment"># subtract expr from lhs (numbers only)</span>
lhs *= expr     <span class="Comment"># multiple lhs by expr (numbers only)</span>
lhs /= expr     <span class="Comment"># divide lhs by expr (numbers only)</span>
lhs ..= expr    <span class="Comment"># concatenate expr to lhs (strings only)</span>
</pre>
<p>This works like "lhs = lhs OP expr", except that "lhs" is only evaluated once.  This matters when evaluating "lhs" has side effects.
</p>

<a name="Assignment_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
assignment   -&gt;  comp-name  sep  "="  sep  expr  line-sep ;
TODO: more types
</pre>

<hr>
<a name="Method%32call"></a><h2>Method call</h2>

<p>TODO
</p>

<p>NEW() can be used as an expression when the type can be inferred from the
context.  This is usually the case when assigned to a variable:
<pre class='vimCodeElement'>
<span class="Type">list</span>&lt;<span class="Type">string</span>&gt; names = <span class="PreProc">NEW</span>()    <span class="Comment"># empty list of strings</span>
<span class="Type">array</span>&lt;<span class="Type">int</span>&gt; numbers = <span class="PreProc">NEW</span>(8)   <span class="Comment"># one-dimensional array containing 8 ints</span>
</pre>
</p>

<p>Otherwise the class must be specified:
<pre class='vimCodeElement'>
<span class="Type">VAR</span> names = NameList.<span class="PreProc">NEW</span>()
</pre>
</p>

<a name="Method%32call_Passing%32arguments%32by%32name"></a><div><h3>Passing arguments by name</h3></div>

<p>Normally arguments are passed by position, their sequence at the call and the
method being called is the same.  When passing arguments by name, the order can
differ.  When an argument is passed by name, all following argument must be
passed by name.
</p>

<p>The following example outputs "There are 3 red desks" and "There are 2 green
chairs".
<pre class='vimCodeElement'>
  <span class="Statement">PROC</span> show(<span class="Type">string</span> color, <span class="Type">string</span> what, <span class="Type">int</span> amount)
    <span class="PreProc">IO</span>.print(<span class="Constant">&quot;There are \(</span>amount<span class="Constant">) \(</span>color<span class="Constant">) \(</span>what<span class="Constant">)&quot;</span>)
  <span class="Statement">}</span>
  show(<span class="Constant">&quot;red&quot;</span>, <span class="Constant">&quot;desks&quot;</span>, 3)
  show(amount = 2, what = <span class="Constant">&quot;chairs&quot;</span>, color = <span class="Constant">&quot;green&quot;</span>)
</pre>
</p>

<p>This has advantages and disadvantages.  The main advantage is that you can see
at the caller side what the argument means.  When there are several booleans
and you pass TRUE or FALSE, it is easy to get confused about what each value is
used for.
</p>

<p>The main disadvantage is that you can't change the name used in the method
without also changing it for all callers.  This can be a problem when adding a
new argument which makes the meaning of an existing argument unclear.  Or when
the name turns out to be a bad choice.
</p>


<a name="Method%32call_Selecting%32the%32method%32to%32be%32called"></a><div><h3>Selecting the method to be called</h3></div>

<p>Since there can be multiple methods with the same name there are rules about
which one to call, depending on the arguments used.
</p>

<p>The return type, and whether the method is a PROC or a FUNC, does not matter
for selecting the method.
</p>

<p>Generally, the method with the lowest argument conversion cost is selected.  If
there is more than one method with the lowest cost, this results in a compile
time error, since the compiler does not know which one to use.  For computing
the conversion cost add up the conversion cost for each argument, as explained
in the following section.
</p>

<p>When the argument name is used in the call ("name = expression") the name
itself is used, not the type of the expression.  All arguments passed by name
must exist.
</p>

<p>Optional arguments, the ones specified with a default value and the varargs
argument, are not used to select the method.
</p>


<a name="Method%32call_Automatic%32argument%32conversion"></a><div><h3>Automatic argument conversion</h3></div>

<p>When a method is called with an argument that is of different type than the
type specified for the function, the compiler will attempt an automatic
conversion.
</p>

<p>When the method arg is a typedef and the used argument is not a typedef, the
method arg is considered to be what the typedef is defined to be.  For example,
if the argument is a typedef Length, which is an int, conversion cost for using
an int is zero.  If the used argument is a typedef Width, which is also an int,
no conversion is possible.
</p>

<p>When two ways of conversion are possible the one with the lower cost is used.
</p>

<p>Cost 0: When no conversion is to be done. This includes:
</p>
<ul>
<li>The types are equal.
</li>
<li>The method arg type is a class and the used argument is an object of that class. 
</li>
<li>The method arg type is a bits and the used argument is an int or nat.
</li>
<li>The method arg type is a FUNC type or FUNC reference type and the used
   argument is a FUNC type or FUNC reference type
</li>
<li>The method arg type is a PROC type or PROC reference type and the used
   argument is a PROC type or PROC reference type
</li>
<li>The used argument is a callback and the method arg type matches first
   argument in the callback.
</li>
<li>The method arg type is a typedef and the used argument is the same typedef.
</li>
<li>The method arg type is a reference type and the used argument is NIL.
</li>
<li>The used argument type is unknown
</li>
<li>a negative number constant to int
</li>
<li>a positive number constant to nat
</li>
<li>a floating point constant to float
</li>
</ul>

<p>Cost 1: When the method arg type is of the same type as the used argument but
bigger.  This includes:
</p>
<ul>
<li>byte to nat16, nat32 or nat
</li>
<li>int8 to int16, int32 or int
</li>
<li>nat16 to nat32 or nat
</li>
<li>int16 to int32 or int
</li>
<li>nat32 to nat
</li>
<li>int32 to int
</li>
<li>float32 to float, float80 or float128
</li>
<li>float to float80 or float128
</li>
<li>float80 to float128
</li>
<li>a positive number constant to nat8, nat16, nat32
</li>
<li>a negative number constant to int8, int16, int32
</li>
<li>a floating point constant to float32, float80 or float128
</li>
</ul>

<p>Cost 2: When the method arg type is very similar and no information will be lost.
</p>
<ul>
<li>byte to int16, int32 or int
</li>
<li>nat16 to int32 or int
</li>
<li>nat32 to int
</li>
<li>a positive number constant to int8, int16, int32, float, float32, float80 or
   float128
</li>
<li>a negative number constant to float, float32, float80 or float128
</li>
</ul>

<p>Cost 100: When the conversion is cheap
</p>
<ul>
<li>The method arg type is dyn.
</li>
<li>The method arg type is a class, object or interface and the used argument is
   a matching class, an object of a matching class or matching interface.
   Matching means that it is the same class or a subclass of that class.
</li>
</ul>

<p>Cost 10000: When the conversion takes some effort
</p>
<ul>
<li>The method arg type is string and the used argument is int, bool, status or
   varString.
</li>
<li>The method arg type is varString and the used argument is int, bool, status
   or string.
</li>
<li>The method arg type is varbyteString and the used argument is byteString.
</li>
<li>The method arg type is byteString and the used argument is varByteString.
</li>
</ul>

<p>Some resulting choices:
</p>
<ul>
<li>If the used argument is a positive number constant, a method with nat
   argument is preferred over a method with an int argument.
</li>
<li>A method with argument is dyn is preferred over a method with argument
   string when called with int, bool, status, etc., because conversion to
   string is more expensive than conversion to dyn.
</li>
</ul>


<a name="Method%32call_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
method-call  -&gt;  comp-name  skip  "("  arguments?  ")"  line-sep ;
</pre>


<hr>
<a name="RETURN"></a><h2>RETURN</h2>

<p>The RETURN statement causes the flow of execution to return to the caller.
When inside a TRY statement any FINALLY block will be executed before
returning.  When DEFER statements were executed, their function calls will be
executed, in reverse order.
</p>

<p>A PROC can have a RETURN statement without any arguments.
</p>

<p>A FUNC must end in a RETURN statement and the argument or arguments must match
the return type or return types of the function.  When there is more than one
return type they are separated with commas, like the arguments to a function.
</p>

<p>No statements may directly follow RETURN.  They would never be executed.
</p>


<a name="RETURN_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
return       -&gt;  "RETURN"  ( sep  expr )?  ( "," sep expr)*  line-sep  ;
</pre>


<hr>
<a name="EXIT"></a><h2>EXIT</h2>

<p>The EXIT statement causes the program to end.  However, a TRY statement may
catch the E.Exit exception and continue execution.
</p>

<p>The EXIT statement has one integer argument, which is used as the exit status for the program.
</p>


<a name="EXIT_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
exit         -&gt;  "EXIT"  sep  expr  line-sep  ;
</pre>


<hr>
<a name="IF"></a><h2>IF</h2>

<a name="IF_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
conditional  -&gt;  "IF"  sep  expr  line-sep
                   block-item+
                 elseif-part*
                 else-part?
                 block-end  ;
elseif-part  -&gt;  "ELSEIF"  sep  expr  line-sep
                   block-item+  ;
else-part    -&gt;  "ELSE"  line-sep
                   block-item+  ;
</pre>


<hr>
<a name="IFNIL"></a><h2>IFNIL</h2>

<p>IFNIL is just like IF, except that it does not take an expression.  Its
condition is TRUE when THIS (the object the method is invoked on) is NIL.
</p>

<pre class='vimCodeElement'>
  <span class="Statement">FUNC</span> $values() <span class="Type">list</span>&lt;<span class="Type">int</span>&gt;
    <span class="Statement">IFNIL</span>
      <span class="Statement">RETURN</span> []
    <span class="Statement">}</span>
    <span class="Statement">RETURN</span> $members.values()
  <span class="Statement">}</span>
  <span class="Statement">FUNC</span> $Size() <span class="Type">int</span>
    <span class="Statement">IFNIL</span>
      <span class="Statement">RETURN</span> 0
    <span class="Statement">}</span>
    ...
  <span class="Statement">}</span>
  <span class="Statement">FUNC</span> $find(<span class="Type">int</span> c) <span class="Type">int</span>
    <span class="Statement">IFNIL</span>
      <span class="Statement">RETURN</span> -1  <span class="Comment"># not found</span>
    <span class="Statement">}</span>
    ...
  <span class="Statement">}</span>
</pre>

<p>IFNIL must be the very first statement in the method.  It can only be used
inside a method of a class.
</p>

<p>Without IFNIL an E.NilAccess exception will be thrown.
</p>

<p>An alternative is to use the ?. operator, it will result in the default return
value.  The advantage of IFNIL is that you can return any value, such as an
emptly list for $values() above, or -1 for $find() above.
</p>

<p>When inheritance is involved a NIL object can be one of several classes.  All
the classes that the object could be an instance of should use IFNIL in the
called method.  Otherwise the program may crash.  If @replace is not used then
it will always work.
</p>


<hr>
<a name="SWITCH"></a><h2>SWITCH</h2>

<p>Multiple CASE statements, without other code in between, cause the following
block to be executed.
</p>

<p>When there is another statement after a CASE statement, execution jumps to the
end of the SWITCH statement.
</p>

<p>A BREAK statement in one of the CASE blocks causes execution to jump to the end of the SWITCH statement.
</p>

<p>There can be only one DEFAULT statement, it must come after all the CASE
statements and if there is a CASE before it there must be code in between.
</p>


<a name="SWITCH_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
switch       -&gt;  "SWITCH"  sep  expr  line-sep
                   switch-item+
                 block-end  ;
switch-item  -&gt;  ( ( "CASE"  sep  expr  line-sep )+ | "DEFAULT"  line-sep )
                    block-item+
                  ;
</pre>


<hr>
<a name="WHILE"></a><h2>WHILE</h2>

<p>A BREAK statement inside the loop causes execution to jump to the end of the
WHILE statement.
</p>

<p>A CONTINUE statement inside the loop causes execution to jump back to the start of the WHILE statement, evaluationg the condition again.
</p>

<a name="WHILE_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
while    -&gt;  "WHILE"  loop-name?  sep  expr  line-sep
                block-item+
              block-end  ;
break    -&gt;  "BREAK"  loop-name?  line-sep  ;
continue -&gt;  "CONTINUE"  loop-name?  line-sep  ;
</pre>


<hr>
<a name="DO%32%45%32UNTIL"></a><h2>DO - UNTIL</h2>

<p>BREAK and CONTINUE work as with WHILE.
</p>

<p>The condition of the UNTIL is evaluated in the context of the loop block.
That allows checking a variable defined in that block.  Example:
</p>

<pre class='vimCodeElement'>
<span class="Statement">DO</span>
  <span class="Type">bool</span> doPass = ++loop &lt; 3
<span class="Statement">UNTIL</span> !doPass
</pre>


<a name="DO%32%45%32UNTIL_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
do-until  -&gt;  "DO"  loop-name?  line-sep
                 block-item+
               "UNTIL"  sep  expr sep-with-eol  ;
</pre>


<hr>
<a name="FOR"></a><h2>FOR</h2>

<p>The FOR loop is used to iterate over anything that can be iterated over.
</p>

<p>A number range:
<pre class='vimCodeElement'>
<span class="Comment"># TO is inclusive</span>
<span class="Statement">FOR</span> i <span class="Statement">IN</span> 1 <span class="Statement">TO</span> 5               <span class="Comment"># i is set to 1, 2, 3, 4 and 5</span>
  <span class="PreProc">IO</span>.write(i)
<span class="Statement">}</span>

<span class="Comment"># UNTIL is exclusive</span>
<span class="Statement">FOR</span> i <span class="Statement">IN</span> 0 <span class="Statement">UNTIL</span> <span class="Type">list</span>.Size()  <span class="Comment"># i is set to 0, 1, .. list.Size() - 1</span>
   <span class="PreProc">IO</span>.write(<span class="Type">list</span>[i])
<span class="Statement">}</span>
</pre>
</p>

<p>A backwards range:
<pre class='vimCodeElement'>
<span class="Statement">FOR</span> i <span class="Statement">IN</span> 5 <span class="Statement">TO</span> 0 <span class="Statement">STEP</span> -1     <span class="Comment"># range is inclusive</span>
   <span class="Comment">#  i = 5, 4, 3, 2, 1, 0</span>
<span class="Statement">}</span>
</pre>
</p>

<p>Characters in a string:
<pre class='vimCodeElement'>
<span class="Statement">FOR</span> c <span class="Statement">IN</span> <span class="Constant">&quot;1234&quot;</span>        <span class="Comment"># c is set to each character in the string</span>
  <span class="PreProc">IO</span>.write(c)
<span class="Statement">}</span>
</pre>
</p>

<p>Values of an enum:
<pre class='vimCodeElement'>
<span class="Statement">ENUM</span> Some
  one
  two
<span class="Statement">}</span>
<span class="Statement">FOR</span> v <span class="Statement">IN</span> Some          <span class="Comment"># v is set to each value in the enum</span>
  <span class="PreProc">IO</span>.write(v.ToString())
<span class="Statement">}</span>
</pre>
</p>

<p>Items in a list (array is the same):
<pre class='vimCodeElement'>
<span class="Statement">FOR</span> item <span class="Statement">IN</span> [1, 2, 3]  <span class="Comment"># item is set to each item in the list</span>
  <span class="PreProc">IO</span>.write(item)
<span class="Statement">}</span>
</pre>
</p>

<p>Items in a list with the index:
<pre class='vimCodeElement'>
<span class="Statement">FOR</span> index, item <span class="Statement">IN</span> [<span class="Constant">&quot;zero&quot;</span>, <span class="Constant">&quot;one&quot;</span>, <span class="Constant">&quot;two&quot;</span>, <span class="Constant">&quot;three&quot;</span>]
  <span class="PreProc">IO</span>.write(index .. <span class="Constant">&quot;: &quot;</span> .. item)
<span class="Statement">}</span>
</pre>
</p>

<p>Items in a dictionary, using only the values
<pre class='vimCodeElement'>
<span class="Statement">FOR</span> item <span class="Statement">IN</span> [1: <span class="Constant">&quot;one&quot;</span>, 2: <span class="Constant">&quot;two&quot;</span>, 3: <span class="Constant">&quot;three&quot;</span>]  <span class="Comment"># item is set to each string</span>
  <span class="PreProc">IO</span>.write(item)
<span class="Statement">}</span>
</pre>
</p>

<p>Items in a dictionary, using the keys and the values
<pre class='vimCodeElement'>
<span class="Statement">FOR</span> key, val <span class="Statement">IN</span> [1: <span class="Constant">&quot;one&quot;</span>, 2: <span class="Constant">&quot;two&quot;</span>, 3: <span class="Constant">&quot;three&quot;</span>]
  <span class="Comment"># key is set to each number, val is set to each string</span>
  <span class="PreProc">IO</span>.write(key .. <span class="Constant">&quot;: &quot;</span> .. item)
<span class="Statement">}</span>
</pre>
</p>

<p>Any class that implements I.Iterable can be iterated over:
<pre class='vimCodeElement'>
<span class="Statement">FOR</span> name <span class="Statement">IN</span> nameList   <span class="Comment"># name is obtained with nameList.Iterator()</span>
  <span class="PreProc">IO</span>.write(name.ToString())
<span class="Statement">}</span>
</pre>
</p>

<p>Any class that implements I.KeyIterable can be iterated over with two loop
variables:
<pre class='vimCodeElement'>
<span class="Statement">FOR</span> key, name <span class="Statement">IN</span> nameList   <span class="Comment"># name is obtained with nameList.KeyIterator()</span>
  <span class="PreProc">IO</span>.write(key .. <span class="Constant">&quot;:&quot;</span> .. name.ToString())
<span class="Statement">}</span>
</pre>
</p>

<p>For the above, if the variable to be iterated over is NIL, this works as if
there are no items.  Thus it does not throw an E.NilAccess exception.
</p>

<p>BREAK and CONTINUE work as with WHILE.
</p>


<a name="FOR_Looping%32over%32more%32than%32one%32iterable"></a><div><h3>Looping over more than one iterable</h3></div>

<p>There can be multiple, comma separated iterable expressions after IN.  There
must be one loop variable for each iterable.  The loop uses one item from
each iterable on each iteration.  The loop ends when one of the iterables runs
out of items.
</p>

<pre class='vimCodeElement'>
  <span class="Type">list</span>&lt;<span class="Type">string</span>&gt; week_en = [<span class="Constant">&quot;Mon&quot;</span>, <span class="Constant">&quot;Tue&quot;</span>, <span class="Constant">&quot;Wed&quot;</span>, <span class="Constant">&quot;Thu&quot;</span>, <span class="Constant">&quot;Fri&quot;</span>]
  <span class="Type">list</span>&lt;<span class="Type">string</span>&gt; week_nl = [<span class="Constant">&quot;ma&quot;</span>, <span class="Constant">&quot;di&quot;</span>, <span class="Constant">&quot;wo&quot;</span>, <span class="Constant">&quot;do&quot;</span>, <span class="Constant">&quot;fr&quot;</span>]
  <span class="Type">list</span>&lt;<span class="Type">string</span>&gt; week_de = [<span class="Constant">&quot;Mo&quot;</span>, <span class="Constant">&quot;Di&quot;</span>, <span class="Constant">&quot;Mi&quot;</span>, <span class="Constant">&quot;Do&quot;</span>, <span class="Constant">&quot;Fr&quot;</span>]
  <span class="Statement">FOR</span> en, nl, de <span class="Statement">IN</span> week_en, week_nl, week_de
    <span class="PreProc">IO</span>.print(<span class="Constant">&quot;English: &quot;</span> .. en .. <span class="Constant">&quot;, Dutch: &quot;</span> .. nl .. <span class="Constant">&quot;, German: &quot;</span> .. de)
  <span class="Statement">}</span>
</pre>

<p>None of the iterable expressions can be a I.KeyIterator.
</p>


<a name="FOR_Loop%32variable"></a><div><h3>Loop variable</h3></div>

<p>The type of the loop variable(s) is inferred from what is being iterated over.
</p>

<p>When using two loop variables and one expression the first variable is the
index or key and the second the value.
</p>

<p>For a class a FOR loop with one variable will use the I.Iterator interface,
with two variables the I.KeyIterator interface.  If an object is given, the
Itorator() and KeyIterator() methods will be used to obtain the iterator.
</p>

<p>The loop variable is available in the scope of the FOR block.  If it needs to
be available elsewhere, explicitly declare a variable and use it with the USE
keyword:
<pre class='vimCodeElement'>
<span class="Type">int</span> idx
<span class="Statement">FOR</span> <span class="Type">USE</span> idx <span class="Statement">IN</span> 0 <span class="Statement">UNTIL</span> <span class="Type">list</span>.Size()
  <span class="Statement">IF</span> <span class="Type">list</span>[idx] == 0
    <span class="Statement">BREAK</span>
  <span class="Statement">}</span>
<span class="Statement">}</span>
<span class="PreProc">IO</span>.print(<span class="Constant">&quot;valid size: &quot;</span> .. idx)
</pre>
</p>

<a name="FOR_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
for-in    -&gt;  "FOR"  loop-name?  sep
                    ( "USE"?  key-var-name )?
                    "USE"?  item-var-name
                    "IN"  expr
                    ( ("TO" | "UNTIL")  expr)?
                    ( "STEP" expr )?
                    line-sep
                 block-item+
               block-end  ;
</pre>


<hr>
<a name="DEFER"></a><h2>DEFER</h2>

<p>A DEFER statement has one argument, which must be a method call.  This call is
postponed until the end of the current method.  The arguments for the method
call are evaluated at the time the DEFER statement is executed.
</p>

<p>DEFER is most useful right after a resource is allocated.  The argument is then
a call to free up the resource.  Example:
<pre class='vimCodeElement'>
<span class="Statement">PROC</span> copy()
  <span class="PreProc">IO</span>.File in = <span class="PreProc">IO</span>.fileReader(<span class="Constant">&quot;source&quot;</span>)
  <span class="Statement">DEFER</span> in.close()
  <span class="PreProc">IO</span>.File out = <span class="PreProc">IO</span>.fileWriter(<span class="Constant">&quot;destination&quot;</span>)
  <span class="Statement">DEFER</span> out.close()
  ... copy from in to out, possibly throws an exception
  <span class="Comment"># out.close() is called here</span>
  <span class="Comment"># in.close() is called here</span>
<span class="Statement">}</span>
</pre>
</p>

<p>The callbacks are invoked in reverse order, the callback from the first DEFER
statement is called first.
</p>

<p>It is possible to use a DEFER statement inside a loop. Keep in mind that the
arguments for the called method are evaluated when the DEFER statement is
executed:
<pre class='vimCodeElement'>
  <span class="Statement">FOR</span> idx <span class="Statement">IN</span> 1 <span class="Statement">TO</span> 3
    <span class="Statement">DEFER</span> <span class="PreProc">IO</span>.print(<span class="Constant">&quot;loop &quot;</span> .. idx)
  <span class="Statement">}</span>
  <span class="Comment"># At the end of the method will print:</span>
  <span class="Comment">#   loop 3</span>
  <span class="Comment">#   loop 2</span>
  <span class="Comment">#   loop 1</span>
</pre>
</p>

<p>If somewhere in the method an exception is thrown, that is not caught by a
TRY/CATCH, the callbacks for the executed DEFER statements are invoked before
the exception is handled.  This also happens for nested methods, going up the
stack until either Main() is handled or a TRY/CATCH handles the exception.
</p>

<p>When the method being called throws an exception, this is reported on stderr
and the processing of callbacks continues.  Note that this means that executing
the deferred methods happens inside a TRY/CATCH, which has some overhead.
</p>

<p>This could also be done with exception handling, but this has more overhead and
gets messy when there are several resources to free.
</p>

<p>Another alternative is to use a Finish() method in a class.  This has the
advantage that it does not require an extra statement.  A disadvantage is that
it won't be called until the garbage is collected.  Unless a not allocated
variable is used.
</p>

<a name="DEFER_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
defer       -&gt;  "DEFER"  sep  expr  line-sep  ;
</pre>


<hr>
<a name="TRY%32%45%32CATCH%32%45%32ELSE%32%45%32FINALLY"></a><h2>TRY - CATCH - ELSE - FINALLY</h2>

<p>TRY can be used to handle an exception.  The TRY block contains statements that might cause an exception to be throw. CATCH blocks are used to deal with them:
</p>

<pre class='vimCodeElement'>
<span class="Type">string</span> s
<span class="Statement">TRY</span>
  <span class="PreProc">IO</span>.File f = openFile(<span class="Constant">&quot;does not exist&quot;</span>)
<span class="Statement">CATCH</span> <span class="PreProc">E</span>.AccessDenied e
  <span class="PreProc">IO</span>.print(<span class="Constant">&quot;Could not open file: &quot;</span> .. e.toString())
<span class="Statement">ELSE</span>
  <span class="Statement">IF</span> f == <span class="Constant">NIL</span>
    <span class="PreProc">IO</span>.print(<span class="Constant">&quot;File does not exist&quot;</span>)
  <span class="Statement">ELSE</span>
    <span class="Statement">TRY</span>
      s = f.read()
    <span class="Statement">FINALLY</span>
      f.close()
    <span class="Statement">}</span>
  <span class="Statement">}</span>
<span class="Statement">}</span>
</pre>

<p>This example uses the openFile() method, which returns NIL when the file does
not exist.  That is the normal way to fail, thus it does not throw an
exception but returns NIL.  Another way to fail is that the file exists, but
cannot be accessed. This throws an E.AccessDenied exception, which is caught by
the CATCH statement.
</p>

<p>The ELSE block is executed when no exception was thrown in the TRY block.
</p>

<p>Note that the variable "f" that was declared n the TRY block is also available
in the ELSE block.  They use the same scope.
</p>

<p>The FINALLY block is always executed.  Also when an exception is thrown in a
CATCH or ELSE block. In that case the exception is thrown again at the end of
the FINALLY block.  However, if an exception is thrown inside the FINALLY
block, this will not happen.
</p>

<p>Also, when BREAK, CONTINUE or RETURN was used, the FINALLY block is executed
and the statement takes affect at the end of it.
</p>

<p>The exceptions throws in the CATCH, ELSE and FINALLY blocks are not caught by
this TRY statement.  Except that this may cause the FINALLY block to be
executed.
</p>

<a name="TRY%32%45%32CATCH%32%45%32ELSE%32%45%32FINALLY_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
try           -&gt;  "TRY"  line-sep
                    block-item+
                  catch-part*
                  else-part?
                  finally-part?
                  block-end  ;
catch-part    -&gt;  "CATCH"  sep  type ( ","  sep  type)* sep  var-name  line-sep
                     block-item+  ;
else-part     -&gt;  "ELSE"  line-sep
                     block-item+  ;
finally-part  -&gt;  "FINALLY"  line-sep
                    block-item+  ;
</pre>


<hr>
<a name="THROW"></a><h2>THROW</h2>

<p>TODO
</p>


<hr>
<a name="Native%32code"></a><h2>Native code</h2>

<a name="Native%32code_Using%32a%32C%32type"></a><div><h3>Using a C type</h3></div>

<p>When writing a module that uses a C type, it can be included in a class like
this:
</p>

<pre class='vimCodeElement'>
C(pthread_t)  thread_id
</pre>

<p>The text between C( and ) is used literally in the produced C code.
There cannot be a line break between C( and ).
</p>

<p>This does not automatically define the type, see the next section about
including the C header file.
</p>

<p>NOTE: Variables defined this way will NOT be garbage-collected!  You must take
care of this yourself, possibly using a Finish() method.
</p>


<a name="Native%32code_IMPORT%46CHEADER"></a><div><h3>IMPORT.CHEADER</h3></div>

<p>For C header files you can use IMPORT.CHEADER.
That makes sure the header file is included early and only once.
</p>

<p>The include statement will appear near the start of the generated C
code.  The compiler discards duplicate names.  The meaning of using "" or
&lt;&gt; matters, it is passed on to the C code.
Example:
</p>

<pre class='vimCodeElement'>
<span class="Statement">IMPORT</span>.<span class="PreProc">CHEADER</span> &lt;ncurses.h&gt;
</pre>


<a name="Native%32code_Using%32a%32C%32expression"></a><div><h3>Using a C expression</h3></div>

<p>For small pieces of C code you can use C(code):
<pre class='vimCodeElement'>
  <span class="Type">bool</span> special = (value &amp; C(SPECIAL_MASK)) != 0
</pre>
</p>

<p>There Zimbu compiler does not check the code, if you do something wrong the C
compiler will produce errors or warnings.
</p>


<a name="Native%32code_Native%32code%32block"></a><div><h3>Native code block</h3></div>

<p>Text between "&gt;&gt;&gt;" and "&lt;&lt;&lt;" is copied as-is to the generated C or Javascript
file.
</p>

<pre class='vimCodeElement'>
<span class="Comment">&gt;&gt;&gt;</span> <span class="PreProc">blockgc</span>
   <span class="Type">FILE</span> *fd = fopen(<span class="Constant">&quot;temp&quot;</span>, <span class="Constant">&quot;r&quot;</span>);
<span class="Comment">&lt;&lt;&lt;</span>
</pre>

<p>Both the "&lt;&lt;&lt;" and the "&gt;&gt;&gt;" must appear at the start of the line without any
preceding white space.  They can not appear halfway a statement.
</p>

<pre class='vimCodeElement'>
<span class="Type">string</span> x =
<span class="Comment">&gt;&gt;&gt;</span>
  <span class="Constant">&quot;This does not work!&quot;</span>;
<span class="Comment">&lt;&lt;&lt;</span>
</pre>

<p>Comments are allowed in the same line after "&gt;&gt;&gt;" and "&lt;&lt;&lt;":
</p>

<pre class='vimCodeElement'>
<span class="Comment">&gt;&gt;&gt;</span>  <span class="Comment"> # debug code</span>
   printf(<span class="Constant">&quot;hello</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="Comment">&lt;&lt;&lt;   # end of debug code</span>
</pre>

<p>The "blockgc" argument means the garbage collector (GC) should not run while
inside this block. "blockgc" must be used for a block that contains an unsafe
function.  An unsafe function is any function that is not safe, as indicated by
the POSIX standard.  This includes a function that allocates memory.
</p>

<p>"fopen" is an unsafe function, it allocates memory, and the GC must not be run
while this is happening.  Unfortunately, "fopen" may take a while, and blocks
any pending GC.  This should be avoided.
</p>

<p>After a block marked with "blockgc" the GC will run if it was postponed.
</p>

<p>To test for missing "blockgc" run your code compiled with the --exitclean
argument.
</p>

<p>Inside &gt;&gt;&gt; and &lt;&lt;&lt; references to Zimbu variables and methods can be used.
Examples:
</p>
<pre>
  %var%
  %obj.member%
  %funcName%
</pre>

<p>For functions this results in a callback.  If this is not wanted, the function
name itself is to be obtained, use %[ expr ]% instead:
</p>
<pre>
  %[$funcName]%
</pre>

<p>Zimbu expressions can be used as: %{ expression }%.
Examples:
</p>
<pre>
   %{var + 5}%
   %{ myFunc("foobar") }%
</pre>

<p>Note that mixing C and Zimbu variables can be tricky.  Look at the generated
code to make sure this is what you wanted.
</p>

<p>To specify what items the native code depends on, so that it gets added to the program, the uses() item is put after "&gt;&gt;&gt;":
<pre class='vimCodeElement'>
<span class="Comment">&gt;&gt;&gt;</span> <span class="PreProc">uses(getCstring)</span>
&gt;&gt;&gt; <span class="PreProc">uses(sys_types, socket, hostname, unistd, getCstring)</span>
</pre>
</p>

<p>Items available in uses() and what they make available:
</p>

<table cellpadding=3 cellspacing=0 border=1>
<tr class="firstrow" valign="top"><td class="firstcol">name    </td><td class="col">made available </td><td class="col"> comment</td></tr>
<tr valign="top"><td class="firstcol">ctype_h</td><td class="col">ctype.h include file</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol">dirent</td><td class="col">dirent.h include file</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol">errno</td><td class="col">errno.h include file </td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol">fcntl</td><td class="col">fcntl.h include file</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol">gcRun</td><td class="col">garbage collection</td><td class="col">rarely needed</td></tr>
<tr valign="top"><td class="firstcol">getCstring</td><td class="col">ZgetCstring(s) </td><td class="col">converts a Zimbu string to a C "char *" NUL terminated string</td></tr>
<tr valign="top"><td class="firstcol">hostname</td><td class="col">netdb.h include file </td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol">limits</td><td class="col">limits.h include file</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol">pthread</td><td class="col">pthread.h include file</td><td class="col">also adds pthread library to link with</td></tr>
<tr valign="top"><td class="firstcol">setjmp_h</td><td class="col">setjmp.h include file</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol">socket   </td><td class="col">include files needed for sockets </td><td class="col">also adds socket library to link with</td></tr>
<tr valign="top"><td class="firstcol">string_h</td><td class="col">string.h include file</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol">sys_stat</td><td class="col">sys/stat.h include file</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol">sys_time</td><td class="col">sys/time.h include file</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol">sys_types</td><td class="col">sys/types.h include file</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol">sys_wait</td><td class="col">sys/wait.h include file</td><td class="col">not available on MS-Windows</td></tr>
<tr valign="top"><td class="firstcol">time_h</td><td class="col">time.h include file</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol">unistd</td><td class="col">unistd.h include file</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol">windows_h</td><td class="col">window.h include file</td><td class="col">only available on MS-Windows</td></tr>
</td></tr></table>


<hr>
<a name="Conditional%32Compilation"></a><h2>Conditional Compilation</h2>

<p>The GENERATE_IF statement can be used to produce output only
when a condition is true or false.  All alternative code paths are still
parsed and verified.  This is useful in libraries where different
code must be produced depending on the situation.
</p>

<p>The BUILD_IF statement can be used to build code only when
a condition is true or false.  This allows skipping code which would not
compile, e.g. a missing enum value.  This can be used to build
code with different versions of the compiler, with different features
or for different purposes (testing, profiling).
</p>


<a name="Conditional%32Compilation_GENERATE_IF"></a><div><h3>GENERATE_IF</h3></div>

<p>Example:
<pre class='vimCodeElement'>
<span class="Statement">GENERATE_IF</span> Z.lang == <span class="Constant">&quot;C&quot;</span>
<span class="Comment">&gt;&gt;&gt;</span>
  fputs(<span class="Constant">&quot;this is C code&quot;</span>, <span class="Constant">stdout</span>);
<span class="Comment">&lt;&lt;&lt;</span>
<span class="Statement">GENERATE_ELSEIF</span> Z.lang == <span class="Constant">&quot;JS&quot;</span>
<span class="Comment">&gt;&gt;&gt;</span>
  alert(<span class="Constant">&quot;this is JavaScript&quot;</span>);
<span class="Comment">&lt;&lt;&lt;</span>
<span class="Statement">GENERATE_ELSE</span>
  Z.error(<span class="Constant">&quot;Language &quot;</span> .. Z.lang .. <span class="Constant">&quot; not supported)</span>
<span class="Constant">}</span>
</pre>
</p>

<p>All alternative code paths are still parsed and resolved.  Thus even when
producing C code an error in the JavaScript code will be noticed.
</p>

<p>The structure of the statement is:
<pre class='vimCodeElement'>
<span class="Statement">GENERATE_IF</span> boolean_expr
   statements
<span class="Statement">GENERATE_ELSEIF</span> boolean_expr
   statements
<span class="Statement">GENERATE_ELSE</span>
   statements
<span class="Statement">}</span>
</pre>
</p>

<p>The GENERATE_ELSEIF can appear any number of times.
</p>

<p>The GENERATE_ELSE is optional.
</p>

<p>For "boolean_expr" see the Compile time expression section below.
</p>

<a name="Conditional%32Compilation_BUILD_IF"></a><div><h3>BUILD_IF</h3></div>

<p>NOT IMPLEMENTED YET
</p>

<p>Examples:
<pre class='vimCodeElement'>
<span class="Statement">BUILD_IF</span> Z.has(<span class="Constant">&quot;thread&quot;</span>)  <span class="Comment"># compiler has thread support</span>
   <span class="Comment"># run jobs in parallel</span>
   job1.start()
   job2.start()
   job1.wait()
   job2.wait()
<span class="Statement">BUILD_ELSE</span>
   <span class="Comment"># run jobs sequentially</span>
   job1.run()
   job2.run()
<span class="Statement">}</span>

<span class="Statement">BUILD_IF</span> Color.has(<span class="Constant">&quot;purple&quot;</span>)
   c = Color.purple  <span class="Comment"># purple is available</span>
<span class="Statement">BUILD_ELSE</span>
   c = Color.red     <span class="Comment"># there is no purple, use red</span>
<span class="Statement">}</span>
</pre>
</p>

<p>The alternate code paths are all parsed, to be able to find the
end of the BUILD_IF statements.  Thus the syntax must be
correct, a missing } will be noticed.  But only when the condition
evaluates to true will the code be resolved and produced.  This
allows for using variables that don't exist, enum values that are
not defined, etc.
</p>

<p>The structure of the statement is:
<pre class='vimCodeElement'>
<span class="Statement">BUILD_IF</span> boolean_expr
   statements
<span class="Statement">BUILD_ELSEIF</span> boolean_expr
   statements
<span class="Statement">BUILD_ELSE</span>
   statements
<span class="Statement">}</span>
</pre>
</p>

<p>The BUILD_ELSEIF can appear any number of times.
</p>

<p>The BUILD_ELSE is optional.
</p>

<p>For "boolean_expr" see the next section.
</p>


<a name="Conditional%32Compilation_GENERATE_ERROR"></a><div><h3>GENERATE_ERROR</h3></div>

<p>When compilation is not supported, then GENERATE_ERROR can be used inside a
GENERATE_IF to produce an error at compile time. This avoids that broken code
is produced, causing a cryptic error from the C compiler or an error message at
runtime.
</p>

<p>GENERATE_ERROR takes one argument, which must evaluate to a string at compile
time.
</p>

<pre class='vimCodeElement'>
<span class="Statement">GENERATE_IF</span> Z.lang == <span class="Constant">&quot;C&quot;</span>
<span class="Comment">&gt;&gt;&gt;</span>
  printf(<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, %nr%);
<span class="Comment">&lt;&lt;&lt;</span>
<span class="Statement">GENERATE_ELSE</span>
  <span class="Statement">GENERATE_ERROR</span> <span class="Constant">&quot;Unsupported&quot;</span>
<span class="Statement">}</span>
</pre>


<a name="Conditional%32Compilation_Compile%32time%32expression"></a><div><h3>Compile time expression</h3></div>

<p>The boolean_expr supports these operators:
<pre class='vimCodeElement'>
     ||    <span class="Comment"># OR</span>
     &amp;&amp;    <span class="Comment"># AND</span>
     ==    <span class="Comment"># equal</span>
     !=    <span class="Comment"># not equal</span>
</pre>
</p>

<p>These values are supported:
<pre class='vimCodeElement'>
    <span class="Constant">TRUE</span>
    <span class="Constant">FALSE</span>
    <span class="Constant">&quot;string literal&quot;</span>
    Z.lang           <span class="Comment"># string: &quot;C&quot; when producing C code, or &quot;JS&quot; when producing JavaScript</span>
    Z.have(<span class="Constant">&quot;backtrace&quot;</span>)  <span class="Comment"># boolean, TRUE when stack backtrace is available</span>
</pre>
</p>


<hr>
<a name="Expressions"></a><h1>Expressions</h1>

<p>Expressions are evaluated according to the operator precedence and then from
left to right.
</p>

<hr>
<a name="Operator%32precedence"></a><h2>Operator precedence</h2>

<table cellpadding=3 cellspacing=0 border=1>
<tr valign="top"><td class="firstcol">expr1   </td><td class="col">expr2 ?: expr1       </td><td class="col">if-nil          </td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol"> expr2   </td><td class="col">expr3 ? expr1 : expr1</td><td class="col">ternary operator</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol"> expr3   </td><td class="col">expr4 || expr3       </td><td class="col">boolean or      </td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol"> expr4   </td><td class="col">expr5 &amp;&amp; expr4       </td><td class="col">boolean and     </td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol"> expr5   </td><td class="col">expr6 == expr6<br>
              expr6 != expr6<br>
              expr6 &gt;= expr6<br>
              expr6 &gt; expr6<br>
              expr6 &lt;= expr6<br>
              expr6 &lt; expr6<br>
              expr6 IS expr6<br>
              expr6 ISNOT expr6<br>
              expr6 ISA expr6<br>
              expr6 ISNOTA expr6
                      </td><td class="col">equal<br>
                         not equal<br>
                         greater than or equal<br>
                         greater than<br>
                         smaller than or equal<br>
                         smaller than<br>
                         same object<br>
                         not same object<br>
                         same class<br>
                         not same class </td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol"> expr6   </td><td class="col">expr7 .. expr6</td><td class="col">string concatenation</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol"> expr7   </td><td class="col">expr8 &amp;expr7<br>
              expr8&nbsp;| expr7<br>
              expr8 ^ expr7<br>
                      </td><td class="col">logical and<br>
                         logical or<br>
                         logical xor</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol"> expr8   </td><td class="col">expr9 <&lt; expr9<br>
              expr9 &gt;&gt; expr9
                      </td><td class="col">bitwise left shift<br>
                         bitwise right shift</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol"> expr9   </td><td class="col">expr10 + expr9<br>
              expr10 - expr9
                      </td><td class="col">add<br>
                         subtract</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol"> expr10   </td><td class="col">expr11 * expr11<br>
              expr11 / expr11<br>
              expr11 % expr11
                      </td><td class="col">multiply<br>
                         divide<br>
                         remainder</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol"> expr11  </td><td class="col">++expr12<br>
                 --expr12<br>
                expr12++<br>
                expr12--
                      </td><td class="col">pre-increment<br>
                         pre-decrement<br>
                         post-increment<br>
                         post-decrement</td><td class="col">can be combined</td></tr>
<tr valign="top"><td class="firstcol"> expr12  </td><td class="col">-expr13<br>
              !expr13<br>
              ~expr13<br>
              &expr13
                      </td><td class="col">negate<br>
                         boolean invert<br>
                         bitwise invert<br>
                         reference </td><td class="col">not in front of a number</td></tr>
<tr valign="top"><td class="firstcol"> expr13    </td><td class="col">expr14.name<br>
                expr14?.name<br>
                expr14(expr1 ...)<br>
                expr14.name(expr1 ...)<br>
                expr14?.name(expr1 ...)<br>
                expr14.(expr1 ...)<br>
                expr14[expr1 ...]<br>
                expr14.name[expr1 ...]<br>
                expr14=name<br>
                expr14&lt;expr1 ...&gt;<br>
                expr14.&lt;expr1 ...&gt;
                      </td><td class="col">member<br>
                         not-nil member<br>
                         method call<br>
                         object method call<br>
                         not-nil method call<br>
                         method reference call<br>
                         get item<br>
                         get object item<br>
                         bits item value<br>
                         template<br>
                         typecast</td><td class="col"></td></tr>
<tr valign="top"><td class="firstcol"> expr14    </td><td class="col">( expr1 )<br>
                1234<br>
                -1234<br>
                0x1abc<br>
                0b010110<br>
                'c'<br>
                "string"<br>
                R"string"<br>
                ''"string"''<br>
                name<br>
                $name<br>
                [ expr1, ... ]<br>
                { expr1: expr1, ... }<br>
                NIL<br>
                THIS<br>
                PARENT<br>
                NEW(expr1, ...)<br>
                PROC (args) .. }<br>
                FUNC (args) type .. }<br>
                TRUE<br>
                FALSE<br>
                FAIL<br>
                OK
                      </td><td class="col">grouping<br>
                         number<br>
                         negative number<br>
                         hex number<br>
                         binary number<br>
                         character constant<br>
                         string literal<br>
                         raw string literal<br>
                         multi-line string literal<br>
                         identifier<br>
                         member<br>
                         list initializer<br>
                         dict initializer</td><td class="col"></td></tr>
</td></tr></table>

<p>Note that compared to C the precedence of &, | and ^ is different.  In C their
precedence is lower than for comparative operators, which often leads to
mistakes.
</p>

<p>Note that with "-1234" the minus sign belongs to the number, while otherwise
"-" is a separate operator.  This matters for members:
<pre class='vimCodeElement'>
-1234.toHex()    <span class="Comment"># apply toHex() on -1234</span>
-var.member      <span class="Comment"># apply &quot;-&quot; to &quot;var.member&quot;</span>
-var.<span class="Type">func</span>()      <span class="Comment"># apply func() on &quot;var&quot;, then apply &quot;-&quot;</span>
</pre>
</p>

<hr>
<a name="Operators"></a><h2>Operators</h2>

<a name="Operators_%63%58%32If%45nil"></a><div><h3>?: If-nil</h3></div>

<p>This is a binary operator that evaluates to the left value when it is not zero
or NIL and the right value otherwise.  This is referred to as the
null-coalescing operator or Elvis operator in other languages.
</p>

<p>Example, where a translated message is used if it exists, otherwise the
untranslated message is used:
<pre class='vimCodeElement'>
getValue(translateMessage(msg) ?: msg)
</pre>
</p>

<p>Simplified syntax:
</p>
<pre>
left ?: right
</pre>
<p>When "left" has its default value then the result is "right".
Otherwise the result is "left".
</p>

<p>This is equivalent to:
</p>
<pre>
left != NIL ? left : right
</pre>
<p>Except that "left" is evaluated only once.
</p>


<a name="Operators_%63%32%58%32Ternary%32operator"></a><div><h3>? : Ternary operator</h3></div>

<p>This operator uses a condition and two value expressions:
</p>
<pre>
cond ? left : right
&lt;pre&gt;

When the condition evaluates to TRUE the result is the left expression,
otherwise the right expression.  The expression that is not used is not
evaluated.


### || Boolean OR

Simplified syntax:
&lt;pre&gt;
left || right
</pre>
<p>The result is TRUE when "left" or "right" or both evaluate to TRUE.
The result is FALSE when both "left" and "right" evaluate to FALSE.
</p>

<p>When "left" evaluates to TRUE then "right" is not evaluated.
</p>

<p>The compiler will generate an error when "right" or "true" do not evaluate to a
bool type.
</p>


<a name="Operators_%38%38%32Boolean%32AND"></a><div><h3>&amp;&amp; Boolean AND</h3></div>

<p>TODO
</p>


<a name="Operators_%61%61%44%32%33%61%32equal%32and%32unequal"></a><div><h3>==, != equal and unequal</h3></div>

<p>TODO
</p>

<pre class='vimCodeElement'>
left == right      <span class="Comment"># equal value</span>
left != right      <span class="Comment"># unequal value</span>
</pre>

<p>"left" and "right" must be of the same type, but size does not matter.  Thus
you can compare an int8 with int64.  Also, signedness does not matter, you can
compare a nat with an int.
TODO: what if the nat value doesn't fit in an int?
</p>

<p>Comparing Strings:
</p>
<ul>
<li>When s1 and s2 are both NIL evaluates to TRUE.
</li>
<li>When s1 or s2 is NIL evaluates to FALSE.
</li>
<li>Otherwise evaluates to TRUE when the strings are equal.
</li>
</ul>

<p>It is possible to compare a Bits value with zero.  The result is TRUE if all
fields in the Bits are at their default value.
</p>

<p>When comparing objects the Equal() method is used.  When there is no Equal()
method this is a compilation error.
</p>


<a name="Operators_%62%44%32%62%61%44%32%60%44%32%60%61%32Comperators"></a><div><h3>&gt;, &gt;=, &lt;, &lt;= Comperators</h3></div>

<p>TODO
</p>

<pre class='vimCodeElement'>
left &gt; right     <span class="Comment"># larger than</span>
left &gt;= right    <span class="Comment"># larger or equal</span>
left &lt; right     <span class="Comment"># smaller than</span>
left &lt;= right    <span class="Comment"># smaller or equal</span>
</pre>


<a name="Operators_IS%44%32ISNOT"></a><div><h3>IS, ISNOT</h3></div>

<p>TODO
</p>

<p>Using IS for string values may give unexpected results, because concatenation
of string constants is done at compile time, and equal string values point to
the same string.  Therefore this condition evaluates to TRUE:
<pre class='vimCodeElement'>
<span class="Statement">IF</span> <span class="Constant">&quot;Hello&quot;</span> <span class="Statement">IS</span> <span class="Constant">&quot;Hel&quot;</span> .. <span class="Constant">&quot;lo&quot;</span>
</pre>
</p>


<a name="Operators_ISA%44%32ISNOTA"></a><div><h3>ISA, ISNOTA</h3></div>

<pre class='vimCodeElement'>
<span class="Statement">IF</span> e <span class="Statement">ISA</span> <span class="PreProc">E</span>.NilAccess
<span class="Statement">IF</span> decl <span class="Statement">ISNOTA</span> Declaration
</pre>

<p>Simplified syntax:
</p>
<pre>
left ISA right
left ISNOTA right
</pre>
<p>The "left" expression must evaluate to a value.
The "right" expression must evaluate to a type.
</p>

<p>For ISA, if "left" is not NIL and can be typecast to "right", then
the result is TRUE, otherwise it is FALSE.
</p>

<p>For ISNOTA the result the opposite.  These two expressions are equivalent:
<pre class='vimCodeElement'>
left <span class="Statement">ISNOTA</span> right
!(left <span class="Statement">ISA</span> right)
</pre>
</p>

<p>To test for whether a value is a specific class and not a child of that class, use ".C" for "right" to make a typecast invalid for child classes:
<pre class='vimCodeElement'>
<span class="Type">VAR</span> left = ChildOfFoo.<span class="PreProc">NEW</span>()
left <span class="Statement">ISA</span> Foo    <span class="Comment"># TRUE</span>
left <span class="Statement">ISA</span> Foo.C  <span class="Comment"># FALSE</span>
</pre>
</p>

<p>See <a href="#Operators_%46%60Typecast%62">.&lt;Typecast&gt;</a> for when a typecast is valid.
</p>


<a name="Operators_%46%46%32String%32concatenation"></a><div><h3>.. String concatenation</h3></div>

<p>TODO
</p>

<pre>
left .. right
</pre>

<p>If "left" or "right" is not a string automatic conversion is done for these
types, using their ToString() method:
</p>
<ul>
<li>int, int8, int16, int32
</li>
<li>nat, byte, nat16, nat32
</li>
<li>float, float32
</li>
<li>bool
</li>
<li>status
</li>
<li>varString
</li>
<li>dyn
</li>
</ul>


<a name="Operators_%38%44%32%124%44%32%94%32Logical%32operators"></a><div><h3>&amp;, |, ^ Logical operators</h3></div>

<p>TODO
</p>

<pre class='vimCodeElement'>
left &amp; right       <span class="Comment"># bitwise AND</span>
left | right       <span class="Comment"># bitwise OR</span>
left ^ right       <span class="Comment"># bitwise XOR</span>
</pre>

<p>"left" and "right" must be of a number or bits type.
</p>

<p>When "left" and "right" are of the Bits type the operator is applied to all
fields.
</p>


<a name="Operators_%60%60%44%32%62%62%32bitwise%32shift"></a><div><h3>&lt;&lt;, &gt;&gt; bitwise shift</h3></div>

<p>TODO
</p>


<a name="Operators_%43%44%32%45%32add%32and%32subtract"></a><div><h3>+, - add and subtract</h3></div>

<p>TODO
</p>


<a name="Operators_%42%44%32%47%44%32%37%32multiply%44%32divide%32and%32remainder"></a><div><h3>*, /, % multiply, divide and remainder</h3></div>

<p>TODO
</p>


<a name="Operators_%43%43%44%32%45%45%32Increment%32and%32decrement"></a><div><h3>++, -- Increment and decrement</h3></div>

<p>TODO
</p>


<a name="Operators_Unary%32operators"></a><div><h3>Unary operators</h3></div>

<p>TODO
</p>


<a name="Operators_%46member"></a><div><h3>.member</h3></div>

<p>TODO
</p>


<a name="Operators_%46member%40%41%32object%32call"></a><div><h3>.member() object call</h3></div>

<p>TODO
</p>


<a name="Operators_%63%46member"></a><div><h3>?.member</h3></div>

<p>The "?." operator, called dotnil operator, works like ".", unless the
expression before the "?." evaluates to NIL.  In that case using "." would
throw an E.NilAccess exception.
When using "?." the result is the default value: zero, NIL or FALSE.
</p>

<pre class='vimCodeElement'>
var?.member   <span class="Comment"># value of &quot;var.member&quot; or 0/FALSE/NIL if var is NIL</span>
</pre>

<p>Simplified syntax:
</p>
<pre>
left?.right
</pre>
<p>When "left" is NIL then the result is the default value for "right".
Otherwise the result is equal to "left.right".
</p>

<p>This is equivalent to:
</p>
<pre>
left == NIL ? 0 : left.right
</pre>
<p>Except that "left" is evaluated only once.
</p>

<pre class='vimCodeElement'>
foo?.member = <span class="Constant">&quot;value&quot;</span>  <span class="Comment"># Does not work!</span>
</pre>

<p>Using "?." on a member in the left-hand-side of a assignment will still throw
E.NilAccess, since there is no place to write the value.
</p>


<a name="Operators_%63%46member%40%41"></a><div><h3>?.member()</h3></div>

<p>The "?." operator, called dotnil operator, works like ".", unless the
expression before the "?." evaluates to NIL.  In that case using "." would
throw an E.NilAccess exception (unless
<a href="#IFNIL">IFNIL</a> is used, see below).
When using "?." the result is  usually the
default return value: zero, NIL or FALSE.
</p>

<pre class='vimCodeElement'>
var?.Size()   <span class="Comment"># size of &quot;var&quot;, or 0 if var is NIL</span>
</pre>

<p>Simplified syntax:
</p>
<pre>
left?.right()
</pre>
<p>When "left" is NIL then the result is the default return value for "right()".
Otherwise the result is equal to "left.right()".
</p>

<p>This is equivalent to:
</p>
<pre>
left == NIL ? 0 : left.right()
</pre>
<p>Except that "left" is evaluated only once.
</p>

<pre class='vimCodeElement'>
mylist?.add(<span class="Constant">&quot;value&quot;</span>)   <span class="Comment"># Does not work!</span>
</pre>

<p>Using "?." on a method that modifies the object will still throw E.NilAccess,
since there is no sensible fallback.
</p>

<p>Note that when using <a href="#IFNIL">IFNIL</a> as the first statement in a method then
"." behaves like "?.".  And the behavior of both depends on the statements inside the <a href="#IFNIL">IFNIL</a> block.
</p>


<a name="Operators_name%91%93%32get%32item"></a><div><h3>name[] get item</h3></div>

<p>TODO
</p>


<a name="Operators_%61name%32Bits%32item%32value"></a><div><h3>=name Bits item value</h3></div>

<p>TODO
</p>


<a name="Operators_%60Type%62%32Template"></a><div><h3>&lt;Type&gt; Template</h3></div>

<p>TODO
</p>


<a name="Operators_%46%60Typecast%62"></a><div><h3>.&lt;Typecast&gt;</h3></div>

<pre class='vimCodeElement'>
foo.&lt;ChildOfFoo&gt;.childOfFooMethod()
</pre>

<p>This operator is most useful when invoking a method on an object which was
declared to be of a parent class, while the method exists on a child class.
</p>

<p>Simplified syntax:
</p>
<pre>
left.&lt;Type&gt;
</pre>

<p>In general, a type is cast from the type of "left" to a more specific type. At
compile time there is only a check if this typecast would be possible for some
value of "left".  If the typecast is never possible that is an error.
</p>

<p>At runtime there will be a check if "left" is indeed of the type being casted
to, or a child of it.  If not than an E.WrongType exception will be thrown.
</p>


<a name="Operators_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
expr             -&gt;  alt-expr  ;
alt-expr         -&gt;  or-expr  ( sep  "?"  sep  alt-expr  sep  ":"  sep  alt-expr )?  ;
or-exp           -&gt;  and-expr  ( sep  "||"  sep  and-expr )*  ;
and-expr         -&gt;  comp-expr  ( sep  "&amp;&amp;"  sep  comp-expr )*  ;
comp-expr        -&gt;  concat-expr  ( sep  ( "==" | "!=" | "&gt;" | &gt;=" | "&lt;" | "&lt;=" | "IS" | "ISNOT" | "ISA" | "ISNOTA" )  sep  concat-expr )*  ;
concat-expr      -&gt;  bitwise-expr  ( sep   ".."  sep  bitwise-expr )* ;
bitwise-expr     -&gt;  shift-expr ( sep  ( "&amp;" | "|"  | "^" )  sep  shift-expr )* ;
shift-expr       -&gt;  add-expr  ( sep ( "&gt;&gt;" | "&lt;&lt;" )  sep  add-expr )* ;
add-expr         -&gt;  mult-expr  ( sep  ( "+" | "-" )  sep  mult-expr )*  ;
mult-expr        -&gt;  incr-expr  ( sep  ( "*" | "/" | "%" )  sep  incr-expr )*  ;
incr-expr        -&gt;  ( "++" | "--" )?  mult-expr  ( "++" | "--" )?  ;
neg-expr         -&gt;  ( "-" | "!" )?  dot-expr  ;
dot-expr         -&gt;  paren-expr  ( TODO )?  ;
paren-expr       -&gt;  "("  skip  expr  skip  ")"  |  base-expr ;
base-expr        -&gt;  ( "EOF" | "NIL" | "THIS" | "TRUE" | "FALSE" | "OK" | "FAIL" | new-item | string | char | number | list | dict | comp-name )  ;
</pre>


<hr>
<a name="Composite%32Names"></a><h2>Composite Names</h2>

<a name="Composite%32Names_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
type           -&gt;  comp-name  ;
comp-name      -&gt;  var-name  comp-follow*
                   | member-name  comp-follow*
                   | group-name  comp-follow+
                   ;
comp-follow    -&gt;  ( dot-item  |  paren-item  |  bracket-item  |  angle-item  )  ;
dot-item       -&gt;  sep-with-eol?  "."  ( var-name | member-name ) ;
paren-item     -&gt;  "("  arguments?  ")"  ;
bracket-item   -&gt;  "[" skip  expr  skip  "]"  ;
angle-item     -&gt;  "&amp;lt;"  arguments  "&amp;gt;"  ;
</pre>


<hr>
<a name="Identifiers"></a><h2>Identifiers</h2>

<p>Using clear names for variables, classes, methods, etc. is very important to
make a program easy to understand.  Here are a few recommendations:
</p>
<ul>
<li>The larger the scope where the name is visible, the longer.  E.g., in a
   block of a few lines you can use "i" for a list index.  In a larger scope
   you would use "listIndex".
</li>
<li>Use abbreviations sparingly.  E.g., everybody knows that "int" stands for
   "integer", thus that is OK.  Few people will know that "ymd" stands for
   "YearMonthDay", avoid that.
</li>
</ul>

<p>A few rules are enforced when using names:
</p>
<ul>
<li>User defined types, thus the name of a class, enum and bits must start with
   an upper case letter and have at leat one lower case letter.
</li>
<li>Module names follow the rules for type names.
</li>
<li>Members, both variables and methods, must start with a lower case letter.
   Except predefined methods, see below.
</li>
<li>Variables start with a lower case letter.
</li>
</ul>

<p>Using CamelCase is recommended, but not enforced.
<pre class='vimCodeElement'>
  <span class="Type">bool</span> camelCaseName          <span class="Comment"># recommended</span>
  <span class="Type">bool</span> underscore_separated   <span class="Comment"># discouraged</span>
</pre>
</p>

<p>It is possible to use the builtin type names for variable names, if you really
want:
<pre class='vimCodeElement'>
  <span class="Type">string</span> <span class="Type">string</span> = <span class="Constant">&quot;foo&quot;</span>
  <span class="Type">bool</span> <span class="Type">bool</span> = <span class="Constant">TRUE</span>
  <span class="Type">dict</span>&lt;<span class="Type">string</span>, <span class="Type">int</span>&gt; <span class="Type">dict</span> = [<span class="Constant">&quot;foo&quot;</span>: 6]
  <span class="Type">func</span>&lt; =&gt; <span class="Type">int</span>&gt; <span class="Type">func</span> = { =&gt; 6 <span class="Statement">}</span>
</pre>
</p>

<a name="Identifiers_Reserved%32names"></a><div><h3>Reserved names</h3></div>

<p>When Zimbu grows and more features are added we want to make sure that your
existing programs keep on working.  Therefore you can not use names that are
reserved for the language itself and for builtin libraries.
</p>

<p>All words made out of upper case letters, underscores and digits are reserved.
When there is at least one lower case letter the word is not reserved.
Examples:
</p>
<pre>
    MY
    THERE_
    MY_NAME
    _OPEN
    KEY2
</pre>

<p>Names cannot contain two or more consecutive underscores.
Examples:
</p>
<pre>
    My__name
    __Foo
    there_____too
</pre>

<p>Type names starting with a lower case letter are reserved for predefined types.
This applies to the name of classes, enums, modules, etc.  Not to member
variables and methods, which actually must start with a lower case letter.
Examples:
</p>
<pre>
    bigInt
    bool
    string
    dict
    multiDict
</pre>

<p>Method and member names starting with an upper case letter are reserved for
predefined methods and members.  The methods can be defined in your class or
module, so long as the arguments and return type match the predefined method,
see <a href="#Method%32Declaration_Predefined%32methods">predefined method</a>.
Examples:
<pre class='vimCodeElement'>
    <span class="Statement">FUNC</span> $ToString() <span class="Type">string</span>
    <span class="Statement">FUNC</span> $Equal(Titem other) <span class="Type">bool</span>
    <span class="Statement">FUNC</span> Main() <span class="Type">int</span>
</pre>
</p>


<a name="Identifiers_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
loop-name     -&gt;  "."  var-name ;
file-name     -&gt;  ( ! NL ) + ;
group-name    -&gt;  upper  id-char*  lower  id-char* ;
var-name      -&gt;  lower  id-char* ;
member-name   -&gt;  upper  id-char*  lower  id-char* | lower  id-char* ;
id-char       -&gt;  alpha | digit | "_" ;
alpha         -&gt;  upper | lower ;
upper         -&gt;  "A" .. "Z" ;
lower         -&gt;  "a" .. "z" ;
digit         -&gt;  "0" .. "9" ;
block-end     -&gt;  "}"  sep-with-eol
</pre>


<hr>
<a name="Values"></a><h2>Values</h2>

<p>The type of a value depends on the context.  For example, using "123" can be an
int or a nat, depending on where it is used.  You will get an error if the
value does not match the expected type. For example, using "1000" for a byte
does not work, a byte can only store a number from 0 to 255.
</p>

<pre class='vimCodeElement'>
   <span class="Type">int</span> a = 1234      <span class="Comment"># 1234 used as an int</span>
   <span class="Type">nat</span> b = 1234      <span class="Comment"># 1234 used as a nat</span>
   <span class="Type">byte</span> c = 1234     <span class="Comment"># Error!  1234 does not fit in a byte</span>
   <span class="Type">list</span>&lt;<span class="Type">int</span>&gt; la = [1, 2, 3]   <span class="Comment"># 1, 2 and 3 used as an int</span>
   <span class="Type">list</span>&lt;<span class="Type">dyn</span>&gt; la = [1, 2, 3]   <span class="Comment"># 1, 2 and 3 used as a dyn</span>
</pre>

<a name="Values_Numbers"></a><div><h3>Numbers</h3></div>

<p>Examples:
<pre class='vimCodeElement'>
0                                     <span class="Comment"># int or nat</span>
-123                                  <span class="Comment"># int</span>
32239234789382798039480923432734343   <span class="Comment"># bigInt or bigNat</span>
0xff00                                <span class="Comment"># int or nat</span>
0b11110000                            <span class="Comment"># int or nat</span>
0.01                                  <span class="Comment"># float</span>
</pre>
</p>

<p>It can be difficult to see the value of large numbers.  Zimbu allows using
single quotes to separate groups of digits.  For Java programmers an underscore
can be used as well.  But the single quote is recommended, it's easier to read.
Swiss bankers use it!
</p>

<pre class='vimCodeElement'>
1'000'000
0xffff'00ff
0b1010'0000'1111'1111

1_000_000
0xffff_00ff
0b1010_0000_1111_1111
</pre>

<a name="Values_Strings"></a><div><h3>Strings</h3></div>

<p>A string value is mostly written with double quotes: "string".  It cannot
contain a literal line break.  Special characters start with a backslash:
</p>
<pre>
\\          \
\'          '
\"          "
\a          BEL 0x07
\b          BS  0x08
\f          FF  0x0c
\n          NL  0x0a
\r          CR  0x0d
\t          TAB 0x09
\v          VT  0x0b
\123        octal byte, must have three digits, start with 0, 1, 2 or 3
\x12        hex byte, must have two hex digits
\u1234      hex character, must have four hex digits
\U12345678  hex character, must have eight hex digits
</pre>
<p>Note that with the \x item it's easy to create invalid UTF-8, only use this for
byteString, not for string.
</p>

<pre class='vimCodeElement'>
<span class="PreProc">IO</span>.write(<span class="Constant">&quot;\u00bb mark \u00ab ¡really!\n&quot;</span>)
<span class="Comment"># output: » mark « ¡really!</span>
</pre>
<p>All Unicode characters can be entered directly, the backslash notation is only
required for control characters.
</p>

<p>A raw string is written as R"string".  Only the double quote character is
special, it must be doubled to get one.  A raw string cannot contain a line
break: a literal line break is not allowed and \n does not stand for a line
break.
<pre class='vimCodeElement'>
<span class="PreProc">IO</span>.print(<span class="Constant">R&quot;contains a \ backslash and a &quot;&quot; quote&quot;</span>)
<span class="Comment"># output: contains a \ backslash and a &quot; quote</span>
</pre>
</p>

<p>A long string can contain line breaks.  Only "'' is special: it always
terminates the string.
<pre class='vimCodeElement'>
<span class="PreProc">IO</span>.write(<span class="Special">''&quot;line one</span>
<span class="Special">line two</span>
<span class="Special">    line three</span>
<span class="Special">&quot;''</span>)
<span class="Comment"># output: line one</span>
<span class="Comment"># line two</span>
<span class="Comment">#    line three</span>
</pre>
Note that leading space is included, also what comes before "''.
</p>


<a name="Values_String%32Expressions"></a><div><h3>String Expressions</h3></div>

<p>A string can contain an expression in \(), for example:
<pre class='vimCodeElement'>
<span class="Type">list</span>&lt;<span class="Type">string</span>&gt; names = [<span class="Constant">&quot;Peter&quot;</span>, <span class="Constant">&quot;John&quot;</span>]
<span class="PreProc">IO</span>.print(<span class="Constant">&quot;The \(</span> names.Size() <span class="Constant">) names are \(</span> names <span class="Constant">)&quot;</span>)
<span class="Comment"># prints: The 2 names are [&quot;Peter&quot;, &quot;John&quot;]</span>
</pre>
After the expression inside \() is evaluated it is converted to a string, as if
calling ToString().
</p>

<p>Inside the \() spaces are optional.  Usually it's easier to read when the \( is followed by a space and there is a space before the ).
</p>

<p>Just after the \( a format can be specified.  This format is passed to the
ToString() method.  Example:
<pre class='vimCodeElement'>
<span class="Type">int</span> number = 111
<span class="Type">int</span> result = -8
<span class="PreProc">IO</span>.print(<span class="Constant">&quot;the \(</span>.5d number<span class="Constant">) is \(</span>5d result<span class="Constant">)&quot;</span>)
<span class="Comment"># prints: the 00111 is    -8</span>
</pre>
There must be no space between the \( and the format.
</p>

<p>All the parts are concatenated into one string result.  The string expression:
<pre class='vimCodeElement'>
<span class="Constant">&quot;the \(</span>5d number <span class="Constant">) is \(</span> result <span class="Constant">)&quot;</span>
</pre>
is equivalent to:
<pre class='vimCodeElement'>
<span class="Constant">&quot;the &quot;</span> .. number.ToString(<span class="Constant">&quot;5d&quot;</span>) .. <span class="Constant">&quot; is &quot;</span> .. result.ToString()
</pre>
</p>


<a name="Values_Lists"></a><div><h3>Lists</h3></div>

<pre class='vimCodeElement'>
[1, 2, 3]
[<span class="Constant">&quot;one&quot;</span>, <span class="Constant">&quot;two&quot;</span>, <span class="Constant">&quot;three&quot;</span>, ]  <span class="Comment"># trailing comma is allowed</span>
[1, <span class="Constant">&quot;two&quot;</span>, [3, 3, 3]]      <span class="Comment"># mix of types can be used for list&lt;dyn&gt;</span>
[]                         <span class="Comment"># empty list</span>
</pre>

<p>The type of the items is inferred from the context.
</p>

<p>A list can also be used to intialize an array and a tuple.  In the case of a
tuple the type of each value must be correct.
</p>


<a name="Values_Dicts"></a><div><h3>Dicts</h3></div>

<p>Dict constants:
<pre class='vimCodeElement'>
[1: <span class="Constant">&quot;one&quot;</span>, 2: <span class="Constant">&quot;two&quot;</span>, ]   <span class="Comment"># trailing comma is allowed</span>
O[1: <span class="Constant">&quot;one&quot;</span>, 2: <span class="Constant">&quot;two&quot;</span>]    <span class="Comment"># with ordered keys</span>
[:]                      <span class="Comment"># empty dict</span>
</pre>
</p>

<p>The type of the keys and items is inferred from the context.
</p>


<a name="Values_Objects"></a><div><h3>Objects</h3></div>

<p>An object initializer can only be used when assigned to an object of a known
class.  The compiler will verify the type of each value.
</p>

<pre class='vimCodeElement'>
{name: <span class="Constant">&quot;Peter&quot;</span>,
  address: {
    street: <span class="Constant">&quot;Gracht&quot;</span>,
    nr: 1234,
    city: <span class="Constant">&quot;Amsterdam&quot;</span>,
  <span class="Statement">}</span>
  phone: [<span class="Constant">&quot;+3120987644&quot;</span>, <span class="Constant">&quot;+31623423432&quot;</span>],
<span class="Statement">}</span>
</pre>

<p>As the example shows nesting is allowed.  Not only with objects, also with
lists, arrays and dicts.
</p>

<p>The class must support a NEW() method without arguments.  It is used to create
an object before applying the values.
</p>

<p>The last comma is optional.
</p>


<a name="Values_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
string           -&gt;  """  ( "^\"" | "\"  ANY )*  """  ;
char             -&gt;  "'"  ( "^\'" | "\"  ANY )  "'"  ;
number           -&gt;  decimal-number | hex-number | binary-number  ;
decimal-number   -&gt;  digit  ( digit | "'")*  ;
hex-number       -&gt;  ( "0x" | "0X" ) ( "0" .. "9" | "a" .. "f" | "A" .. "F" | "'" )+  ;
binary-number    -&gt;  ( "0b" | "0B" ) ( "0" | "1" | "'" )+  ;
list             -&gt;  "["  ( skip  ( expr  ","  sep )*  expr  ( ","  sep)? )?  skip  "]"  ;
dict             -&gt;  empty-dict | non-empty-dict ;
empty-dict       -&gt;  "[:]" ;
non-empty-dict   -&gt;  "["  ( skip  ( dict-item  ","  sep )*  dict-item  ","? )?  skip  "]"  ;
dict-item        -&gt;  expr  skip  ":"  sep  expr  ;
new-item         -&gt;  "NEW"  "("  arguments?  ")"  ;
</pre>


<hr>
<a name="Execution"></a><h1>Execution</h1>

<hr>
<a name="Default%32Values"></a><h2>Default Values</h2>

<p>When a variable has not been explicitly initialized it will have the default
value.  This also applies to all members of an object.  At the lowest level all
bytes have the value zero.
</p>

<div class="rationale">
<a name="Default%32Values_Rationale"></a><div onclick="showHide('r2')"><h3>Rationale</h3><div class="openclose">click to open/close</div></div><div onclick="showHide('r2')" style="display: none" id="r2">

<p>Some languages, such as C, do not use default values.  When allocating memory
it can contain anything.  This avoids the time needed to clear the memory.
However, it has several disadvantages:
</p>

<ul>
<li>The memory often contains data that was previously freed.  This may cause
   private information to leak out. An example is that the structure used by
   the getpwuid() library function showed up in output when a NUL character was
   missing.
</li>
<li>Tests may pass accidentally, depending on the sequence of events.
</li>
<li>The programmer must decide which variables to explicitly initialize.  It's
   easy to forget to initialize a variable.  Some compilers help by giving a
   warning when using an unititilized variable.  That is not reliable though.
</li>
<li>When the computer supports parity check, reading unititilized memory may
   cause the program to crash.
</li>
<li>The explicit initializations take up space, while they often use the default
   value.
</li>
</ul>

<p>Now that computers are very efficient, the time needed to clear the memory is
so small that the disadvantages of not clearing the memory have become more
important.
</div></div>
</p>


<a name="Default%32Values_Default%32values%32for%32types"></a><div><h3>Default values for types</h3></div>

<table cellpadding=0 cellspacing=0 border=0>
<tr class="firstrow" valign="top"><td class="firstcol">type      </td><td class="col">value </td><td class="col">also for</td></tr>
<tr valign="top"><td class="firstcol">bool       </td><td class="col">FALSE </td><td class="col">    </td></tr>
<tr valign="top"><td class="firstcol">status     </td><td class="col">FAIL  </td><td class="col">    </td></tr>
<tr valign="top"><td class="firstcol">int        </td><td class="col">0     </td><td class="col">int8 int16 int32 int64 bigInt</td></tr>
<tr valign="top"><td class="firstcol">nat        </td><td class="col">0     </td><td class="col">byte nat8 nat16 nat32 nat64 bigNat</td></tr>
<tr valign="top"><td class="firstcol">float      </td><td class="col">0.0   </td><td class="col">float32 float64 float80 float128</td></tr>
<tr valign="top"><td class="firstcol">fixed10    </td><td class="col">0     </td><td class="col">fixed1 fixed 2 ... fixed15</td></tr>
<tr valign="top"><td class="firstcol">enum       </td><td class="col">the first item</td></tr>
<tr valign="top"><td class="firstcol">string     </td><td class="col">NIL   </td><td class="col">byteString varString varbyteString</td></tr>
<tr valign="top"><td class="firstcol">container  </td><td class="col">NIL   </td><td class="col">list, dict, set, etc.   </td></tr>
<tr valign="top"><td class="firstcol">object     </td><td class="col">NIL   </td><td class="col">    </td></tr>
</td></tr></table>

<p>For a bits every field will have the default value.
</p>


<hr>
<a name="Startup%32Sequence"></a><h2>Startup Sequence</h2>

<p>Modules and classes can define an Init() method to initialze things when the
program is starting.  In its simplest form this executes code that does
not depend on other initializations.  Example:
<pre class='vimCodeElement'>
<span class="Statement">MODULE</span> Foo
  <span class="Type">list</span>&lt;<span class="Type">string</span>&gt; weekendDays
  <span class="Statement">FUNC</span> Init() <span class="Type">status</span>
    weekendDays = <span class="PreProc">NEW</span>()
    weekendDays.add(<span class="Constant">&quot;Saturday&quot;</span>)
    weekendDays.add(<span class="Constant">&quot;Sunday&quot;</span>)
    return <span class="Constant">OK</span>
  <span class="Statement">}</span>
<span class="Statement">}</span>
</pre>
</p>

<p>The EarlyInit() method is used in the same way, but it is called before the
command line arguments are processed.
</p>

<p>If an Init() or EarlyInit() method depends on other initialization to be done,
and that has not been done yet, it should return FAIL.  It will then be called
again after making a round through all modules and classes.
</p>

<p>This is how it works exactly:
</p>

<ol>
<li>All "static variables" are set to their default value. "static variables"
   are the variables at the module level, variables in the SHARED section of
   a class and variables declared with STATIC in a method.
</li>
<li>The "static variables" with a constant initializer are initialized.
</li>
<li>The "static variables" in builtin modules are initialized.
</li>
<li>One by one, in undetermined order, the "static variables" that have the
   @earlyInit attribute and an assignment are initialized.  This includes
   objects of a class that has the @earlyInit attribute, such as the command
   line flags in the ARG module.<br>
   Note that the expression is evaluated while
   other "static variables" may not have been initialized yet.  It is possible
   to create command line arguments, but they cannot be used yet.
</li>
<li>The EarlyInit() methods are invoked in undetermined order.  This is repeated
   until they all return OK.  An EarlyInit() method is only called again when
   it previously returned FAIL.<br>
   This is aborted with an error after 1000 rounds.<br>
   This allows for anything that needs to be done before command line
   arguments are processed, including calling ARG.replaceRawList() and even a
   complete replacement of the ARG module.<br>
   The Foo.EarlyReady flag indicates
   whether the Foo module or class has finished early initialization.  It is
   TRUE when there is no EarlyInit() method or the EarlyInit() method has
   returned OK.
</li>
<li>Command line arguments are processed, unless ARG.disable() was invoked in
   one of the previous steps.
</li>
<li>One by one, in undetermined order, the "static variables" that have an
   assignment and no @earlyInit attribute are initialized.<br>
   Note that the expression is evaluated while other "static variables" may not
   have been initialized yet.  It is possible to use command line arguments.
</li>
<li>All defined Init() methods are invoked in undetermined order.  This is
   repeated until they all return OK.  An Init() method is only called again
   when it previously returned FAIL.<br>
   For classes only the Init() method in the SHARED section is invoked, not the
   $Init() method.<br>
   This is aborted with an error after 1000 rounds.<br>
   This allows modules and classes to perform initializations that depend on
   other modules and classes.<br>
   The Foo.Ready flag indicates whether the Foo module or class finished
   initialization.  It is TRUE when there is no Init() method or the Init()
   method has returned OK.
</li>
<li>Main() is called.
</li>
</ol>

<p>Illustration:
<pre class='vimCodeElement'>
<span class="Statement">MODULE</span> Foo
  <span class="Comment"># A boolean command line argument &quot;-v&quot; or &quot;--verbose&quot;.</span>
  <span class="Comment"># This will be initialized in step 3, because ARG.Bool has the @earlyInit attribute.</span>
  <span class="PreProc">ARG</span>.Bool verbose = <span class="PreProc">NEW</span>(<span class="Constant">&quot;v&quot;</span>, <span class="Constant">&quot;verbose&quot;</span>, <span class="Constant">FALSE</span>, <span class="Constant">&quot;Verbose messages&quot;</span>)

  <span class="Comment"># This will be initialized in step 6, after &quot;verbose&quot;.</span>
  <span class="Type">string</span> leader = verbose.value() ? <span class="Constant">&quot;Foo module: &quot;</span> : <span class="Constant">&quot;&quot;</span>

  <span class="Comment"># This will be invoked in step 7, after &quot;leader&quot; was initialized.</span>
  <span class="Statement">FUNC</span> Init() <span class="Type">status</span>
    <span class="Statement">IF</span> Bar.Ready    <span class="Comment"># when Bar has been initialized</span>
      Bar.setLeader(leader)
      <span class="Statement">RETURN</span> <span class="Constant">OK</span>     <span class="Comment"># initialization of Foo is done</span>
    <span class="Statement">}</span>
    <span class="Statement">RETURN</span> <span class="Constant">FAIL</span>     <span class="Comment"># we need another round</span>
  <span class="Statement">}</span>
<span class="Statement">}</span>
</pre>
</p>

<p>If a class extends a class that has an Init method, and it does not define its
own Init method, the Init method of the parent is invoked. Only one "Ready"
flag is used to avoid calling it again after it returns OK.
</p>

<p>Note that the initialization happens in one thread. If an Init() or EarlyInit()
blocks then the whole program startup is blocked.  It is not a good idea to
block on something that takes longer than reading a file.  Internet connections
are better not used, unless the program really can't do anything without them.
</p>


<hr>
<a name="Object%32Initialization%32Sequence"></a><h2>Object Initialization Sequence</h2>

<p>When NEW() is invoked to create a new object, this happens:
</p>

<ol>
<li>The object is allocated with all members set to their default value.
</li>
<li>If members are assigned a value in the declaration, these are executed. This
   happens in the order the members are declared.  If the class extends a
   parent, this is first done in that parent (and its parent, etc.).
</li>
<li>If an $Init() method exists it is invoked.  If the class extends a parent,
   its $Init() method is invoked first (and in the parent of the parent, etc.).
   But the method is always invoked in the context of the created class, thus
   replaced methods are invoked.
</li>
<li>The NEW() method is executed.
</li>
</ol>

<p>The $Init() method is a PROC without arguments.
</p>

<p>It is allowed to call $Init() again later. It will execute both the assignments
for members and the body of the $Init() method.  That includes the parent
class, and its parent, etc.  Note that none of the NEW() methods are called.
</p>

<p>Best is to do simple initializations in the declaration, e.g.:
</p>

<pre class='vimCodeElement'>
<span class="Statement">CLASS</span> Example
  <span class="Type">list</span>&lt;<span class="Type">int</span>&gt; $numbers = <span class="PreProc">NEW</span>()
  <span class="Type">string</span> $message = <span class="Constant">&quot;this is an example&quot;</span>
<span class="Statement">}</span>
</pre>

<p>More complicated initializations belong in $Init():
</p>

<pre class='vimCodeElement'>
<span class="Statement">CLASS</span> Example
  <span class="Type">list</span>&lt;<span class="Type">int</span>&gt; $numbers = <span class="PreProc">NEW</span>()
  <span class="Type">string</span> $message

  <span class="Statement">PROC</span> $Init()
    <span class="Statement">FOR</span> i <span class="Statement">IN</span> 1 <span class="Statement">TO</span> 10
      $numbers.add(i)
    <span class="Statement">}</span>
    <span class="Statement">IF</span> Lang.current == Lang.ID.nl
      $message = <span class="Constant">&quot;dit is een voorbeeld&quot;</span>
    <span class="Statement">ELSE</span>
      $message = <span class="Constant">&quot;this is an example&quot;</span>
    <span class="Statement">}</span>
  <span class="Statement">}</span>
<span class="Statement">}</span>
</pre>

<p>Keep in mind that these initializations cannot be overruled in sub-classes.
Use NEW() if you do want that.
</p>


<hr>
<a name="Object%32Destruction"></a><h2>Object Destruction</h2>

<p>Garbage collection (GC) will find allocated objects that are no longer used and
free the associated memory.  This is done automatically, the programmer does
not need to keep track of what objects are in use.  The GC can be invoked
intentionally with:
<pre class='vimCodeElement'>
<span class="PreProc">GC</span>.run()
</pre>
</p>

<p>Normally there are no side effects when an object is destructed, other than the
memory becoming available.  If a side effect is desired, a Finish method can be
defined. For example, when an object is used to keep track of a temp file:
</p>

<pre class='vimCodeElement'>
<span class="Statement">CLASS</span> TempFileName
  <span class="Type">string</span> $tempFileName

  <span class="PreProc">NEW</span>()
    $tempFileName = createTempFile()
  <span class="Statement">}</span>

  <span class="Statement">FUNC</span> $Finish() <span class="Type">status</span>
    <span class="Statement">IF</span> $tempFileName != <span class="Constant">NIL</span>
      <span class="PreProc">IO</span>.delete($tempFileName)
      $tempFileName = <span class="Constant">NIL</span>  <span class="Comment"># only delete it once</span>
    <span class="Statement">}</span>
    <span class="Statement">RETURN</span> <span class="Constant">OK</span>
  <span class="Statement">}</span>
<span class="Statement">}</span>
</pre>

<p>NOTE: $Finish() is only supported for generated C code, not for Javascript.  <br>
NOTE: $Finish() is not called when memory management has been disabled at
compile time with --manage=none. <br>
NOTE: An alternative is to use a DEFER statement.  The advantage is that the
work is done at the end of the function, not later when the object is
garbage collected.  The disadvantage is that it requires an extra statement.
</p>

<p>Finish has one optional argument: Z.FinishReason.  This specifies the reason
why it was called.
</p>

<p>An attribute <b>@notOnExit</b> can be added to the Finish method.  It will then
not be called when the program is exiting.  This is used by IO.File.Finish() to
prevent the stdin/stdout/stderr files to be closed when exiting.
</p>

<p>The Finish method can do anything.  For allocated objects, if Finish() is
called with <b>unused</b> and it returns FAIL this prevents
the object from being freed. Also, when executing the
Finish() method causes the object to be referenced from another object that is
in use, the object will not be freed.
</p>

<p>If a Finish method throws an exception it is caught and a message is written to
stderr.  Finish will not be called again, just like when it returned OK.
However, running out of memory or another fatal error may cause the program to
exit, and some Finish methods may not be called.
</p>

<p>For not allocated objects, e.g., on the stack, the Finish() method is called
once when leaving the block it was defined in, with an argument <b>leave</b>.
Exceptions will be thrown as usual.  This can be used to automatically executed
code at the end of the block:
</p>

<pre class='vimCodeElement'>
<span class="Statement">FOR</span> name <span class="Statement">IN</span> [<span class="Constant">&quot;1&quot;</span>, <span class="Constant">&quot;22&quot;</span>, <span class="Constant">&quot;333&quot;</span>]
  TempFileName %tf = <span class="PreProc">NEW</span>()
  doSomething(tf, name)  <span class="Comment"># uses the temp file.</span>
  <span class="Comment"># %tf.Finish() called here, because leaving the block where %tf is declared</span>
<span class="Statement">}</span>
</pre>

<p>When an exception causes the block to be left, the same happens as when the
block is left in a normal way, thus Finish() is called with <b>leave</b>.
</p>

<p>In a single-threaded application Finish methods will be called by the GC,
and thus delay execution of the program.  To avoid this put work to be done in
a work queue (e.g. using a pipe), and invoke it at a convenient time.
</p>

<p>In a multi-threaded application Finish methods will be called by the same
thread that executes the GC. This is usually OK, but if a Finish method takes
very long it prevents from the next GC round to happen.  To avoid this run a
separate thread to do the work, using a pipe to send the work from the Finish
method to that thread.
</p>

<p>One can also call Finish directly.  This is useful to avoid waiting for the GC
to kick in.  You are expected to pass the <b>called</b> argument, but this is
not enforced.  Returning OK will prevent the method from being called again.
The method can be called this way multiple times, also when it returned OK
previously. Exceptions are not caught like when Finish is called by the GC.
</p>

<p>This is how objects with a Finish method are handled by the GC:
</p>

<ol>
<li>GC will locate objects that are no longer used and have a Finish method that
   did not return OK yet.  These are moved to the toFinish list.
   Unused objects that have a Finish method that were already called and
   returned OK will be freed.
</li>
<li>The members of objects in the toFinish list are marked as used, and its
   members recursively.
</li>
<li>If there is at least one object in the toFinish list that is not marked (not
   referenced by other objects in the toFinish list),
   the marked objects are removed (put back in the list of used objects).
   Otherwise all objects are kept (they refer to each other somehow).
</li>
<li>The Finish methods of the objects in the toFinish list are invoked. The
   return value is remembered, if it is OK the Finish method will not be called
   by the GC again.
</li>
<li>The objects are moved back from the toFinish list to the list of used
   objects.
</li>
</ol>

<p>The result is that an object with a Finish() method is not freed in the first
GC round, but only in the GC round after it returned OK.
</p>

<p>On exit (also when exiting because of an exception) the following happens:
</p>

<ol>
<li>All objects that have a Finish method that did not return OK yet are moved
   to the toFinish list.
</li>
<li>The Finish method of the objects in the toFinish list is invoked.
   The Z.exiting flag can be used to detect that Finish was called because the
   program is exiting.
</li>
</ol>

<p>The program may hang on exit when a Finish() method hangs.  It is up to the
programmer to make sure this does not happen.  When a Finish() method throws an
exception that is does not catch itself, e.g. when running out of memory or a
NIL pointer access, the exception will be written to stderr.  If an error
occurs that is not caught the program will exit with some Finish() methods not
being called.
</p>


<hr>
<a name="Syntax"></a><h1>Syntax</h1>

<hr>
<a name="White%32Space%32and%32Comments"></a><h2>White Space and Comments</h2>

<a name="White%32Space%32and%32Comments_Comments"></a><div><h3>Comments</h3></div>

<p>There are two types of comments.  The first type starts with a # and continues
until the end of the line. Multi-line comments require repeating the # in every line.
</p>

<p>The second type of comment starts with /* and ends with */.  This comment must
not contain a line break.
</p>

<p>Comments can be used in many places, but not inside a string.
</p>

<p>Recommended is to make the comment either a short note or a full sentence.  A
sentence starts with a capital letter and ends in a full stop, while a short
note does not.
<pre class='vimCodeElement'>
<span class="Comment"># Whole line comments are usually a sentence.</span>
idx++  <span class="Comment"># next item</span>
b = 0  <span class="Comment"># Reset b so that blah blah blah blah blah blah blah blah.</span>
</pre>
</p>

<p>Zudocu can be used to generate documentation from source code.  Special markers
in the comments are used. A wiki-like syntax is used for formatting.  See
the <a href="http://www.zimbu.org/documentation/generating-docs">web page</a>.
This is extensively used in the Zimbu library code.
</p>

<a name="White%32Space%32and%32Comments_White%32space"></a><div><h3>White space</h3></div>

<p>Zimbu is very strict about use of white space.  This ensures that every Zimbu
program that compiles has at least the basic spacing right.  Examples:
<pre class='vimCodeElement'>
  a=<span class="Constant">&quot;foo&quot;</span>    <span class="Comment"># Error: Must have white space before and after the &quot;=&quot;.</span>
  a = <span class="Constant">&quot;foo&quot;</span>  <span class="Comment"># OK</span>
  f(1,2)     <span class="Comment"># Error: A comma must be followed by white space.</span>
  f(1, 2)    <span class="Comment"># OK</span>
  f( 1)      <span class="Comment"># Error: No white space after &quot;(&quot; if text follows.</span>
  f(1 )      <span class="Comment"># Error: No white space before &quot;)&quot; if text precedes.</span>
  f(1)       <span class="Comment"># OK</span>
</pre>
</p>

<p>Zimbu uses line breaks to separate statements, so that there is no need for a
semicolon.  This is done in a natural way, the exact syntax specifies what the
rules are.
</p>

<p>If you do want to put several statements in one line, use a semicolon as a
statement separator:
<pre class='vimCodeElement'>
<span class="Statement">SWITCH</span> count
  <span class="Statement">CASE</span> 0; $write(<span class="Constant">&quot;no items&quot;</span>); <span class="Statement">RETURN</span> <span class="Constant">FAIL</span>
  <span class="Statement">CASE</span> 1; $write(<span class="Constant">&quot;1 item&quot;</span>); <span class="Statement">RETURN</span> <span class="Constant">OK</span>
  <span class="Statement">DEFAULT</span>; $write(<span class="Constant">&quot;\(</span>count<span class="Constant">) items&quot;</span>); <span class="Statement">RETURN</span> <span class="Constant">OK</span>
<span class="Statement">}</span>
</pre>
</p>

<a name="White%32Space%32and%32Comments_Notes%32on%32the%32exact%32syntax"></a><div><h3>Notes on the exact syntax</h3></div>

<table cellpadding=0 cellspacing=0 border=0>
<tr valign="top"><td class="firstcol">line-sep    </td><td class="col"></td><td class="col">Line separator: Either a semicolon or an NL with optional
                    white space and comments.</td></tr>
<tr valign="top"><td class="firstcol">semicolon   </td><td class="col"></td><td class="col">A semicolon with mandatory following white space. This is
                    only used to separate statements.</td></tr>
<tr valign="top"><td class="firstcol">sep-with-eol</td><td class="col"></td><td class="col">At least one line break, with optional comments and white
                    space.</td></tr>
<tr valign="top"><td class="firstcol">sep         </td><td class="col"></td><td class="col">Mandatory white space with optional comments and line
                    breaks.</td></tr>
<tr valign="top"><td class="firstcol">skip        </td><td class="col"></td><td class="col">Optional white space, comments and line breaks.</td></tr>
<tr valign="top"><td class="firstcol">white       </td><td class="col"></td><td class="col">One or more spaces.</td></tr>
<tr valign="top"><td class="firstcol">comment     </td><td class="col"></td><td class="col">One comment, continues until the end of the line.</td></tr>
</td></tr></table>

<a name="White%32Space%32and%32Comments_Exact%32syntax"></a><div><h3>Exact syntax</h3></div>

<pre>
line-sep      -&gt;  semicolon | sep-with-eol ;
semicolon     -&gt;  ";" white
sep-with-eol  -&gt;  ( white comment )?  NL  skip ;
sep           -&gt;  ( white | NL ) skip ;
skip          -&gt;  ( ( white | NL ) ( white | comment | NL )* )? ;
white         -&gt;  " "+ ;
comment       -&gt;  "#" ( ! NL )* ;
</pre>


<hr>
<a name="Exact%32Syntax%32Notation"></a><h2>Exact Syntax Notation</h2>

<pre>
one-item    non-terminal
"abc"       terminal representing string literal "abc"
"a" .. "z"  terminal: a character in the range from "a" to "z"
"^abc"      terminal: any character but "a", "b" or "c"
NL          terminal, New Line character, ASCII 0x0a
ANY         terminal, any character not discarded by the preprocessor

-&gt;          produces
|           alternative
;           end of rule
()          group items into one non-terminal
?           preceding item is optional
*           preceding item appears zero or more times
+           preceding item appears one or more times
!           anything but next item
</pre>

<hr>
<a name="Copyright"></a><h1>Copyright</h1>

<p>Copyright 2013 Bram Moolenaar  All Rights Reserved.
</p>

<p>Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
The License can be found it in the LICENSE file, or you may obtain a copy of
the License at http://www.apache.org/licenses/LICENSE-2.0
</p>

<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
License for the specific language governing permissions and limitations
under the License.
</p>

</body>
</html>
