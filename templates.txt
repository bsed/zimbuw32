ZUT: ZIMBU TEMPLATES

[ZWT notes below ZUT]

Current work:
- Add controller for balloon text on hoover-over:
        Use mouseOver and mouseOut events, both on the element and on the
        balloon.
        Pass in a template for the balloon, using a callback.
        Use a timer to delay show and hide.
  -> How to add this to an element in another template?
- Pluginzut should handle white space in a better way, easy to understand
  and allow for inserting/removing white space where desired.
- ZUT.Context passed around during HTML and CSS generation.
   - Methods to detect browser properties.
   - Methods to manipulate the DOM (like jQuery?)
   - Current name is "context".  Use "ctx" or something else?

============================  ZUT  ===============================

Currently ZWT can generate a UI from widgets, generating HTML in Javascript.
It does not allow for editing HTML directly.  And the whole page is build in
the client.  Since more and more programmers work with HTML an approach where
HTML and CSS can be entered directly would be preferred. And server-side
rendering improves responsiveness and reduces the size of the files tha the
client uses.

There are six building blocks:

1. Server side code for answering browser requests.
   E.g. to serve a page, image, CSS, scripts, XML requests, etc.
   When a page is served it can point to static HTML or a template handler.
   The template handler first triggers business logic, then calls the renderer
   to fill in the templates.

2. Businiss logic:
   Uses the request, does backend lookups and fills in the arguments used by
   the templates (possibly protocol buffers with deeply nested info).
   When invoked for an XML request it responds to that.
   Written in Zimbu, compiled into binary.  When this changes the server needs
   to be restarted.

3. Template compiler:
   Input is a template containing HTML, CSS with arguments and conditions
   Each template has a name with an entry point, specifying the data that goes
   in.  The data is made of two parts:
   1. request context, available to all templates (e.g., browser type)
   2. arguments, like a function call
   Takes care of escaping text, translated strings, RTL, etc.
   CSS is also included and manipulated.  CSS associated with a template is
   included when used.
   There are hooks for having the HTML manipulated from Javascript.

   Version A: Produces binary code, a change requires a server restart if the
   templae is used server side.
     Takes a .zut template and produces functions that renders it.
     This results in a Zimbu file, which is compiled into binary (server side)
     or Javascript (client side).
     The produced functions return HTML where parts are changed at runtime.

   Version B: Produces a compiled template, which is executed by the template
   interpreter.  Can be replaced without restarting the server.
     The interpreter takes a render-ready template, renders it using the
     arguments provided.
     Interprets Zimbu expressions that were compiled into an intermediate
     format.
     This is a bit slower to execute and only allows for using existing
     business logic.

4. Client code for dynamic HTML.
   This is Zimbu code, compiled into Javascript.  This will be executed by the
   browser.
   This can use ZWT code to create parts of the DOM.
   This can also use templates.  It's like the client side businiss logic.
   It invokes a client-side version of the renderer.
   This can do async server requests to update the page.

5. Scripts are split up in modules.  Each module can be loaded separately,
   this avoids having to load all the scripts that might ever be used when
   first loading the page.  Dependencies between modules are handled
   automatically: When the client asks the server for a module, the modules
   it depends on are also loaded.

A few requirements:
- While developing code it is very convenient if templates can be edited and
  get used without restarting the HTTP server.
- Updating web pages without restarting the server is good as well, avoids
  down time.
- Type safety also for templates.  The values are passed like function
  arguments.  Use a protocol buffer for flexibility.
- Support building blocks that take care of specific browsers, translation,
  etc.
- It should also be possible to use templates to generate static HTML pages,
  e.g. the Zimbu documentation, as generated by zudocu.
- Support for class renaming (use short names in the browser)

It would be possible to parse and process the templates on the fly.  However,
that will be inefficient.  Better is to compile the template into something
that executes fast.  It could be compiled into binary code, but then the
requirement for changing templates without restarting the server can't be met.
Instead the template can be compiled into a form that is efficient to use.
Let's call this a template script.

    [HTML/CSS template]        +       [Zimbu controller code]
              |                                 |
              V                                 V
       template compiler       +           Zimbu compiler
              |                                 |
              V                                 V
  [HTML/CSS strings + Javascript]           [Javascript]
              |                                 |
              +---------------------------------+
                                  |
                                  V
                            HTTP server
                                  |
                                  V
                         [HTML + CSS + Javascript]

The template compiler can do a partial build when there are small changes, or
a full build when needed.

The HTTP server would still need to be restarted if RPCs from the browser to
the server change.  This can be avoided by having RPCs in a container.


Examples and ideas:
- Google Closure .soy templates.  Require strict typing.
- Google Closure stylesheets
- JsAction   https://github.com/google/jsaction
- Clearsilver: www.clearsilver.net  (has security holes)
- Angular
- jQuery


Later:
- Figure out dependencies and split up "all.js" into modules.
  The server will handle requests for modules, knowing the name of the
  controller it locates the Javascript.
  In ZUT.Page one may add controllers that are loaded right away.
        page.addController()
  Others will be loaded from the server when used, including their
  dependencies.
  In ZUT.page one may add CSS early, so that it won't be added when a template
  is used.  Could omit it from the template then.
        page.addCss()
- Zimbu Template Language (ZUT, file.zut)
   -> Defines a module with a name
   -> Defines Zimbu code with strings and methods to return strings
      These can be used in the CSS and HTML blocks
   -> Defines CSS (one block?)
   -> Defines one or more HTML templates, they look like function calls.
   -> At the top imports other .zut files.
   -> Special codes in CSS and HTML:
        [variableName]
        [expression]
        [IF expr]
        [}]
        [[   single [

- Generate Zimbu code from template.  Can use IMPORT.ZUT ?
- Provide condition on browser type, mobile/tablet, language, etc.
        library of utilities - server and/or client side

ZUT plugin:
- Checks that all CSS class names used are defined.
- Renames class names to short names (unless defined extern).
- Generates unique IDs.
- Templates can invoke other templates and pass arguments.
 
At runtime:
- All events are caught, find the lowest "zaction" attribute, then the lowest
  controller.  Load and instantiate the controller if needed.
  Invoke the method on the controller with the event.
  If the method returns TRUE the event bubbles up.
  The method can also generate events.

Possible example  AddressForm.zut:

IMPORT.ZUT "Button.zut"

ZUT AddressForm

  string backgroundColor = ZUT.rgb(235, 239, 249)
  string errorColor = ZUT.Color.red

  FUNC size(int width, int height)
    RETURN " width: \(width)px; height: \(height)px;"
  }

  # External class names and IDs, not to be renamed.
  EXTERN
    shadow
  }

  CSS
    .formColor {
      background-color: [backgroundColor];
    }

    # Color for an error
    .error {
      color: [errorColor]; /* CSS comment */
    }

    .country {
      [IF ZUT.mobile]
        [size(300, 20)]
      [ELSEIF ZUT.tablet]
        [size(400, 30)]
      [ELSE]
        [size(500, 30)]
      [}]
    }
    .hidden {
      display: none;
    }
  }

  HTML address(bool international, string buttonName)
    <form class="formColor shadow" zcontroller="AddressController">
      <div>
        <span>Street address:</span>
        <input type="text" name="street" zaction="change: updateButton">
      </div>
      <div>
        <span>City:</span>
        <input type="text" name="city" zaction="change: updateButton">
      </div>
      <div>
        <span>Zip code:</span>
        <input type="text" name="zip" zaction="change: updateButton">
      </div>
      [IF international]
        <div>
          <span class="country">Country:</span>
          <input type="text" name="country" zaction="change: updateButton">
        </div>
      [}]
      [IF !buttonName.empty()]
        <div id="button">
          [RENDER Button.submit(buttonName, "click: submit")]
        </div>
        <div id="message" class="hidden">
          Submitted
        </div>
      [}]
    </form>
  }
}

In the AddressController.zu file:

CLASS AddressController
  bool $buttonEnabled

  # Return TRUE when the event bubbles up.
  FUNC $updateButton(ZUT.Event e) bool
    # check the input fields on every change and when they are
    # invalid disable the button.
    list<ZUT.Element> inputs = e.findAll("input")
    $buttonEnabled = TRUE
    FOR el IN inputs
      IF el.value().empty()
        $buttonEnabled = FALsE
        BREAK
      }
    }
    Button b = e.find(Button)
    b.setVisible($buttonEnabled)
    return FALSE
  }

  # Return TRUE when the event bubbles up.
  FUNC $submit(ZUT.Event e) bool
    ZUT.Element buttonEl = e.findId("button")
    buttonEl.addClass("hidden")
    e.findId("message").removeClass("hidden")

    AddressForm form = NEW()
    form.setStreet(e.findName("street").value())
    form.setCity(e.findName("city").value())
    form.setZip(e.findName("zip").value())
    form.setCountry(e.findName("country")?.value())
    RPC.send(form)
  }
}

If the button has zaction="click: clicked" and the button controller does
something with it (e.g., changes the decoration), then how does the higher
level AddressController get this event?
-> We do not want to install listeners, it adds too much code.
- The button controller generates a custom event "button clicked" with the ID
  of the button.

NOTES
- Should be able to change zudocu into using these templates.
- Info about changing style from Javascript:
    http://www.w3.org/wiki/Dynamic_style_-_manipulating_CSS_with_JavaScript

====================  ZUT documentation  ===========================

A ZUT file ends in .zut.  It is imported with IMPORT.ZUT.  Example:

        IMPORT.ZUT "ZutDemoPage.zut"

At the toplevel there must be one MODULE with a name matching the file name.

In the MODULE can be any Zimbu code.  There are two special items: CSS and
HTML.  Their syntax is similar to a PROC, but the contents is CSS and HTML
text.  Except that text in square brackets has a special meaning.

MODULE MyZutModule

  CSS cssMethodName(string color)
    .myclass {
      color: [=color];
    }
  }

  HTML htmlMethodName(string name)
    <div>
      Hello [=name]!
    </div>
  }
}

The square brackets have two forms:

   [=expression]  Evaluates the expression and the result is inserted in its
                  place

   [statement]    Will execute the Zimbu statement at runtime.

============================  ZWT  ===============================

IMPORTING ZWT MODULE

The UI of a ZWT application is defined in a separate Zimbu file.  It uses
exactly the same syntax, the only special thing about it is how it's imported:

        IMPORT.ZWT "ui.zu"

This implies that "ui.zu" must be produced as a Javascript file, to be loaded
by a browser.

The way style sheets are used in ZWT makes it difficult to debug.  Is there
another way?

ZWT: does script need to use "parent" or can it be "window"?

-> Have a look at qooxdoo.org.  Interesting widget model.
   The layout mechanism and Themes look interesting.

-> Separate:
     Looks/Theme - color, border, font, etc.
     Layout - position, stretching, wrapping, scrollbars, etc.
     Control - actions, drag&drop, submit, etc.
   To be fixed: current Style mixes looks and layout.

-> set Style on all table cells, use ".class td" selector.

-> set Style on all cells in table row.  How?

-> IO.write() doesn't work in ZWT.  Give error or write to console?

-> Caching for main zwt file 5 minutes?
    implement HTTP.Servlet.setCacheTime(seconds)

-> Allow setting primary and additional styles.  Also by name, so that an
   external CSS file can be used.

-> Turn IO.print() into ZWT.write()?  Don't produce fputs() at least.
      dump("Error message not found!");

Should permuNames be an enum?  Should have permutations for
	browser and language.

How to split up a ZWT tree into more than one JS file?




Copyright 2014 Bram Moolenaar  All Rights Reserved
Licensed under the Apache License, Version 2.0.  See the LICENSE file or
obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0

vim: set tw=78 et sw=2 :
