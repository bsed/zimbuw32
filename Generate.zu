#
# The Zimbu compiler written in Zimbu
#
# Generate module: everything related to generating C code.
# This includes collecting symbols.
#
# Copyright 2009 Bram Moolenaar  All Rights Reserved.
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#
# Characters prepended to symbols:
# V   variable or member
# M   module
# F   function or method
# C   class
# E   array of enum names
# GC  Zimbu internal functions
#

IMPORT.PROTO "zui.proto"

IMPORT "Annotator.zu"
IMPORT "ArrayStuff.zu"
IMPORT "BitsType.zu"
IMPORT "BitsValueType.zu"
IMPORT "BlockScope.zu"
IMPORT "Builtin.zu"
IMPORT "CallbackType.zu"
IMPORT "ClassRefType.zu"
IMPORT "ClassScope.zu"
IMPORT "ClassType.zu"
IMPORT "CodeProperties.zu"
IMPORT "Config.zu"
IMPORT "ContainerType.zu"
IMPORT "Debug.zu"
IMPORT "DeclStore.zu"
IMPORT "Declaration.zu"
IMPORT "DictStuff.zu"
IMPORT "EnumType.zu"
IMPORT "EnumValueType.zu"
IMPORT "ExprArg.zu"
IMPORT "ExprEval.zu"
IMPORT "FileScope.zu"
IMPORT "ForLoopInfo.zu"
IMPORT "ListStuff.zu"
IMPORT "MainFile.zu"
IMPORT "MethodRefType.zu"
IMPORT "MethodScope.zu"
IMPORT "MethodType.zu"
IMPORT "ModuleScope.zu"
IMPORT "ModuleType.zu"
IMPORT "MultipleType.zu"
IMPORT "NoAllocType.zu"
IMPORT "Output.zu"
IMPORT "PieceScope.zu"
IMPORT "Pos.zu"
IMPORT "ReferenceType.zu"
IMPORT "Resolve.zu"
IMPORT "SContext.zu"
IMPORT "Scope.zu"
IMPORT "SharedScope.zu"
IMPORT "SwitchScope.zu"
IMPORT "SymUse.zu"
IMPORT "Template.zu"
IMPORT "TopScope.zu"
IMPORT "TupleType.zu"
IMPORT "TryScope.zu"
IMPORT "Type.zu"
IMPORT "TypedefType.zu"
IMPORT "UsedFile.zu"
IMPORT "ValueType.zu"
IMPORT "Visibility.zu"
IMPORT "WriteCommon.zu"
IMPORT "ZimbuFile.zu"
IMPORT "ZuiFile.zu"
IMPORT "ZuiCodeBlockExt.zu"
IMPORT "ZuiDeclarationExt.zu"
IMPORT "ZuiExpressionExt.zu"
IMPORT "ZuiForStatementExt.zu"
IMPORT "ZuiImportExt.zu"
IMPORT "ZuiMethodCallExt.zu"
IMPORT "ZuiMethodTypeExt.zu"
IMPORT "ZuiStatementExt.zu"
IMPORT "ZuiTryStatementExt.zu"
IMPORT "ZuiTypeExt.zu"

IMPORT "genC/WriteC.zu"

IMPORT "lib/TModule.zu"
IMPORT "lib/ZWTLoader.zu"

MODULE Generate @items=public                   # TODO: restrict visibility

  # For debugging: Set to FALSE to enter all scopes even when there were no
  # undefined symbols in a previous pass.
  ARG.Bool undefinedFlag = NEW("z", "zeroundef", TRUE,
                   "Skip resolving symbols if there are no undefined symbols")
  bool skip_zero_undefined = undefinedFlag.value()

  ARG.Bool keepUnusedFlag = NEW(NIL,
                                 "keepunused", FALSE, "Do write unused items")

  # For debugging: Mark items as used even when undefined is non-zero
  bool usedWhenUndefined = FALSE

  # When the number of undefined symbols does not go down to zero this flag is
  # set before writing the code.  Unused items will be produced so that they
  # can generate errors.
  bool undefinedNonZero

  # When this flag is set we continue compiling files even after an error was
  # found.
  bool continueAfterError

  # When this flag is set we are trying to locate a place where undefined is
  # non-zero.  That's a bug in the compiler.
  bool reportUndef

  FUNC skipUnused() bool
    RETURN !keepUnusedFlag.get() && !undefinedNonZero
  }

  # When starting to generate this flag is set to FALSE.  Once a file is
  # encountered that requires another pass it is set to TRUE.
  bool needAnotherPass

  # For debugging: In an area with something interesting.
  bool verbose

  # Call resolve() for |usedFile|.  Used at toplevel.
  # Return TRUE if another pass is needed.
  FUNC resolve(UsedFile usedFile, SContext ctx) bool
    needAnotherPass = FALSE
    RETURN resolve(usedFile, "", ctx)
  }

  # Go through the statements of a file to resolve symbols.
  # |indent| is used for progress messages.
  #
  # Return TRUE if another pass is needed.
  FUNC resolve(UsedFile usedFile, string indent, SContext ctx) bool
    usedFile.zimbuFile.startedPass = ctx.topScope.pass
    string leader = indent .. usedFile.zimbuFile.filename
    FileScope fileScope = usedFile.scope()
    ZuiFile zuiFile = usedFile.zimbuFile.zuiFile

    Zui.Statement firstStatement = fileScope.getFirstStatement()
    IF firstStatement == NIL
      LOG.info("\(leader): Empty file")
      IF zuiFile.contents.sizeStatement() != 0
        LOG.error("\(leader): Does have statements")
      }
      RETURN FALSE
    }

    int previousUndef = fileScope.undefined

    # Set the indent on the scope again, it changes when finding builtin
    # modules and when skipping files.
    fileScope.importIndent = indent

    # This may recursively call back for IMPORT statements.
    LOG.info("\(leader): Check imports...")
    int undef = generateImports(usedFile, ctx)

    # No need to resolve symbols when already done this pass level.
    # This happens when we want to check the imports.
    bool needPass
    IF fileScope.topscopePass > ctx.topScope.pass
      needPass = previousUndef > 0
    ELSE
      fileScope.topscopePass = ctx.topScope.pass + 1
      LOG.info("\(leader): Pass \(fileScope.pass)...")

      int generateUndef = generate(fileScope, ctx)
      undef += generateUndef
      fileScope.undefined = undef

      # Do some inits of this file.
      ctx.gen.afterGenerate(usedFile, NIL, ctx)

      LOG.info("\(leader): Pass \(fileScope.pass) done.", flags = noNewline)
      IF undef > 0
        LOG.info(" (\(undef) undefined symbols)", flags = noNewline)
      }
      LOG.info("")
      fileScope.pass++

      # We need another pass when there are undefined symbols.
      # However, if no symbols were resolved there might be an error, so don't
      # do another pass then.
      # Sometimes including another module causes the number of undefined
      # symbols to increase.  Only stop when the number doesn't change.
      # Also stop after 20 passes, catches errors in the compiler.
      needPass = undef > 0
                     && fileScope.pass < 20
                     && (fileScope.pass == 2 || undef != previousUndef)

      # Debug undefined symbols not going down to zero.  Only do this when we
      # did not encounter a file that requires another pass, since that means
      # something may be undefined and we will get back here later.
      IF !needPass && generateUndef > 0 && LOG.isDebug() && !needAnotherPass
        Debug.listUndefined(fileScope.statements, ctx)
      }
      IF needPass
        needAnotherPass = TRUE
      }

      # When we do not do another pass but undefined is not zero, set a flag so
      # that we generate all code to see the error messages.
      IF needAnotherPass
        undefinedNonZero = FALSE
      ELSEIF undef > 0
        undefinedNonZero = TRUE
      }
    }

    RETURN needPass
  }

  #
  # Write C code for |usedFile|.
  #
  PROC write(UsedFile usedFile, SContext ctx, Output.Group outputs)
    write(usedFile, ctx, outputs, "")
  }

  #
  # Write the code (C or JS) into |outputs|.
  #
  PROC write(UsedFile usedFile, SContext ctx, Output.Group outputs,
                                                                string indent)
    string inFileName = usedFile.zimbuFile.filename
    FileScope fileScope = usedFile.scope()
    int prevUndefined = fileScope.undefined

    string leader = indent .. inFileName
    LOG.info("\(leader): Generating \(ctx.gen.getLangName()) code...")

    fileScope.importIndent = indent

    outputs.startWriting()

    # Write all the code for imported files.
    generateImports(usedFile, ctx)

    # Writing is only needed when there is an item that is actually used.
    # Also write when the last pass had undefined symbols, report errors.
    IF !skipUnused() || usedFile.hasUsedItem(ctx.gen, indent)
                                                          || prevUndefined > 0
      # Separate the inits of imports and inits of this file.
      ctx.gen.afterImports(fileScope, outputs)

      # Write the body of this file.
      generate(fileScope, ctx)

      # Finish the inits of this file.
      ctx.gen.afterGenerate(usedFile, outputs, ctx)
    }

    LOG.info("\(leader): Done.")
  }

  #
  # The generation function handling imports only: Resolve symbols and
  # generate code when writing.
  # Returns the number of undefined symbols in the imports.
  #
  FUNC generateImports(UsedFile usedFile, SContext ctx) int
    # Process any builtin module imports.  Only for the top file scope.
    int undef
    IF usedFile.isTopFile
      undef = Builtin.generateBuiltins(usedFile, ctx)
    }

    # Go through the IMPORT statements of this scope.
    ZuiFile zf = usedFile.zimbuFile.zuiFile
    IF zf.contents.hasImport()
      FOR import IN zf.contents.getImportList()
        undef += generateImport(usedFile, import, ctx)
      }
    }

    RETURN undef
  }

  #
  # The main generation function: go through the parse tree, resolve symbols
  # and generate code when writing.
  # Returns the number of undefined symbols.
  #
  FUNC generate(Scope scope, TopScope topScope,
                                              Resolve gen, Output.Group outs
              ) int
    RETURN generate(scope.statements, NEW(topScope, scope, gen, outs))
  }

  FUNC generate(Scope scope, SContext ctx, Output.Group outs) int
    RETURN generate(scope.statements, NEW(ctx.topScope, scope, ctx.gen, outs))
  }

  FUNC generate(Scope scope, SContext ctx) int
    RETURN generate(scope.statements, ctx)
  }

  FUNC generate(list<Zui.Statement> statements, SContext ctx) int
    int undef = generateStatements(statements, ctx)

    IF statements != NIL && statements.Size() > 0
      # Write the generated virtual methods.
      ctx.gen.writeVirtual(ctx)
    }

    RETURN undef
  }

  # Inner part of generate().
  FUNC generateStatements(list<Zui.Statement> statements, SContext ctx) int
    # Go through the statements of this scope.
    int undef
    IF statements != NIL
      FOR i IN 0 UNTIL statements.Size()
        undef += generateOneStatement(
                    statements[i],
                    i + 1 < statements.Size() ? statements[i + 1] : NIL,
                    ctx)

        # Dereference intermediate expression results, if any.
        ctx.scope.writeAfterStmt(ctx.out)
      }
    }
    RETURN undef
  }

  # Handle one statement.  Return the number of undefined items.
  FUNC generateOneStatement(
                 Zui.Statement stmt, Zui.Statement nextStmt, SContext ctx) int
    int undef = -1
    VAR stmtExt = ZuiStatementExt.get(stmt)

    #
    # Handle statements that may appear at the toplevel.
    #
    SWITCH stmt.getType()
      CASE Zui.StatementType.eCBLOCK
        undef = generateCBlock(stmt, ctx)
      CASE Zui.StatementType.eMODULE_DECL
        undef = generateModule(stmt, ctx)
      CASE Zui.StatementType.eCLASS_DECL
        undef = generateClassWithTemplate(stmt, ctx)
      CASE Zui.StatementType.eBITS_DECL
        undef = generateBits(stmt, ctx)
      CASE Zui.StatementType.eENUM_DECL
        undef = generateEnum(stmt, ctx)
      CASE Zui.StatementType.eMETHOD_DECL
        undef = generateMethodWithTemplate(stmt, ctx)
      CASE Zui.StatementType.eVAR_DECL
        undef = generateDeclare(stmt, ctx)
      CASE Zui.StatementType.eALIAS_DECL
        undef = generateAlias(stmt, ctx)
      CASE Zui.StatementType.eTYPE_DECL
        undef = generateTypedef(stmt, ctx)
      CASE Zui.StatementType.eGENERATEIF
        undef = generateGenerateIf(stmt, ctx)
      CASE Zui.StatementType.eGENERATEERROR
        undef = generateGenerateError(stmt, ctx)
      CASE Zui.StatementType.eINCLUDE
        undef = generateInclude(stmt, ctx)
    }
    IF undef >= 0
      stmtExt.undefined = undef
      IF reportUndef && undef != 0
        ctx.error("generateOneStatement() "
                    .. stmt.getType().ToString() .. " undef: " .. undef, stmt)
      }
      RETURN undef
    }

    #
    # Handle statements that cannot appear at the toplevel.
    #
    IF !ctx.scope.hasStatements()
      ctx.error("Item not allowed here", stmt)
      RETURN 0
    }

    SWITCH stmt.getType()
      CASE Zui.StatementType.eBLOCK
        undef = generateCodeBlock(stmt.getBlock(), NIL,
                                                  ctx, Scope.Stype.block, NIL)
      CASE Zui.StatementType.eIF
      CASE Zui.StatementType.eIFNIL
        undef = generateIf(stmt, ctx)
      CASE Zui.StatementType.eTRY
        undef = generateTry(stmt, ctx)
      CASE Zui.StatementType.eTRYELSE
        undef = generateTryElse(stmt, ctx)
      CASE Zui.StatementType.eWHILE
        undef = generateWhile(stmt, ctx)
      CASE Zui.StatementType.eDO
        undef = generateDo(stmt, ctx)
      CASE Zui.StatementType.eUNTIL
        undef = generateUntil(stmt, ctx)
      CASE Zui.StatementType.eFOR
        undef = generateFor(stmt, ctx)
      CASE Zui.StatementType.eRETURN
      CASE Zui.StatementType.eEXIT
      CASE Zui.StatementType.eTHROW
        undef = generateReturnExitThrow(stmt, nextStmt, ctx)
      CASE Zui.StatementType.eDEFER
        undef = generateDefer(stmt, ctx)
      CASE Zui.StatementType.eBREAK
        undef = generateBreak(stmt, nextStmt, ctx)
      CASE Zui.StatementType.eCONTINUE
        undef = generateContinue(stmt, nextStmt, ctx)
      CASE Zui.StatementType.eSWITCH
        undef = generateSwitch(stmt, ctx)
      CASE Zui.StatementType.eCASE
      CASE Zui.StatementType.eDEFAULT
        undef = generateCase(stmt, nextStmt, ctx)
      CASE Zui.StatementType.eNEWCALL
        undef = generateNewCall(stmt, ctx)
      CASE Zui.StatementType.eCALL
        undef = generateCallStatement(stmt, ctx)
      CASE Zui.StatementType.eINC
      CASE Zui.StatementType.eDEC
        undef = generateIncDec(stmt, ctx)
      CASE Zui.StatementType.eASSIGN
        undef = generateAssign(stmt, ctx)
    }

    IF undef < 0
      ctx.error("INTERNAL: generate(): Statement type \""
                     .. stmt.getType().ToString() .. "\" not supported", stmt)
      undef = 0
    }
    stmtExt.undefined = undef
    IF reportUndef && undef != 0
      # For debugging: report information about where the undefined count came
      # from.  Only supports a few statement types that had problems in the
      # past.
      ctx.error("generateOneStatement() "
                .. stmt.getType().ToString() .. " end undef: " .. undef, stmt)
      IF stmt.getType() == Zui.StatementType.eASSIGN
        ZuiExpressionExt.reportUndefined("lhs", stmt.getAssign().getLhs())
        ZuiExpressionExt.reportUndefined("rhs", stmt.getAssign().getRhs())
      ELSEIF stmt.getType() == Zui.StatementType.eRETURN
        ZuiExpressionExt.reportUndefined("rhs", stmt.getArguments(0))
      ELSEIF stmt.getType() == Zui.StatementType.eCALL
        ZuiExpressionExt.reportUndefined("call", stmt.getMethodCall())
      }
    }
    RETURN undef
  }

  # A list of a >>> copy this %{ expression }% <<<
  FUNC generateCBlock(Zui.Statement stmt, SContext ctx) int
    int undef
    IF stmt.hasCblock()
      IF ctx.scope.hasStatements()
        ctx.gen.beforeStatement(stmt.getPos(), stmt.getBlockgc(), ctx)
      }
      FOR block IN stmt.getCblockList()
        ctx.out.write(block.getText())
        IF block.hasExpr()
          Zui.Expression expr = block.getExpr()
          VAR exprExt = ZuiExpressionExt.get(expr)
          IF block.getLiteral()
            SymUse symUse = NEW(expr.getPos(), ctx)
            exprExt.undefined = 0
            Declaration decl = ctx.scope.findExprDecl(expr, FALSE, TRUE, TRUE,
                                                                  ctx, symUse)
            undef += exprExt.undefined
            IF decl == NIL
              IF ctx.doError()
                ctx.error("Item not found", expr)
              }
            ELSE
              ctx.addUsedItem(decl)
              ctx.out.write(decl.pName)
            }
          ELSE
            genExpr(expr, ctx)
          }
          undef += exprExt.undefined
        }
        IF block.hasUses()
          # Handle the uses(foo) argument.
          Builtin.usesDeclarations(block.getUsesList(), stmt, ctx)
        }
      }
      IF ctx.scope.hasStatements()
        ctx.gen.afterStatement(stmt, ctx)
      }
    }
    RETURN undef
  }

  # Generate Main()
  FUNC generateMain(Zui.Declaration zuiDecl, SContext ctx) int
    Resolve gen = ctx.gen
    Scope scope = ctx.scope
    Zui.Type type = zuiDecl.getType()
    Zui.MethodType zuiMethod = type.getMethodDecl()
    VAR declExt = ZuiDeclarationExt.get(zuiDecl)

    IF scope.outer != NIL || scope.scopeName != NIL
      ctx.error("Main() not at toplevel", zuiDecl)
    }
    Zui.Expression expr
    IF type.getType() == Zui.TypeEnum.eFUNC
      expr = zuiMethod.getReturnType(0).getName()
      IF expr.getType() != Zui.ExprType.eID || expr.getId().getName() != "int"
        expr = NIL
      }
    }
    IF expr == NIL
      ctx.error("Main() must return int", zuiDecl)
    }
    IF zuiMethod.hasArgument()
      ctx.error("Main() must not have an argument", zuiDecl)
    }
    VAR zuiMethodExt = ZuiMethodTypeExt.get(zuiMethod)
    IF skip_zero_undefined && !ctx.gen.writing
        && zuiMethodExt.scope != NIL
        && !zuiMethodExt.scope.needPass && declExt.undefined == 0
      # No need to process this Main() again.
      RETURN 0
    }

    MethodScope mainScope
    MethodType method
    IF zuiMethodExt.scope == NIL
      # Create the scope for the main function and generate its body.
      mainScope = NEW(scope, zuiMethod.getBody().getStatementList())
      mainScope.name = "Main()"
      mainScope.returnType = Type.anInt
      mainScope.scopeName = "FMain"
      mainScope.scopeType = Scope.Stype.procDef
      mainScope.methodScope = mainScope
      zuiMethodExt.scope = mainScope

      # Add a MethodType declaration for use in markMainUsed().
      method = MethodType.NEW(Type.Enum.func, "Main")
      declExt.decl = method
      method.zuiDecl = zuiDecl
      method.type = declExt.decl
      method.returnType = Type.anInt
      method.scope = mainScope
      method.pName = "main"
      mainScope.outerDecl = declExt.decl
    ELSE
      mainScope = zuiMethodExt.scope
      mainScope.initPass(scope)
      mainScope.needPass = FALSE
      mainScope.returnType = Type.anInt
      method = declExt.decl
    }

    # Write main() and the start of Fmain().
    SContext mainCtx = NEW(ctx.topScope, mainScope, ctx.gen, ctx.outs)

    gen.mainHead(declExt.decl, mainCtx)

    # Adjust outputs to put variable declarations first, body statements
    # separately, to be appended after generate().  Set origBodyOut so that a
    # method or class defined inside Main() goes to the toplevel, not inside
    # the function.
    Output.Group newOuts = ctx.outs.startNewBlock()
    IF newOuts.origBodyOut == NIL
      newOuts.origBodyOut = ctx.outs.bodyOut
    }

    mainCtx.outs = newOuts
    mainCtx.out = newOuts.out

    gen.methodBodyStart(method, FALSE, FALSE, NIL, mainCtx)
    gen.mainMiddle(mainCtx)

    int undef = generate(mainScope.statements, mainCtx)
    declExt.undefined = undef
    newOuts.endNewBlock()

    IF mainScope.wantBacktrace
      scope.wantBacktrace = TRUE
    }

    gen.mainEnd(ctx)

    checkMethodHasReturn(zuiMethod, zuiDecl.getPos(), ctx)

    RETURN undef
  }

  # Generate a MODULE.
  FUNC generateModule(Zui.Statement stmt, SContext ctx) int
    Zui.Declaration zuiDecl = stmt.getDeclaration()
    Zui.Type zuiType = zuiDecl.getType()
    Zui.ModuleType module = zuiType.getModuleDecl()
    Output out = ctx.out             # normal generate output
    Scope scope = ctx.scope
    VAR declExt = ZuiDeclarationExt.get(zuiDecl)

    IF scope.scopeName != NIL && scope.scopeName[0] != 'M'
      ctx.error("MODULE can only be defined inside a MODULE", stmt)
    }
    ctx.checkDeclName(zuiDecl, "module")
    string name = zuiDecl.getName()

    # Declaration
    #  |- name  (name of the module)
    #  |- type == ModuleType  (specifies it's a module)
    #              |- scope == ModuleScope  (scope used during resolving)
    #                           |- declDict   (contains the module items)
    Declaration decl
    ModuleScope moduleScope
    IF declExt.decl == NIL
      # First time at this module, create the declaration with a ModuleType.
      # Store it in Zui.Declaration.decl for the next round.
      ModuleType type = NEW(Type.Enum.module, name)
      scope.addTypeDecl(type, zuiDecl, FALSE, ctx)
      decl = type
      declExt.decl = decl

      # Create the ModuleScope.
      moduleScope = NEW(scope, NIL)
      moduleScope.statements = module.getStatementList()
      type.scope = moduleScope
      IF scope.scopeType == Scope.Stype.libModule
                       && (name.endsWith("Module") || name.endsWith("module"))
        moduleScope.name = name.slice(0, -7)
        moduleScope.builtin = TRUE
      ELSE
        moduleScope.name = name
      }
      IF scope.scopeName == NIL
        moduleScope.scopeName = "M" .. name
      ELSE
        moduleScope.scopeName = scope.scopeName .. "__M" .. name
      }
      moduleScope.depth = 0
      moduleScope.returnType = NIL
      moduleScope.zuiAttr = zuiType.getAttr()
      moduleScope.outerDecl = decl

      decl.pName = moduleScope.scopeName
    ELSE
      # Second round and up: re-use the declaration created in the first round.
      decl = declExt.decl
      IF !scope.isForwardDeclare()
        # Not re-using the scope, need to define the module again
        scope.addMember(decl)
      }

      # Write the module type code when used.  Also when the module itself was
      # not marked as used (using ZWT module .Type() from non-ZWT code).
      IF decl.typeUsed
        ctx.gen.moduleType(decl, ctx)
      }

      moduleScope = decl.type.<ModuleType.C>.scope
      IF skip_zero_undefined && !ctx.gen.writing && !moduleScope.needPass
                                   && ZuiStatementExt.get(stmt).undefined == 0
        # No need to parse this module again.
        RETURN 0
      }
      moduleScope.initPass(scope)
      moduleScope.needPass = FALSE
    }

    decl.setVisibilityAttr(zuiDecl, ctx)

    # Only generate the module when resolving and when we actually need to
    # write the code for the target language.
    int undef
    IF ctx.gen.doGenerateModule(ctx)
      undef = generate(moduleScope, ctx, ctx.outs)
    }

    RETURN undef
  }

  # Generate a CLASS or INTERFACE.
  # For a templated CLASS |template| is not NIL and contains info about the
  # types used in the template.
  # Also used for PIECE.
  FUNC generateClass(Zui.Statement stmt, SContext ctx, Template template) int
    Output out = ctx.out             # normal generate output
    int undef
    Resolve gen = ctx.gen
    Scope scope = ctx.scope
    Zui.Declaration zuiDecl = stmt.getDeclaration()
    VAR stmtExt = ZuiStatementExt.get(stmt)
    Zui.Type zuiType = zuiDecl.getType()
    Zui.ClassType zuiClassType = zuiType.getClassDecl()
    VAR declExt = ZuiDeclarationExt.get(zuiDecl)

    bool isInterface = zuiClassType.getIsInterface()
    bool isPiece = zuiClassType.getIsPiece()
    # Allow any class name in the module that defines "I".
    # Specifically, the name is not required to start with "I_".
    IF scope.name != "I"
      checkTypeName(zuiDecl, isInterface ? "interface" : "class", ctx)
    }

    string className = zuiDecl.getName()
    Declaration classDecl
    ClassScope classScope
    ClassType classType
    IF declExt.decl == NIL
      # First round, add a class declaration.
      IF isInterface
        classType = NEW(Type.Enum.interface, className)
      ELSEIF isPiece
        classType = NEW(Type.Enum.piece, className)
      ELSE
        classType = NEW(Type.Enum.class, className)
      }
      classDecl = classType
      scope.addTypeDecl(classType, zuiDecl, FALSE, ctx)
      classType.zuiDecl = zuiDecl

      classScope = NEW(scope, zuiClassType.getMemberList())
      classType.scope = classScope
      classScope.name = className
      IF scope.scopeName == NIL
        classScope.scopeName = "C" .. className
      ELSE
        classScope.scopeName = scope.scopeName .. "__C" .. className
      }

      # Put the pName in the Declaration and in the Type.
      # TODO: can we put it in the Type only?
      classDecl.pName = WriteCommon.getUid(classScope.ToString())

      DeclStore.storePName(scope.scopeName ?: "", "C" .. className, classDecl)
      classDecl.setAttributes(zuiDecl, ctx)

      classScope.flags.insideShared = FALSE
      classScope.methodScope = NIL
      classScope.depth = 1
      classScope.returnType = NIL
      classScope.zuiAttr = zuiDecl.getType().getAttr()
      classScope.outerDecl = classDecl

      IF isInterface
        # An interface is always abstract.
        classDecl.zuiAttr.setAbstract(TRUE)
      }

      # Add the class to itself, to be able to compare an alias of the class
      # to.
      classScope.classType = classType

      stmtExt.undefined = 1  # always do another pass

      declExt.decl = classDecl
      stmtExt.typeObj = classType
    ELSE
      # Second round, re-use the symbol created in the first round.
      classDecl = declExt.decl
      IF !scope.isForwardDeclare()
        # Not re-using the scope, need to declare the class again
        scope.addMember(classDecl)
      }
      classType = classDecl.type
      classScope = classType.scope
      classScope.initPass(scope)
      # Don't use the class from scope but this one.
      classScope.classType = classType
    }

    # For a PIECE everything happens where it is included, nothing to be done
    # here.
    IF isPiece
      RETURN 0
    }

    # If this class is used the module or class that contains it must also be
    # marked as used.
    classDecl.addDependsOn(scope.outerDecl)

    IF skip_zero_undefined && !gen.writing
                             && !classScope.needPass && stmtExt.undefined == 0
      # No need to process this class again in this pass.
      RETURN 0
    }
    classScope.needPass = FALSE

    # Note: Even when the class is not marked as used we need to continue,
    # individual methods and members in the SHARED section may be marked as
    # used.
    bool classUsed = !skipUnused() || gen.isDeclUsed(classDecl)

    # THIS name depends on ctx.gen, set every pass.
    classScope.thisName = gen.thisName(FALSE)

    # For a templated class: Add the template types to the scope.
    # This is done every pass, in case a type is resolved.
    # Must come before EXTENDS and IMPLEMENTS, because interfaces there may
    # use the template types.
    classScope.template = template
    classScope.addTemplateTypes()

    # Context that includes the template types.
    SContext classCtx = NEW(ctx, classScope, ctx.outs)

    # EXTENDS
    bool needE_
    IF zuiClassType.hasExtends()
      Zui.Expression expr = zuiClassType.getExtends()
      VAR exprExt = ZuiExpressionExt.get(expr)
      exprExt.undefined = 0
      SymUse symUse = NEW(stmt.getPos(), classCtx)
      Declaration parentDecl = scope.findExprDecl(expr, FALSE, FALSE, TRUE,
                                                             classCtx, symUse)
      undef += exprExt.undefined
      IF ctx.doError()
        IF parentDecl == NIL
          symUse.doError = TRUE
          IF scope.findExprDecl(expr, FALSE, TRUE, TRUE,
                                                      classCtx, symUse) == NIL
            ctx.error("Class not found", expr)
          }
        ELSEIF !isInterface && parentDecl.type.getTtype() != Type.Enum.class
          ctx.error("Not a class", expr)
        ELSEIF isInterface && parentDecl.type.getTtype() != Type.Enum.interface
          ctx.error("Not an interface", expr)
        ELSEIF parentDecl.type.zuiAttr.getFinal()
          ctx.error("Cannot extend " .. parentDecl.name
                                              .. ": it is marked final", expr)
        }
      }
      IF parentDecl != NIL
        IF parentDecl.type.getClassType(ctx) != NIL
          # In case it's an alias.
          parentDecl = parentDecl.type.getClassType(ctx)
        }

        # Add ourselves as a child to the parent.
        parentDecl.type.<ClassType>.addChild(classType, ctx)

        # If the parent is marked @earlyInit the child is too.
        IF parentDecl.type.zuiAttr.getEarlyInit()
          classType.zuiAttr.setEarlyInit(TRUE)
        }

        # A class extending from E.Exception must start with E_, except when
        # it's in the "E" module.
        IF !classScope.scopeName.startsWith("MEModule__")
          Type etype = Builtin.getExceptionDotIType()
          IF etype.getTtype() != Type.Enum.unknown
                   && etype.getClassType(ctx).hasSubclass(
                                            parentDecl.type.getClassType(ctx))
            needE_ = TRUE
            IF !className.startsWith("E_")
              ctx.error("Exception class name must start with E_", stmt)
            }
          }
        }

        # Mark this class to depend on the parent class, but only when
        # abstractClass is marked as used, because it depends on the language.
        classDecl.addDependsOnCond(parentDecl, Declaration.abstractClass)
      ELSE
        # Use a dummy ClassType, so that we know there is a parent.
        parentDecl = Declaration.NEW("dummy parent")
        parentDecl.type = ClassType.NEW(Type.Enum.class, "dummy parent")
        parentDecl.type.pName = "dummy"  # needed for imt table name
        parentDecl.pName = "dummy"
        ++undef
      }

      classType.parent = parentDecl.type
    }

    IF ctx.doError() && !needE_ && className.startsWith("E_")
      ctx.error("Class name must not start with E_, unless it's an exception",
                                                                         stmt)
    }

    # IMPLEMENTS
    IF zuiClassType.hasImplements()
      undef += handleImplements(zuiClassType, classType, classCtx)
    }

    # Write the struct declaration to a separate output and append it to
    # ctx.outs.structOut when done.  This handles nested classes.
    Output structOut = NEW()
    structOut.writing = out.writing
    IF gen.writing
      SContext structCtx = ctx.copy(structOut)
      ClassType parent = classType.parent
      WHILE parent != NIL
        generateObjectMembers(parent, structCtx)
        parent = parent.parent
      }
    }

    IF !classType.isAbstract() && out.writing && classUsed
         # TODO: can we add this: && classType.type != Type.Enum.interface
      gen.writeClassDef(classType.pName,
          scope.scopeName == NIL ? className
                                        : scope.scopeName .. "." .. className,
          ctx.outs.typeOut)
    }

    # At the class level we only write members, these go to structOut.
    Output.Group newOuts = ctx.outs.copy()
    newOuts.out = structOut
    newOuts.varOut = structOut

    # If we extended a class redefine the methods from the parent in this
    # class scope.  That's because the type of the THIS pointer is different
    # and a method in the parent may call a method that is replaced in the
    # child.
    #
    # A method that was defined in the parent, or inherited from its parent
    # and not replaced, has the original method name.  This is used when
    # $method() is called in this class.
    # We also add this method with "__p1" added to the method name, to be used
    # for PARENT.method().
    # When encountering this in a child we increment the depth: "__p2", to be
    # called by PARENT.PARENT.method().
    # etc.
    #
    # When the function signature changes we need to remove the symbols and
    # add them again.  Thus when the name is "method" we find and remove
    # "method" and also remove "method__1" (they are exactly the same). When
    # the name is "method__1" we find and remove "method__2".
    #
    ClassType parent = classType.parent
    IF parent != NIL
        && parent.getObjectDeclDict() != NIL
        && !out.writing
      FOR l IN parent.getObjectDeclDict().values()
        FOR decl IN l
          Type m = decl.type
          IF (m.getTtype() == Type.Enum.builtinMethod
                 || m.getTtype() == Type.Enum.new
                 || m.getTtype() == Type.Enum.func
                 || m.getTtype() == Type.Enum.proc)
              && !decl.type.isAbstract()
              && m.defined
              && !isInitName(decl.name)  # Skip $Init().
              && !decl.hasLocalAttr()    # Skip methods with @local.
            string parentName  # name of method for PARENT.method()
            string findName    # name of symbol to possibly remove
            string sname = decl.name
            string baseName
            MethodType method = m.<MethodType>
            int endOriginalName = sname.find("__p")
            IF endOriginalName < 0
              parentName = sname .. "__p1"
              findName = sname
              baseName = sname
            ELSE
              baseName = sname.slice(0, endOriginalName - 1)
              parentName = baseName .. "__p" .. (method.parentLevel + 1)
              findName = parentName
            }

            # Find the method copied from the parent, it is only added once.
            # We can't find it with findMatchingMethod(), the function
            # signature may have changed, we have to go through the whole list
            # and check parentMethod.
            # Also check the end of pName, it may change when a child class is
            # found before its parent.  Below decl.pName is used for the copy,
            # it must match for PARENT.method() to work.
            VAR declDict = classType.getObjectDeclDict()
            Declaration oldDecl
            list<Declaration> allDecl
            IF declDict != NIL
              FOR valueList IN declDict.values()
                FOR prevDecl IN valueList
                  IF prevDecl.type ISA MethodType
                    MethodType mt = prevDecl.type.<MethodType>
                    IF mt.parentLevel == method.parentLevel + 1
                         && (mt.parentMethod IS decl.type
                                     || mt.parentMethod IS method.parentMethod)
                         && (prevDecl.name == sname
                                                || prevDecl.name == parentName)
                         && prevDecl.pName.endsWith(decl.pName)
                      oldDecl = prevDecl
                      IF allDecl == NIL
                        allDecl = NEW()
                      }
                      allDecl.add(prevDecl)
                    }
                  }
                }
              }
            }

            # Only add the methods from the parent when not done already.
            IF oldDecl == NIL
              # Create a Type Declaration that is a copy of the method.
              MethodType methodCopy = method.copyType()
              Declaration declCopy = methodCopy
              declCopy.clearDependencies()
              declCopy.name = parentName
              declCopy.scopeName = classScope.scopeName
              declCopy.zuiDecl = decl.zuiDecl
              declCopy.type = methodCopy
              methodCopy.parentLevel = method.parentLevel + 1
              # Remember where it came from: either the parent or its parent.
              IF method.parentLevel == 0 || method.parentMethod == NIL
                methodCopy.parentMethod = method
              ELSE
                methodCopy.parentMethod = method.parentMethod
              }
              declCopy.scopeBase = classScope

              IF method.getTtype() != Type.Enum.builtinMethod
                # Need to use a different name, will write the func below.
                declCopy.pName = classType.pName .. "__" .. decl.pName
              ELSE
                declCopy.pName = decl.pName
                # We only generate the method once, thus if one is used the
                # other one must also be marked as used.
                declCopy.addDependsOn(decl)
                decl.addDependsOn(declCopy)
              }
              declCopy.jsMName = decl.jsMName
              declCopy.jsFName = decl.jsFName

              # A Finish method is always used if the class is used.
              IF baseName == "Finish"
                addFinishDependencies(declCopy, classType)
              }

              # Add the method with "__p1", "__p2", etc.  To be used by
              # PARENT.method, PARENT.PARENT.method, etc.
              # Do this for methods defined in the parent class
              # (method.parentLevel == 0) and the ones inherited in the parent
              # class from a grantparent (endOriginalName > 0).
              bool usedDeclCopy
              IF method.parentLevel == 0 || endOriginalName > 0
                usedDeclCopy = TRUE
                classType.addObjectMember(declCopy)
                undef += ZuiDeclarationExt.get(declCopy.zuiDecl).undefined
                declCopy.addDependsOn(classDecl)

                # Find the method with the original name.  If it already
                # exists (can be earlier in the dict) make it depend on the
                # copy.
                Declaration baseDecl = classType.findMatchingMethod(
                                             baseName, TRUE, method.arguments,
                                                NIL, onlyDefined + methodArgs,
                                                &undef, ctx)
                IF baseDecl != NIL
                  # If we did add a method the original method depends on it.
                  baseDecl.addDependsOn(declCopy)
                }

                # There might already be a method with the original name,
                # without __1, with the same pName.  If it gets used the __1
                # method must be produced, since the one with the original
                # name won't be.
                FOR dl IN classType.scope.objectMembers.values()
                  FOR d IN dl
                    IF d.pName == declCopy.pName
                      d.addDependsOn(declCopy)
                    }
                  }
                }
              }

              # Try to find a method in this class with the same signature.
              # If it exists it will be used, if not then we add a
              # declaration for the method inherited from the parent.
              Declaration fdecl = classType.findMatchingMethod(findName,
                                                  TRUE, method.arguments, NIL,
                                                  onlyDefined + methodArgs,
                                                  &undef, ctx)
              Type ftype = fdecl?.type
              IF ftype != NIL && !ftype.defined
                # Ignore this match, something is still undefined.
                fdecl = NIL
                ftype = NIL
              }
              IF ftype != NIL && ftype.<MethodType>.parentLevel > 0
                  && (method.getTtype() == Type.Enum.builtinMethod
                                                || decl.getClassName() == NIL)
                # For JavaScript: Use the generated method from the parent,
                # set the jsName to that.
                fdecl.jsFName = decl.jsFName
              }

              IF (ftype == NIL
                       || ftype.<MethodType>.parentLevel > method.parentLevel)
                   && endOriginalName < 0
                # Add the method with the original name, a copy from the
                # parent method with the original name.
                # This is removed when a method with the same signature is
                # defined in the current class or when this happens in the
                # parent class.
                Declaration origDecl
                IF usedDeclCopy
                  origDecl = declCopy.type.copyType()
                  # Add a reference to the other copy, which will be produced.
                  # This one won't be produced.
                  origDecl.<MethodType>.producedMethod = declCopy.type
                ELSE
                  origDecl = declCopy
                }
                origDecl.clearDependencies()
                origDecl.name = decl.name
                origDecl.scopeName = classScope.scopeName
                origDecl.type = origDecl
                origDecl.zuiDecl = decl.zuiDecl
                origDecl.scopeBase = classScope
                origDecl.pName = declCopy.pName
                origDecl.jsMName = decl.jsMName
                origDecl.jsFName = decl.jsFName

                classType.addObjectMember(origDecl)

                # Remember that we added a copy of the method in this class.
                # It needs to be removed if the method is replaced.
                IF method.childMethodClasses == NIL
                  method.childMethodClasses = NEW()
                }
                method.childMethodClasses.add(classType)

                # For a language that supports classes we will generate the
                # method in the parent.  This is indicated by
                # Declaration.inheritMethod being marked as used.
                origDecl.addDependsOnCond(decl, Declaration.inheritMethod)

                # We only generate the method once, thus if it is used others
                # with the same pName must also be marked as used.
                FOR dl IN classType.scope.objectMembers.values()
                  FOR d IN dl
                    IF d.pName == origDecl.pName
                      origDecl.addDependsOn(d)
                    }
                  }
                }

                undef += ZuiDeclarationExt.get(origDecl.zuiDecl).undefined
                origDecl.addDependsOn(classDecl)
              }
            ELSE
              # The method was already added, but the argument and return
              # types may have changed, update them.
              FOR aDecl IN allDecl
                MethodType aType = aDecl.type.<MethodType>
                IF aType.parentLevel > 0
                  aType.arguments = method.arguments
                  aType.useArguments = method.useArguments
                  aType.returnType = method.returnType
                }
              }
            }
          }
        }
      }
    }

    newOuts.origDeclOutWriting = newOuts.declOut.writing
    newOuts.origBodyOutWriting = newOuts.bodyOut.writing

    # Methods of an abstract class are never used in C.
    # But do give errors when we detected a problem in a previous pass.
    IF classType.isAbstract() && gen.skipAbstractMethod()
                                                     && stmtExt.undefined == 0
      newOuts.declOut.writing = FALSE
      newOuts.bodyOut.writing = FALSE
    }

    # Generate the class body.
    undef += generate(classScope, ctx, newOuts)

    # Generate the SHARED section.
    IF zuiClassType.hasShared()
      undef += generateShared(zuiClassType.getShared(),
                              zuiClassType.getSharedAttr(),
                              NEW(ctx.topScope, classScope, ctx.gen, newOuts))
    }

    VAR objectDeclDict = classType.getObjectDeclDict()

    # Add an $Init() function, if it doesn't exist yet.
    IF !isInterface && (objectDeclDict == NIL || !objectDeclDict.has("Init"))
      MethodType initDecl = NEW(Type.Enum.proc, "Init")
      initDecl.arguments = NEW()
      initDecl.pName = WriteCommon.getUid(classScope.ToString())
      initDecl.jsMName = "Init"
      initDecl.jsFName = initDecl.pName
      initDecl.fake = TRUE
      initDecl.scopeBase = classScope
      classType.addObjectMember(initDecl)
      objectDeclDict = classType.getObjectDeclDict()

      Zui.MethodType method = NEW()
      initDecl.zuiDecl = NEW()
      initDecl.zuiDecl.setPos(zuiDecl.getPos())
      initDecl.zuiDecl.setName("Init")
      initDecl.zuiDecl.setDollar(TRUE)
      initDecl.zuiDecl.newType()
            .setType(Zui.TypeEnum.ePROC)
            .setMethodDecl(method)
            .setAttr(NEW())
      classType.initDecl = initDecl
    }

    IF classType.initDecl != NIL
      # Set or reset the default $Init() defined flag.
      Declaration usefulDecl = findUsefulInit(classScope)
      IF usefulDecl != NIL && !usefulDecl.fake
        # Reset the flag if there is a real $Init().
        classType.initDecl.defined = FALSE
      ELSEIF classType.hasMemberInits()
        # Set the flag if there are inits for object members.
        classType.initDecl.defined = TRUE
      ELSEIF !classType.initDecl.defined
        # Set the flag when a parent class has a non-default $Init().
        ClassType p = classType.parent
        WHILE p != NIL
          IF findUsefulInit(p.scope) != NIL
            classType.initDecl.defined = TRUE
            BREAK
          }
          p = p.parent
        }
      }
    }

    # Generate methods inherited from parents.  These have a name that ends in
    # "__p1", "__p2", etc.
    # We do not generate a method inherited from a parent that is declared
    # with the original name, as there will always be a "__p1" method with the
    # same pName.
    IF objectDeclDict != NIL
      FOR l IN objectDeclDict.values()
        FOR decl IN l
          Type t = decl.type
          IF (t.getTtype() == Type.Enum.func || t.getTtype() == Type.Enum.new
                                            || t.getTtype() == Type.Enum.proc)
                 && decl.name.find("__p") > 0
            # Write a copy of the method from the parent in the context of this
            # class.  Only needed for C, when resolving and for NEW in JS.
            IF gen.doWriteParentMethod(decl)
              undef += generateParentMethod(classType,
                                          decl, NEW(ctx, classScope, newOuts))
            }
          }
        }
      }
    }

    newOuts.declOut.writing = newOuts.origDeclOutWriting
    newOuts.bodyOut.writing = newOuts.origBodyOutWriting

    IF !(gen.skipAbstractMethod() && classType.isAbstract())
      # Generate default Init methods.
      IF objectDeclDict != NIL
        FOR l IN objectDeclDict.values()
          FOR decl IN l
            Type t = decl.type
            IF t.getTtype() == Type.Enum.proc
                      && decl.name == "Init" && decl.fake && decl.type.defined
              # Generate default $Init() method.
              generateMethod(decl.zuiDecl, NEW(ctx, classScope, newOuts),
                                                             FALSE, NIL, decl)
              undef += ZuiDeclarationExt.get(decl.zuiDecl).undefined
            }
          }
        }
      }
    }

    # For C only write the declaration for a non-abstract class.
    # For JS we do, the language takes care of inheritance for us.
    bool writeClassDecl = !(gen.skipAbstractMethod() && classType.isAbstract())
                             && classType.getTtype() != Type.Enum.interface
                             && classUsed

    IF writeClassDecl
      gen.writeClassDecl(classType, ctx.outs, structOut, ctx)
    }

    # Check that a non-abstract class doesn't have any abstract method.
    IF !classType.isAbstract()
      FOR l IN objectDeclDict?.values()
        FOR decl IN l
          IF decl.type.isAbstract()
            ctx.error("non-abstract class cannot have an abstract method: "
                                                         .. decl.name, stmt)
            IF decl.zuiDecl != NIL
              ctx.error("location of the abstract method", decl.zuiDecl)
            }
          }
        }
      }

      # Check that all abstract methods of the parent have been implemented.
      # Check that no members of the parent are overruled.
      IF parent != NIL
          && parent.getObjectDeclDict() != NIL
          && ctx.doError()
        FOR l IN parent.getObjectDeclDict().values()
          FOR decl IN l
            IF (decl.type.getTtype() == Type.Enum.builtinMethod
                   || decl.type.getTtype() == Type.Enum.new
                   || decl.type.getTtype() == Type.Enum.func
                   || decl.type.getTtype() == Type.Enum.proc)
              IF decl.type.isAbstract()
                string otherName  # name of method for PARENT.method()
                string findName   # name of symbol to possibly remove
                string sname = decl.name
                int endOriginalName = sname.find("__p")
                IF endOriginalName < 0
                  otherName = sname .. "__p1"
                  findName = sname
                ELSE
                  otherName = sname.slice(0, endOriginalName + 2)
                                     .. (decl.type.<MethodType>.parentLevel + 1)
                  findName = otherName
                }
                Declaration f = classType.findMatchingMethod(findName, TRUE,
                                  decl.type.getArgList(), NIL, methodArgs,
                                  &undef, ctx)
                IF f == NIL
                  ctx.error("Missing implementation for abstract method: "
                                                                 .. sname, stmt)
                  IF decl.zuiDecl != NIL
                    ctx.error("location of the abstract method", decl.zuiDecl)
                  }
                }
              }
            ELSEIF objectDeclDict != NIL && objectDeclDict.has(decl.name)
              ctx.error("Already defined in parent: " .. decl.name,
                                      objectDeclDict.get(decl.name)[0].zuiPos)
              ctx.error("Location in parent", decl.zuiPos)
            }
          }
        }
      }
    }

    # Keep track of what _imt table has been produced.  Do this again in every
    # pass.
    set<string> imtDone = NEW()

    # Check that all interfaces have been implemented.  Only give errors when
    # writing, function signatures may change until then.
    FOR idecl IN classType.interfaces
      VAR declDict = idecl.type.getObjectDeclDict()
      IF declDict != NIL
        string iname = idecl.getInterfaceName(ctx)
        FOR l IN declDict.values()
          FOR decl IN l
            Type member = decl.type
            string memberName = decl.name
            IF decl.getClassName() == NIL
              ctx.error("INTERNAL: object member without className: "
                                             .. member.typeToString(), stmt)
              CONTINUE
            }

            # Check methods and members without @local.
            IF !decl.hasLocalAttr()
              IF member.getTtype() == Type.Enum.func
                               || member.getTtype() == Type.Enum.proc
                               || member.getTtype() == Type.Enum.builtinMethod
                list<Declaration.C> argList = member.getArgList()
                Declaration fdecl = classType.findMatchingMethod(memberName,
                                          TRUE, argList, NIL, methodArgs,
                                          &undef, ctx)
                Type ftype = fdecl?.type
                IF ftype == NIL
                  IF ctx.doError()
                    ctx.error("Missing implementation for "
                      .. memberName .. MethodType.argTypesAsString(argList),
                                                                       stmt)
                    ctx.error(".. needed for interface " .. idecl.name,
                                                              idecl.zuiDecl)
                  }
                ELSEIF member.getTtype() == Type.Enum.func
                  IF ftype.getTtype() == Type.Enum.proc
                    IF ctx.doError()
                      ctx.error(memberName .. " should be a FUNC ..",
                                                              fdecl.zuiDecl)
                      ctx.error(".. for implementing the interface "
                                                    .. iname, idecl.zuiDecl)
                    }
                  ELSEIF !Type.matchingTypes(member.<MethodType>.returnType,
                                             ftype.<MethodType>.returnType,
                                             ctx)
                    IF ctx.doError()
                      ctx.error(memberName .. " returns a wrong type",
                                                              fdecl.zuiDecl)
                      ctx.error(".. for implementing the interface "
                                                    .. iname, idecl.zuiDecl)
                    }
                  }
                ELSEIF member.getTtype() == Type.Enum.proc
                                         && ftype.getTtype() == Type.Enum.func
                  IF ctx.doError()
                    ctx.error(memberName .. " should be a PROC ..",
                                                              fdecl.zuiDecl)
                    ctx.error(".. for implementing the interface " .. iname,
                                                              idecl.zuiDecl)
                  }
                ELSE
                  # When the member of the interface is used, the member of
                  # the implementing class is used, under the condition that
                  # the class is used.
                  decl.addDependsOnCond(fdecl, classDecl)
                }
              ELSE
                Declaration mdecl = classType.findObjectMember(
                       memberName, NEW(idecl.zuiDecl.getPos(), ctx), 0, FALSE)
                IF mdecl == NIL
                  IF ctx.doError()
                    ctx.error("Missing implementation for " .. memberName,
                                                              idecl.zuiDecl)
                  }
                ELSE
                  # When the member of the interface is used, the member of
                  # the implementing class is used, under the condition that
                  # the class is used.
                  decl.addDependsOnCond(mdecl, classDecl)
                }
              }
            }
          }
        }

        # Check for duplicates.
        IF imtDone.has(iname)
          ctx.error("Duplicate interface: " .. iname, idecl.zuiDecl)
        ELSE
          imtDone.add(iname)
        }

        # For each interface generate the interface member lookup table,
        # when needed.
        gen.interfaceMemberTable(classDecl, idecl, ctx)
      }
    }

    IF gen.writing
      IF classUsed
        # Write Interface Method tables, when needed.
        gen.writeIMTTables(classDecl, imtDone, ctx)

        # Write the object declaration table.
        IF writeClassDecl
          gen.writeToTable(classDecl, ctx)
        }
        gen.writeIMTend(ctx)
      }
    ELSE
      # Just mark ToString() as used.
      # TODO: Not always?
      gen.writeToTable(classDecl, ctx)
    }

    # This is used by child classes.
    declExt.undefined = undef

    RETURN undef
  }

  # Generate for a class with or without a template.
  # Returns the number of undefined symbols.  With a template this is always
  # more than one, because we don't know what other uses of the template there
  # are.
  FUNC generateClassWithTemplate(Zui.Statement stmt, SContext ctx) int
    Zui.Declaration zuiDecl = stmt.getDeclaration()

    Zui.ClassType class = zuiDecl.getType().getClassDecl()
    IF !class.hasTemplateTypeName()
      # No template, the easy way.
      RETURN generateClass(stmt, ctx, NIL)
    }

    # Class with a template: generate the class for each used set of
    # types.  If the class was never used (so far) this only puts the
    # class in the scope without generating any code.

    # Add the class to the scope, so that it can be used with different types.
    Scope scope = ctx.scope
    ClassType classType
    VAR stmtExt = ZuiStatementExt.get(stmt)
    IF stmtExt.typeObj == NIL
      # First round, add a class symbol.
      string name = zuiDecl.getName()
      IF class.getIsInterface()
        classType = NEW(Type.Enum.interface, name)
      ELSE
        classType = NEW(Type.Enum.class, name)
      }

      VAR names = getTemplateTypeNames(class.getTemplateTypeNameList(), ctx)
      IF names == NIL
        RETURN 99  # error in names
      }
      classType.templateNames = names

      scope.addTypeDecl(classType, zuiDecl, FALSE, ctx)
      classType.templateList = NEW()
      stmtExt.typeObj = classType

      # The scope is only used to set needPass when the template is used.
      classType.scope = NEW(scope, [])
    ELSE
      # Second round, re-use the symbol created in the first round.
      classType = stmtExt.typeObj
      IF !scope.isForwardDeclare()
        # Not re-using the scope, need to define the class again
        scope.addMember(classType)
      }
    }

    int undef

    # Generate the class for each combination of types in the template.
    FOR template IN classType.templateList
      IF template.stmt == NIL
        # Make a recursive copy of the statement, so that typeObj in each
        # branch can be used.
        string name = zuiDecl.getName() .. "__t" .. template.name

        template.stmt = stmt.copy(TRUE)
        template.stmt.getDeclaration().setName(name)
        template.templateClass = classType
      }

      string extraSave = LOG.setExtraLead(
                          "in \(zuiDecl.getName())\(template.typeString()): ")
      undef += generateClass(template.stmt, ctx, template)
      LOG.setExtraLead(extraSave)

      # When any of the templates is used this class is used.
      Declaration decl = ZuiDeclarationExt.get(
                                          template.stmt.getDeclaration()).decl
      IF decl != NIL
        decl.addDependsOn(classType)
      }
    }

    # When this class is used then the containing decl is also used.
    classType.addDependsOn(scope.outerDecl)

    RETURN undef
  }

  # Check the names used for types in a template for a class or method.
  FUNC getTemplateTypeNames(list<Zui.Id> ids, SContext ctx) list<string>
    list<string> names = NEW()
    FOR id IN ids
      IF id.getName()[0] != 'T'
        ctx.error("name for a type must start with T", id.getPos())
        RETURN NIL
      }
      names.add(id.getName())
    }
    RETURN names
  }

  # Check the names used for types in a template for a class or method.
  # Return a list with the names, NIL if there is an error.
  FUNC getTemplateTypeNames(list<Zui.Type> types, SContext ctx) list<string>
    list<string> names = NEW()
    FOR type IN types
      Zui.Expression expr = type.getName()
      IF expr.getType() != Zui.ExprType.eID
        ctx.error("Expected a name for a type", type)
        RETURN NIL
      }
      string name = expr.getId().getName()
      IF name[0] != 'T'
        ctx.error("name for a type must start with T", type)
        RETURN NIL
      }
      names.add(name)
    }
    RETURN names
  }

  # Return the C name for method |method| from a parent class |level| levels
  # up in the context of |class|.
  FUNC parentMethodName(ClassType class, int level, Type method,
                                                          SContext ctx) string
    ClassType parent = class
    string x = ""
    int i
    WHILE parent != NIL
      x ..= parent.pName .. "__"
      parent = parent.<ClassType>.parent
      ++i
      IF i >= level && parent != NIL
        # Check that the method is actually in this class.  It's possible that
        # for PARENT.func() we actually find func() in a parent higher up,
        # equal to using PARENT.PARENT.func()
        bool found
        VAR declDict = parent.getObjectDeclDict()
        FOR l IN declDict?.values()
          FOR decl IN l
            IF decl.type IS method
              found = TRUE
            }
          }
        }
        IF found
          BREAK
        }
      }
    }

    ctx.addUsedItem(method)

    RETURN x .. method.pName
  }

  # Mark method copied from parent with pName |pName| in |class| as used.
  PROC markParentMethodUsed(ClassType class, string pName, SContext ctx)
    IF class.getObjectDeclDict() != NIL
      FOR l IN class.getObjectDeclDict().values()
        FOR decl IN l
          IF decl.pName == pName
            ctx.addUsedItem(decl)
          }
        }
      }
    }
  }

  # Return 1 for PARENT, 2 for PARENT.PARENT, etc.
  # Assumes validity is checked elsewhere.
  FUNC parentDepth(Zui.Expression expr) int
    int depth = 1
    Zui.Expression e = expr
    WHILE e.getType() == Zui.ExprType.eMEMBER && e.getLeft() != NIL
      ++depth
      e = e.getLeft()
    }
    RETURN depth
  }

  # Generate a method for a class that was defined in a parent class.
  # This is necessary for THIS to have the right type.
  # |parentMethod| is the method in the parent.
  # |curMethod| is the equivalent method in the current class.
  # Returns number of undefined symbols.
  FUNC generateParentMethod(Type classType, Declaration decl, SContext ctx
                           ) int
    MethodType curMethod = decl.type
    MethodType parentMethod = curMethod.parentMethod
    Declaration parentDecl = parentMethod
    int level = curMethod.parentLevel

    IF curMethod.copyDecl == NIL
      # First time here, make a recursive copy of the parent method
      # declaration.
      curMethod.copyDecl = parentDecl.zuiDecl.copy(TRUE)
      IF level > 0
        string name = parentDecl.zuiDecl.getName() .. "__p" .. level
        curMethod.copyDecl.setName(name)
        ZuiDeclarationExt.get(curMethod.copyDecl).parentLevel = level
      }
    }
    decl.zuiDecl = curMethod.copyDecl  # setDeclUsed() looks in zuiDecl.

    ClassScope scope = ctx.scope

    # Annotate the method.  This wasn't done from the file level, since this
    # is a copy of a method.
    IF ctx.out.writing
      Annotator.getProps(curMethod.copyDecl.getType().getMethodDecl(), ctx)
    }

    # Set the parent level, so that PARENT.method() looks in the right class.
    int origLevel = classType.<ClassType>.parentLevel
    classType.<ClassType>.parentLevel = origLevel + level

    # Set the outer scope to that of the parent class, where the method was
    # defined.  We must not use the outer scope of the subclass (thisone).
    Scope origOuter = scope.outer
    Type parent = classType
    FOR i IN 1 TO level
      parent = parent.<ClassType>.parent
    }
    scope.outer = parent.scopeBase

    bool origIsParentMethod = scope.flags.isParentMethod
    scope.flags.isParentMethod = TRUE

    VAR origDeclDict = scope.declDict
    scope.declDict = classType.<ClassType>.scope.declDict

    # Generate the method, re-using the existing declaration.
    generateMethod(curMethod.copyDecl, ctx, FALSE, NIL, decl)

    scope.outer = origOuter
    classType.<ClassType>.scope.declDict = scope.declDict
    scope.declDict = origDeclDict
    scope.flags.isParentMethod = origIsParentMethod
    classType.<ClassType>.parentLevel = origLevel

    RETURN ZuiDeclarationExt.get(curMethod.copyDecl).undefined
  }

  # Write the declaration of member variables of |type|
  PROC generateObjectMembers(ClassType type, SContext ctx)
    VAR declDict = type.getObjectDeclDict()
    IF declDict != NIL
      FOR l IN declDict.values()
        FOR d IN l
          IF d.type.isVariableType()
               && !d.hasLocalAttr()
               && (!skipUnused() || ctx.gen.isDeclUsed(d))
            ctx.out.writeIndent(ctx.scope.depth)
            ctx.gen.vardecl(d, ctx)
            ctx.gen.statementLineEnd(ctx.out)
          }
        }
      }
    }
  }

  # Generate the SHARED section of a CLASS.
  FUNC generateShared(Zui.CodeBlock block, Zui.Attributes zuiAttr,
                                                             SContext ctx) int
    
    VAR blockExt = ZuiCodeBlockExt.get(block)
    Output out = ctx.out             # normal generate output
    int undef
    ClassScope classScope = ctx.scope

    IF skip_zero_undefined && !ctx.gen.writing
        && blockExt.scope != NIL
        && !blockExt.scope.needPass && blockExt.undefined == 0
      # No need to process this SHARED section again.
      RETURN 0
    }

    SharedScope sharedScope = blockExt.scope
    IF sharedScope == NIL
      sharedScope = NEW(classScope, block.getStatementList())
      blockExt.scope = sharedScope

      sharedScope.flags.insideShared = TRUE
      sharedScope.scopeType = Scope.Stype.shared
      sharedScope.depth = 0
      sharedScope.scopeName = classScope.scopeName .. "__X"

      # Declarations are added to the declarations dict of the class, so that
      # the symbols defined here are available in the whole class.
      # Make sure the dict exists, needed to get the reference to it.
      IF classScope.declDict == NIL
        classScope.declDict = NEW()
      }
      sharedScope.declDict = classScope.declDict

      # Use the @items= attribute from the class, unless overruled.
      # TODO: each SHARED block can have its own attributes
      sharedScope.zuiAttr = zuiAttr
      IF !sharedScope.zuiAttr.hasItemsVisibility()
        IF classScope.zuiAttr.hasItemsVisibility()
          sharedScope.zuiAttr.setItemsVisibility(
                                      classScope.zuiAttr.getItemsVisibility())
        }
      }
      sharedScope.outerDecl = classScope.outerDecl
    ELSE
      sharedScope.initPass(classScope)
      sharedScope.needPass = FALSE
    }

    IF block.hasStatement()
      # Go through the statements of this scope.  Clear the ".class" field
      # since we are no longer inside the class itself.
      Output.Group newOuts = ctx.outs.copy()
      newOuts.out = newOuts.declOut    # don't write to structOut
      newOuts.varOut = newOuts.declOut
      SContext newCtx = NEW(ctx, sharedScope, newOuts)

      undef += generateStatements(block.getStatementList(), newCtx)
    }

    # Not calling ctx.addUsedScope(sharedScope), because the class itself does
    # not need to be defined for the members to be defined.

    blockExt.undefined = undef
    RETURN undef
  }

  # Generate a BITS.
  FUNC generateBits(Zui.Statement stmt, SContext ctx) int
    Output out = ctx.out             # normal generate output
    int undef
    Zui.Declaration zuiDecl = stmt.getDeclaration()
    Zui.Type zuiType = zuiDecl.getType()
    Zui.BitsType zuiBitsType = zuiType.getBitsDecl()
    VAR declExt = ZuiDeclarationExt.get(zuiDecl)

    Resolve gen = ctx.gen
    Scope scope = ctx.scope

    checkTypeName(zuiDecl, "bits", ctx)
    string name = zuiDecl.getName()
    Declaration decl
    IF declExt.decl == NIL
      decl = BitsType.NEW(Type.Enum.int32, name)
      scope.addTypeDecl(decl, zuiDecl, FALSE, ctx)
      ZuiStatementExt.get(stmt).typeObj = decl.type
      declExt.decl = decl
      IF scope.scopeName == NIL
        decl.pName = "B" .. name
      ELSE
        decl.pName = scope.scopeName .. "__B" .. name
      }
    ELSE
      decl = declExt.decl
      IF !scope.isForwardDeclare()
        # Not re-using the scope, need to define the bits again
        scope.addMember(decl)
      }
    }
    BitsType type = decl.type.<BitsType>

    # Re-parse the fields every time, some may have had undefined types
    # previously.
    SymUse symUse = NEW(stmt.getPos(), ctx)
    int bitsUsed
    FOR memberStmt IN zuiBitsType.getMemberList()
      SWITCH memberStmt.getType()
        CASE Zui.StatementType.eMETHOD_DECL
          # TODO
          ctx.error("Method in BITS declaration not supported yet", memberStmt)

        CASE Zui.StatementType.eVAR_DECL
          Zui.Declaration memberDecl = memberStmt.getDeclaration()
          Zui.Type zuiMemberType = memberDecl.getType()
          Zui.Expression expr = zuiMemberType.getName()
          int    bits
          Type memberType
          string typeName = expr.getType() == Zui.ExprType.eID
                                                 ? expr.getId().getName() : ""
          IF typeName == "bool"
            # bool $name
            memberType = Type.aBool
            bits = 1
          ELSEIF typeName.slice(0, 2) == "int"
                 || typeName.slice(0, 2) == "nat"
            # int5 $name
            # nat3 $name
            IF typeName[0] == 'i'
              memberType = Type.anInt
            ELSE
              memberType = Type.aNat
            }
            string number = typeName.slice(3)
            IF number == "" || !number[0].isDigit()
              ctx.error("Expected a number after " .. typeName.slice(0, 2),
                                                                         expr)
            ELSE
              bits = number.toInt()
              IF bits > 32
                ctx.error("Cannot have more than 32 bits", expr)
              }
            }
          ELSE
            # MyEnum $name
            VAR exprExt = ZuiExpressionExt.get(expr)
            exprExt.undefined = 0
            Declaration typeDecl = scope.findExprDecl(expr, ctx, symUse)
            undef += exprExt.undefined
            IF typeDecl == NIL
              undef += 2
              IF ctx.doError()
                symUse.doError = TRUE
                IF scope.findExprDecl(expr, ctx, symUse) == NIL
                  ctx.error("Type not found", expr)
                }
              }
            ELSEIF typeDecl.type.getTtype() != Type.Enum.enum
              undef++
              IF ctx.doError()
                ctx.error("Type not supported in BITS", expr)
              }
            ELSE
              bits = 1
              # TODO: need log2()
              EnumType et = typeDecl.type.<EnumType>
              int size = et.members == NIL ? 0 : et.members.Size()
              WHILE size > 2
                size = size >> 1
                bits++
              }
            }
            memberType = typeDecl?.type
          }
          IF bits > 0
            string memberName = memberDecl.getName()
            Declaration.C oldMember = type.findMember(memberName, NIL)

            IF oldMember != NIL && oldMember.zuiDecl ISNOT memberDecl
              ctx.error("Duplicate member: " .. memberName, memberStmt)
            ELSEIF !memberDecl.hasDollar()
              ctx.error("Missing $ before " .. memberName, memberStmt)
            ELSE
              Declaration.C member = oldMember
              IF member == NIL
                member = NEW(memberName)
              }
              # TODO: don't copy the type, use a BitsMemberType.  Or set the
              # shift and mask on the Declaration.
              # TODO: Keep the existing type if it is the same.
              IF memberType ISA EnumType
                member.type = EnumValueType.NEW(Type.Enum.enumValue, memberName)
                member.type.<EnumValueType>.enumType = memberType
              ELSE
                member.type = memberType.copyType()
                # The copy depends on the original object and vise versa, if
                # one is used the other must also be marked as used.
                member.type.addDependsOn(memberType)
                memberType.addDependsOn(member.type)
              }
              member.zuiDecl = memberDecl
              IF oldMember == NIL
                type.addMember(member)
              }

              ValueType vt = member.type
              vt.shift = bitsUsed
              vt.mask = (1 << bits) - 1
            }
            bitsUsed += bits
          }

        DEFAULT
          ctx.error("Syntax error in BITS declaration", memberStmt)
      }
    }
    IF bitsUsed > Config.intSize
      type.valueType = Type.Enum.int
    }

    bool didSetWritingFlags
    IF !ctx.outs.bodyOut.writing && !ctx.outs.declOut.writing
      IF ctx.outs.origBodyOutWriting && ctx.outs.origDeclOutWriting
        # Inside an abstract class.  Although members are not produced, bits
        # are.
        didSetWritingFlags = TRUE
        ctx.outs.declOut.writing = TRUE
        ctx.outs.bodyOut.writing = TRUE
      }
    }

    ctx.gen.bits(zuiDecl, decl, ctx)

    IF didSetWritingFlags
      ctx.outs.declOut.writing = FALSE
      ctx.outs.bodyOut.writing = FALSE
    }

    RETURN undef
  }

  # Generate an ENUM declaration.
  FUNC generateEnum(Zui.Statement stmt, SContext ctx) int
    Scope scope = ctx.scope
    Zui.Declaration zuiDecl = stmt.getDeclaration()
    VAR declExt = ZuiDeclarationExt.get(zuiDecl)

    checkTypeName(zuiDecl, "enum", ctx)
    string name = zuiDecl.getName()
    Declaration decl
    IF declExt.decl == NIL
      decl = EnumType.NEW(Type.Enum.enum, name)
      scope.addTypeDecl(decl, zuiDecl, FALSE, ctx)
      decl.setAttributes(zuiDecl, ctx)
      decl.type.zuiAttr = zuiDecl.getType().getAttr()
      declExt.decl = decl
      IF scope.scopeName == NIL
        decl.pName = "E" .. name
      ELSE
        decl.pName = scope.scopeName .. "__E" .. name
      }
    ELSE
      decl = declExt.decl
      IF !scope.isForwardDeclare()
        # Not re-using the scope, need to define the enum again
        scope.addMember(decl)
      }
    }

    # If this enum is used the module or class that contains it must also be
    # marked as used.
    # Note that an enum only should be marked as used if the item names are
    # used, there is no need to mark it as used when a value is used.
    decl.addDependsOn(scope.outerDecl)

    bool didSetWritingFlags
    IF !ctx.outs.bodyOut.writing && !ctx.outs.declOut.writing
      IF ctx.outs.origBodyOutWriting && ctx.outs.origDeclOutWriting
        # Inside an abstract class.  Although members are not produced, enums
        # are.
        didSetWritingFlags = TRUE
        ctx.outs.declOut.writing = TRUE
        ctx.outs.bodyOut.writing = TRUE
      }
    }

    ctx.gen.enum(zuiDecl, decl, ctx)

    IF didSetWritingFlags
      ctx.outs.declOut.writing = FALSE
      ctx.outs.bodyOut.writing = FALSE
    }

    RETURN 0
  }

  FUNC generateIf(Zui.Statement stmt, SContext ctx) int
    Zui.Condition cond = stmt.getCondition()
    Output out = ctx.out

    ctx.gen.beforeStatement(stmt, ctx)

    int undef
    out.writeIndent(ctx.scope.depth)
    out.write("if (")
    IF stmt.getType() == Zui.StatementType.eIFNIL
      IF (ctx.scope.isClassScope() && ctx.scope.thisName != NIL
                                                        # && !isNew && !isInit
         ) || ctx.scope.insideBuiltin()
        ctx.gen.ifnilExpr(ctx)
      ELSE
        ctx.error("Cannot use IFNIL here", stmt)
      }
    ELSE
      genExpr(cond.getCond(), ctx, Type.aBool)
      undef = ZuiExpressionExt.get(cond.getCond()).undefined
    }
    out.write(")\n")
    undef += generateCodeBlock(cond.getBlock(), NIL, ctx, Scope.Stype.if, NIL)

    int needClose
    IF cond.hasElseif()
      FOR elseif IN cond.getElseifList()
        out.writeIndent(ctx.scope.depth)
        out.write("else {\n")
        ++needClose
        Zui.Expression elseExpr = elseif.getCond()
        ctx.gen.beforeStatement(elseExpr.getPos(), stmt, ctx)
        out.write(" if (")
        genExpr(elseExpr, ctx, Type.aBool)
        out.write(")\n")
        undef += ZuiExpressionExt.get(elseExpr).undefined
        undef += generateCodeBlock(elseif.getBlock(), NIL,
                                                 ctx, Scope.Stype.elseif, NIL)
      }
    }

    IF cond.hasElse()
      out.writeIndent(ctx.scope.depth)
      out.write("else\n")
      undef += generateCodeBlock(cond.getElse(), NIL,
                                                   ctx, Scope.Stype.else, NIL)
    }
    IF needClose > 0
      out.writeIndent(ctx.scope.depth)
      FOR i IN 1 TO needClose
        out.write("}")
      }
      out.write("\n")
    }

    RETURN undef
  }

  FUNC generateTry(Zui.Statement stmt, SContext ctx) int
    Resolve gen = ctx.gen
    Zui.TryStatement tryStmt = stmt.getTry()
    VAR tryStmtExt = ZuiTryStatementExt.get(tryStmt)
    IF skip_zero_undefined && !gen.writing
        && tryStmtExt.scope != NIL
        && !tryStmtExt.scope.needPass
                                   && ZuiStatementExt.get(stmt).undefined == 0
      # No need to process this block again.
      RETURN 0
    }

    ctx.addUsedItem(Declaration.try)
    Output out = ctx.outs.out           # normal generate output
    int undef

    ctx.gen.beforeStatement(stmt, ctx)

    # Create a scope for the whole TRY statement.
    ctx.gen.startBlock(ctx)

    TryScope blockScope
    IF tryStmtExt.scope == NIL
      blockScope = TryScope.NEW(ctx.scope, [])
      blockScope.scopeName = ctx.scope.scopeName .. "__"
                                            .. getScopeNr(ctx.scope.scopeName)
      tryStmtExt.scope = blockScope
      blockScope.scopeType = Scope.Stype.try
      blockScope.flags.insideTry = TRUE
      blockScope.hasFinally = tryStmt.hasFinally()

      STATIC int tryCount
      ++tryCount
      blockScope.finallyLabelName = "finally" .. tryCount
    ELSE
      blockScope = tryStmtExt.scope
      blockScope.initPass(ctx.scope)
      blockScope.needPass = FALSE
    }

    blockScope.catchList = NEW()
    Output.Group newOuts = ctx.outs.startNewBlock()
    SContext tryCtx = NEW(ctx.topScope, blockScope, gen, newOuts)

    # Produce the TRY block, including an optional ELSE
    gen.try_block(stmt, tryCtx)
    undef = generateCodeBlock(tryStmt.getBody(), NIL,
                                               tryCtx, Scope.Stype.block, NIL)
    IF blockScope.wantBacktrace
      ctx.scope.wantBacktrace = TRUE
    }
    gen.try_block_end(stmt, tryCtx)

    # Produce the CATCH blocks.
    IF tryStmt.hasCatch()
      FOR catch IN tryStmt.getCatchList()
        undef += generateCatch(catch, tryCtx)
      }
    }

    # Produce a FINALLY block.
    IF tryStmt.hasFinally()
      gen.try_finally(stmt, tryCtx)
      undef += generateCodeBlock(tryStmt.getFinally(), NIL,
                                               tryCtx, Scope.Stype.block, NIL)
    }

    gen.try_end(stmt, tryCtx)
    newOuts.endNewBlock()

    IF undef == 0
      # Symbols used in this block are also used in the containing scope.
      ctx.addUsedScope(blockScope)
    }

    out.writeIndent(ctx.scope.depth)
    out.write("}\n")

    RETURN undef
  }

  # ELSE as part of a TRY statement
  FUNC generateTryElse(Zui.Statement stmt, SContext ctx) int
    ctx.gen.try_else(stmt, ctx)
    RETURN generateCodeBlock(stmt.getBlock(), NIL, ctx, Scope.Stype.block, NIL)
  }

  # WHILE cond block
  FUNC generateWhile(Zui.Statement stmt, SContext ctx) int
    Zui.Condition cond = stmt.getCondition()

    ctx.gen.beforeStatement(stmt, ctx)

    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("while (")
    genExpr(cond.getCond(), ctx, Type.aBool)
    ctx.out.write(")\n")
    int undef = ZuiExpressionExt.get(cond.getCond()).undefined
    IF cond.hasBlock()
      undef += generateCodeBlock(cond.getBlock(), stmt,
                                                  ctx, Scope.Stype.while, NIL)
    ELSE
      ctx.out.writeIndent(ctx.scope.depth + 1)
      ctx.out.write(";\n")
    }
    RETURN undef
  }

  # DO block UNTIL cond
  FUNC generateDo(Zui.Statement stmt, SContext ctx) int
    Zui.Condition cond = stmt.getCondition()

    ctx.gen.beforeStatement(stmt, ctx)

    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("for (;;)\n")

    # The UNTIL is generated at the end of the block.
    RETURN generateCodeBlock(cond.getBlock(), stmt, ctx, Scope.Stype.do, NIL)
  }

  # UNTIL of DO block UNTIL cond
  FUNC generateUntil(Zui.Statement stmt, SContext ctx) int
    ctx.gen.beforeStatement(stmt, ctx)

    RETURN ctx.gen.until(stmt.getCondition(), ctx)
  }

  # FOR x IN composite
  # FOR x IN expr TO expr STEP expr
  FUNC generateFor(Zui.Statement stmt, SContext ctx) int
    Zui.ForStatement forStmt = stmt.getFor()
    VAR forStmtExt = ZuiForStatementExt.get(forStmt)
    Output out = ctx.out             # normal generate output
    int undef
    Resolve gen = ctx.gen
    Scope scope = ctx.scope
    int loopVarCount = forStmt.sizeLoopVar()
    int loopIterCount = forStmt.sizeIter()
    bool foundError

    ForLoopInfo forLoopInfo
    IF forStmtExt.info == NIL
      forLoopInfo = NEW()
      forStmtExt.info = forLoopInfo
      forLoopInfo.forStmt = forStmt
      forLoopInfo.iters = NEW()
      FOR i IN 0 UNTIL loopIterCount
        ForLoopInfo.Iter fi = NEW()
        fi.varDecl = NEW("for")
        # name to be used for variable that holds the loop info.
        fi.varDecl.pName = "Zf" .. ctx.scope.depth
        IF loopIterCount > 1
          fi.varDecl.pName ..= "abcdefghijklmnopqrstuvwxyz"[i].asString()
        }
        fi.varDecl.zuiPos = stmt.getPos()
        forLoopInfo.iters.add(fi)
      }
    ELSE
      forLoopInfo = forStmtExt.info
    }

    # Get the type(s) of what we loop over.
    FOR i IN 0 UNTIL forStmt.sizeIter()
      Zui.Expression iterExpr = forStmt.getIter(i)
      ForLoopInfo.Iter iter = forLoopInfo.iters[i]
      Type type = genExpr(iterExpr, ctx.copyNoOutUseItems())
      undef += ZuiExpressionExt.get(iterExpr).undefined
      type = type?.getEffType()
      iter.varDecl.type = type
      IF reportUndef && undef != 0
        ctx.error("generateFor() undef: \(undef), type: \(type.typeName())",
                                                                         stmt)
      }

      IF type == NIL
        foundError = TRUE
      ELSE
        IF ctx.doError() && type.getTtype() == Type.Enum.unknown
          # Generate the error in the expression.
          genExpr(iterExpr, ctx)
          foundError = TRUE
        }

        IF type.getClassType(ctx) != NIL
          ClassType class = type.getClassType(ctx)
          IF loopVarCount == 1 ? class.implementsIterator(ctx)
                               : class.implementsKeyIterator(ctx)
            # The iter expr is an iterator
            iter.isIterator = TRUE
            iter.iteratorType = type
          ELSE
            # The expression is an object that should have an Iterator() or
            # KeyIterator() method.
            Declaration method = class.findMatchingMethod(
                                loopVarCount == 1 ?  "Iterator" : "KeyIterator",
                                                  TRUE, [], NIL, 0, &undef, ctx)
            ctx.addUsedItem(method)
            iter.iteratorMethod = method

            IF method == NIL
              foundError = TRUE
            ELSE
              # The type of the iterator is the return type of the method.
              MethodType methodType = method.type
              iter.iteratorType = methodType.returnType
              iter.varDecl.type = methodType.returnType
              IF methodType.returnType == NIL
                foundError = TRUE
              }
            }
          }
        }

        # TODO: a variable with the same type can be re-used.
        mayPutDeclInMethodScope(iter.varDecl, ctx)
      }
    }

    # when not NIL use Iterator() or KeyIterator()
    Declaration iteratorMethod = forLoopInfo.iters[0].iteratorMethod

    # Start a new block so that we can declare the loop variable.
    gen.beforeStatement(stmt, ctx)
    Zui.Expression expr = forStmt.getIter(0)
    gen.forBlockStart(expr.getPos(), ctx)

    Type toType
    Type untilType
    Type stepType
    IF forStmt.hasTo() || forStmt.hasUntil()
      Type iterType = forLoopInfo.iters[0].varDecl.type
      IF forStmt.hasTo()
        # FOR x IN a TO b
        Zui.Expression toExpr = forStmt.getTo()
        toType = genExpr(toExpr, ctx.copyNoOutUseItems(), iterType)
        undef += ZuiExpressionExt.get(toExpr).undefined
        IF ctx.doError()
          IF toType == NIL
            genExpr(toExpr, ctx, iterType)
            ctx.error("Expected int", toExpr)
          ELSEIF !toType.isIntType()
            genExpr(toExpr, ctx, iterType)
            ctx.error("Expected number, found "
                                      .. toType.getTtype().ToString(), toExpr)
          }
        }
      ELSE
        # FOR x IN a UNTIL b
        Zui.Expression untilExpr = forStmt.getUntil()
        untilType = genExpr(untilExpr, ctx.copyNoOutUseItems(), iterType)
        undef += ZuiExpressionExt.get(untilExpr).undefined
        IF ctx.doError()
          IF untilType == NIL
            genExpr(untilExpr, ctx, iterType)
            ctx.error("Expected int", untilExpr)
          ELSEIF !untilType.isIntType()
            genExpr(untilExpr, ctx, iterType)
            ctx.error("Expected number, found "
                                .. untilType.getTtype().ToString(), untilExpr)
          }
        }
      }
      IF forStmt.hasStep()
        # FOR x IN a TO b STEP c
        Zui.Expression stepExpr = forStmt.getStep()
        stepType = genExpr(stepExpr, ctx.copyNoOutUseItems(), iterType)
        undef += ZuiExpressionExt.get(stepExpr).undefined
        IF ctx.doError() && stepType == NIL
          ctx.error("Expected int", stepExpr)
        }
      }
    }

    # Chicken-egg problem: forStart() gets the item type, but we need to
    # generate the item type declaration first.  Write forStart() output into
    # forStartOut and append afterwards.
    Output forStartOut
    SContext forStartCtx
    IF out.writing
      forStartOut = NEW()
      forStartOut.writing = out.writing
      forStartCtx = ctx.copy(forStartOut)
    ELSE
      forStartOut = ctx.out
      forStartCtx = ctx
    }

    list<Type> itemTypes
    IF !foundError
      itemTypes = gen.forStart(forLoopInfo, toType, untilType, stepType,
                                                                  forStartCtx)
      IF itemTypes == NIL
        ++undef
      ELSEIF itemTypes.Size() != loopVarCount
        ++undef
        IF ctx.doError()
          ctx.error("Expected " .. itemTypes.Size() .. " variables, found "
                                                 .. loopVarCount, stmt)
        }
      }
    }
    IF itemTypes == NIL
      # avoid checking for NIL everywhere
      itemTypes = [Type.anUnknown]
    }

    # Process the loop variables: Get it from the context for "USE i", declare
    # a new variable for "i".
    list<Declaration> varList = NEW()
    list<ScopeSym> ssl
    FOR i IN 0 UNTIL loopVarCount
      Zui.Declaration loopVar = forStmt.getLoopVar(i)
      Type itemType
      IF i < itemTypes.Size()
        itemType = itemTypes[i]
      }
      IF itemType == NIL
        itemType = Type.anUnknown
      }
      string loopVarName = loopVar.getName()
      bool needDeclare

      # Find the loop variable in outer scope.
      Declaration varDecl = scope.getDecl(loopVar, NEW(loopVar.getPos(), ctx))
      IF varDecl == NIL
        IF loopVar.getIsUse()  # "USE i"
          undef++
          IF ctx.doError()
            ctx.error("USE loop variable not found", loopVar)
          }
        }

        # Declare the loop variable.
        VAR loopVarExt = ZuiDeclarationExt.get(loopVar)
        needDeclare = TRUE
        IF loopVarExt.decl == NIL
          varDecl = Declaration.NEW("for", Type.anUnknown) # type is set below
          varDecl.pName = "V" .. loopVarName
          varDecl.isLoopVar = TRUE
          loopVarExt.decl = varDecl
        ELSE
          varDecl = loopVarExt.decl
        }

        IF itemType.getTtype() == Type.Enum.unknown
          undef += 2
        ELSE
          varDecl.type = itemType
          IF itemType.getTtype() == Type.Enum.unknown
            undef++
          }
          mayPutDeclInMethodScope(varDecl, ctx)

          IF !varDecl.inMethodScope || !gen.varsInMethodScope()
            out.writeIndent(scope.depth + 1)

            # TODO: Avoid this hack for bool and status.
            # For Bits it's wrong when the variable is not declared here.
            Type.Enum actualType = varDecl.type.getTtype()
            IF varDecl.type.getTtype() == Type.Enum.bool
                               || varDecl.type.getTtype() == Type.Enum.status
                               || varDecl.type.getTtype() == Type.Enum.bitsValue
                               || varDecl.type.getTtype() == Type.Enum.int8
                               || varDecl.type.getTtype() == Type.Enum.int16
                               || varDecl.type.getTtype() == Type.Enum.int32
              # A bool and status is declared as an int, so that we can use
              # ZforListGetInt().
              varDecl.type.ttype = Type.Enum.int
            ELSEIF varDecl.type.getTtype() == Type.Enum.byte
                               || varDecl.type.getTtype() == Type.Enum.nat16
                               || varDecl.type.getTtype() == Type.Enum.nat32
              varDecl.type.ttype = Type.Enum.nat
            ELSEIF varDecl.type.getTtype() == Type.Enum.float32
              varDecl.type.ttype = Type.Enum.float
            }
            gen.vardecl(varDecl, ctx)
            gen.statementLineEnd(out)
            varDecl.type.ttype = actualType
          }
          ctx.addUsedItem(varDecl)
        }
      ELSE
        IF itemType.getTtype() != Type.Enum.unknown
          IF !loopVar.getIsUse()  # not "FOR USE i"
            undef++
            IF ctx.doError()
              ctx.error("loop variable shadows symbol", stmt)
              Declaration.reportError("declared here", varDecl, ctx)
            }
          }
          IF !Type.matchingTypes(varDecl.type, itemType, ctx)
            undef++
            IF ctx.doError()
              typeError(itemType, varDecl.type, loopVar.getPos(), ctx)
            }
          }
        }
        IF varDecl ISNOTA Declaration
          # Happens when the name is a method.
          # Avoid an error further down.
          Declaration decl = NEW(varDecl.name)
          decl.type = varDecl
          varDecl = decl
        }
      }

      varList.add(varDecl)

      IF needDeclare
        # Declare the loop var at the start of the block.
        ScopeSym ss = NEW(loopVarName, varDecl, loopVar)
        IF ssl == NIL
          ssl = [ss]
        ELSE
          ssl.add(ss)
        }
      }
    }

    out.append(forStartOut)

    IF !foundError
      gen.forLoop(forLoopInfo, varList, ctx)
    }

    # "FOR i, j IN expr" needs a temp variable to store the result of the
    # iterator, before each value is assigned to "i" and "j".
    # The Annotator will set tempDecl on forLoopInfo.multiExpr.
    IF loopVarCount > 1
      IF forLoopInfo.multiExpr == NIL
        forLoopInfo.multiExpr = NEW()
        forLoopInfo.multiExpr.setType(Zui.ExprType.eID)
        forLoopInfo.multiExpr.setPos(stmt.getPos())
      }
      ZuiExpressionExt.get(forLoopInfo.multiExpr).resultType =
                                              MultipleType.NEW(varList, "for")
    }

    IF forStmt.hasBody()
      Zui.CodeBlock block = forStmt.getBody()
      VAR blockExt = ZuiCodeBlockExt.get(block)
      IF skip_zero_undefined && !gen.writing
          && blockExt.scope != NIL
          && !blockExt.scope.needPass
                     && ZuiStatementExt.get(stmt).undefined == 0 && undef == 0
        # No need to process this block again.
        RETURN 0
      }

      undef += genBlockScopeWithSym(ssl, Scope.Stype.for, NIL, forLoopInfo,
                               block, ctx)
    }

    IF !foundError
      gen.forEnd(stmt, ctx)
    }
    out.writeIndent(scope.depth + 1)
    out.write("}\n")

    out.writeIndent(scope.depth)
    out.write("}\n")

    RETURN undef
  }

  FUNC getScopeNr(string scopeName) int
    # Every block that doesn't have a name gets a number, so that items
    # defined inside it can have a unique name.  The number is generated from
    # the outer scope name, so that it doesn't change every time when anything
    # before this changed.  Keep track of which ones were used to avoid
    # duplicates.
    STATIC set<int> %scopeNumbers = NEW()

    int nr = scopeName.hash() % 1'000'000
    WHILE %scopeNumbers.has(nr)
      ++nr
    }
    %scopeNumbers.add(nr)
    RETURN nr
  }

  # One symbol defined in a block scope.
  CLASS ScopeSym
    string           $symName  # name of the symbol in Zimbu code
    Declaration.C    $decl     # pName is the name in generated code
    Zui.Declaration  $zuiDecl  # used to keep the created Declaration

    NEW(string symName, Declaration.C decl, Zui.Declaration zuiDecl)
      $symName = symName
      $decl = decl
      $zuiDecl = zuiDecl
    }
  }

  # Generate a scope for |block| defining |symbols| in that scope.
  FUNC genBlockScopeWithSym(list<ScopeSym> symbols,
                            Scope.Stype scopeType,
                            Type switchType,
                            ForLoopInfo forLoopInfo,
                            Zui.CodeBlock block,
                            SContext ctx) int
    BlockScope blockScope
    VAR blockExt = ZuiCodeBlockExt.get(block)
    IF blockExt.scope == NIL
      list<Zui.Statement> statements = block.getStatementList()
      IF scopeType == Scope.Stype.switch
        blockScope = SwitchScope.NEW(ctx.scope, statements)
      ELSE
        blockScope = BlockScope.NEW(ctx.scope, statements)
      }
      blockScope.scopeName = ctx.scope.scopeName .. "__"
                                            .. getScopeNr(ctx.scope.scopeName)
      blockScope.scopeType = scopeType
      blockExt.scope = blockScope
    ELSE
      blockScope = blockExt.scope
      blockScope.initPass(ctx.scope)
      blockScope.needPass = FALSE
    }

    IF scopeType == Scope.Stype.switch
      SwitchScope ss = blockScope
      ss.caseSet = NEW()
      IF ss.varName == NIL
        ss.varName = WriteCommon.getUid(ctx.scope.ToString())
      }
      blockScope.switchType = switchType
    }
    blockScope.forLoopInfo = forLoopInfo

    FOR sym IN symbols
      # Define the symbols.
      Declaration.C decl = sym.decl
      Declaration.C scopeDecl = blockScope.addDecl(sym.symName, decl.type,
                                                      sym.zuiDecl, FALSE, ctx)
      # recycle scopeDecl in next pass
      ZuiDeclarationExt.get(sym.zuiDecl).decl = scopeDecl
      scopeDecl.pName = decl.pName
      scopeDecl.isLoopVar = decl.isLoopVar

      # Reference the loop variable. Not for a for loop, what it points to
      # always has a non-zero reference count.
      IF !decl.isLoopVar
        # Need to write the declaration of the variable at the start of the
        # method.
        mayPutDeclInMethodScope(decl, ctx)
      }
    }

    Output.Group newOuts = ctx.outs.startNewBlock()
    SContext blockCtx = NEW(ctx.topScope, blockScope, ctx.gen, newOuts)

    IF scopeType == Scope.Stype.tryCatch
      # This is a CATCH block.
      IF blockScope.statements.Size() > 0
        # The declaration is at start of the method, set the value here.
        ctx.out.writeIndent(blockScope.depth)
        Declaration.C decl = symbols[0].decl
        ctx.out.write(decl.pName)
        ctx.out.write(" = ")
        ctx.gen.topException(decl, block.getPos(), ctx, blockCtx)
        ctx.gen.statementLineEnd(ctx.out)
      }

      blockCtx.out.writeIndent(blockScope.depth)
      blockCtx.out.write("caught = 1;\n")
    }

    int undef = generate(blockScope.statements, blockCtx)

    # End the block scope.
    IF !endsInReturn(blockScope.statements, TRUE)
      ctx.gen.writeScopeEnd(TRUE, FALSE, blockScope.statements,
                                                  block.getEndPos(), blockCtx)
    }
    newOuts.endNewBlock()

    IF undef == 0
      # Symbols used in this block are also used in the containing scope.
      ctx.addUsedScope(blockScope)
    }

    IF blockScope.wantBacktrace
      ctx.scope.wantBacktrace = TRUE
    }
    IF blockScope.primitive
      ctx.scope.primitive = TRUE
    }
    blockExt.undefined = undef
    RETURN undef
  }

  # EXIT, RETURN and THROW.
  FUNC generateReturnExitThrow(
                 Zui.Statement stmt, Zui.Statement nextStmt, SContext ctx) int
    Output out = ctx.out             # normal generate output
    int undef
    Scope scope = ctx.scope
    Zui.StatementType stmtType = stmt.getType()
    bool isExit = stmtType == Zui.StatementType.eEXIT
    bool isReturn = stmtType == Zui.StatementType.eRETURN
    bool isThrow = stmtType == Zui.StatementType.eTHROW

    # Always set the position, even though it will not be used if there is no
    # expression, because we don't want to run the GC here.
    ctx.gen.beforeStatement(stmt.hasExpr() && !isThrow
                         ? stmt.getExpr().getPos() : stmt.getPos(), TRUE, ctx)

    IF isReturn && scope.returnType != NIL
      # When there are multiple return values, first set the extra ones.
      IF stmt.sizeArguments() > 1
        FOR i IN 1 UNTIL stmt.sizeArguments()
          Zui.Expression expr = stmt.getArguments(i)
          Type type
          IF scope.returnType ISA MultipleType
            type = scope.returnType.<MultipleType>.getType(i)
          }
          IF type != NIL
            ctx.gen.extraReturn(expr, i, ctx, type)
            undef += ZuiExpressionExt.get(expr).undefined
          ELSE
            undef += 5
          }
        }
        ctx.gen.returnBefore(FALSE, TRUE, ctx)
      ELSE
        ctx.gen.returnBefore(FALSE, FALSE, ctx)
      }
    ELSEIF isExit
      out.writeIndent(scope.depth)
      ctx.gen.exitBefore(stmt, ctx)
    }
    IF stmt.hasExpr()
      Zui.Expression expr = stmt.getExpr()
      VAR exprExt = ZuiExpressionExt.get(expr)
      IF isReturn && (scope.returnType == NIL || scope.flags.insideNew)
        undef = 5
        IF ctx.doError() || scope.flags.insideNew
          ctx.error(stmtType.ToString().slice(1) .. " argument unexpected",
                                                                         stmt)
        }
      ELSEIF isExit
        genExpr(expr, ctx, Type.anInt)
        undef = exprExt.undefined
      ELSEIF isThrow
        undef = 0
        Type type = genExpr(expr, ctx.copyNoOut())
        IF type == NIL || type.getTtype() != Type.Enum.string
          type = Builtin.getExceptionDotIType()
          IF type.getTtype() == Type.Enum.unknown
            ++undef
          }
        }
        ctx.gen.throw(stmt, nextStmt != NIL, type, ctx)
        undef += ZuiStatementExt.get(stmt).undefined
      ELSEIF stmt.sizeArguments() > 1
        # Multiple return values, first one is produced normally.
        IF scope.returnType ISA MultipleType
          genTopExprDoConv(expr, ctx,
                                   scope.returnType.<MultipleType>.getType(0))
        }
        undef += exprExt.undefined
      ELSE
        # One return value
        genTopExprDoConv(expr, ctx, scope.returnType)
        undef = exprExt.undefined
        # Note: the return value is not in the stack frame, thus it canoot be
        # used for expr.toplevelVar.
      }
    ELSE
      IF isReturn && (scope.flags.insideNew || scope.flags.insideInit)
        out.write(scope.thisName)
      ELSEIF scope.returnType != NIL
        ctx.error("argument expected", stmt)
      }
    }
    IF isReturn
      IF scope.returnType != NIL
        ctx.gen.statementLineEnd(out)
      }

      IF scope ISA MethodScope
        IF nextStmt == NIL
          # At the end of a method: we can simply return.
          ctx.gen.returnAfter(scope.returnType, TRUE, stmt.getPos(), ctx)
        ELSE
          # In the method scope: jump to the return at the end.
          ctx.gen.jumpToReturn(ctx)
        }
      ELSE
        # In an inner scope: set the "rt" flag and jump to the end of the
        # outer scope.
        Scope s = ctx.scope.tryScope(FALSE, FALSE)
        IF s != NIL && s.<TryScope>.hasFinally
          # Inside a TRY with a FINALLY, need to jump to the finally.
          ctx.gen.returnAfter(scope.returnType, TRUE, stmt.getPos(), ctx)
        ELSE
          IF nextStmt == NIL
            ctx.gen.writeScopeEnd(TRUE, TRUE, NIL, stmt.getPos(), ctx)
          }
          ctx.gen.jumpToOuterScope(ctx)
        }
      }
    ELSEIF isExit
      ctx.gen.exitAfter(nextStmt == NIL, ctx)
      IF scope ISA MethodScope && scope.retLabel != NIL
        # A RETURN will jump to the end of the function, need to generate the
        # label and return statement.
        ctx.gen.returnAfter(scope.returnType, TRUE, stmt.getPos(), ctx)
      }
    }
    checkNoNextStmt(nextStmt, stmtType.ToString().slice(1), ctx)

    RETURN undef
  }

  PROC checkNoNextStmt(Zui.Statement nextStmt, string after, SContext ctx)
    IF nextStmt != NIL
        && nextStmt.getType() != Zui.StatementType.eCASE
        && nextStmt.getType() != Zui.StatementType.eDEFAULT
      ctx.error("Unreachable code after " .. after, nextStmt)
    }
  }

  # DEFER
  FUNC generateDefer(
                 Zui.Statement stmt, SContext ctx) int
    IF !stmt.hasExpr()
      ctx.error("Argument required", stmt)
    ELSE
      Zui.Expression expr = stmt.getExpr()
      IF expr.getType() != Zui.ExprType.eCALL
        ctx.error("Expected method call", stmt)
      ELSE
        ctx.addUsedItem(Declaration.defer)
        ctx.addUsedItem(Declaration.list)
        ctx.addUsedItem(Declaration.try)

        # This is like creating a callback and adding it to a list:
        #    callback<proc<>, argType> cb = NEW(method, arg)
        #    deferList.add(cb)
        # However, to locate the method we need the type of the arguments.
        # That is a lot like generating the call, without actually generating
        # it.  Pass CallbackInfo down for that.
        Zui.MethodCall call = expr.getMethodCall()
        CallbackInfo cbInfo = NEW()
        generateCall(call, cbInfo, ctx.copyNoOutUseItems(), Type.anUnknown)

        # Create the callback type for the method.
        # TODO: share the MethodType with callback<proc<>>
        STATIC MethodType deferMethodType = NIL
        IF deferMethodType == NIL
          deferMethodType = NEW(Type.Enum.proc, "defer")
        }
        CallbackType cb = deferMethodType.getCallback(cbInfo.arguments, ctx)
        setCalledMethodType(cb, ctx)
        ctx.addUsedItem(cb)
        cbInfo.callback = cb
        
        # Generate as "ZaddDefer(deferList, NewCallback(method, arg))"
        ctx.gen.beforeStatement(stmt, ctx)
        ctx.gen.addDefer(call, cbInfo, ctx)
        RETURN ZuiMethodCallExt.get(call).undefined
      }
    }
    RETURN 10
  }

  # CATCH
  # Return number of undefined symbols.
  FUNC generateCatch(Zui.Catch catch, SContext ctx) int
    int undef
    Output out = ctx.out
    TryScope scope = ctx.scope

    # Get exception type arguments.
    list<Type> exceptList = NEW()
    FOR type IN catch.getTypeList()
      Zui.Expression expr = type.getName()
      SymUse symUse = NEW(expr.getPos(), ctx)
      Type exceptType = generateDeclType(expr, ctx.copyNoOut(),
                                                    isDecl + markUsed, symUse)
      undef += ZuiExpressionExt.get(expr).undefined

      # Change a class to an iobject if it has children.
      # "CATCH E.Exception" means "CATCH E.Exception.I"
      IF exceptType != NIL && exceptType.getTtype() == Type.Enum.class
        Type t = exceptType.getValueType(ctx)
        IF t.getTtype() == Type.Enum.iobject
          exceptType = t
        }
      }

      IF exceptType == NIL || exceptType.getTtype() == Type.Enum.unknown
        ++undef
        IF ctx.doError()
          symUse.doError = TRUE
          IF generateDeclType(expr, ctx.copyNoOut(),
                                             isDecl + markUsed, symUse) == NIL
            symUse.doError = TRUE
            generateDeclType(expr, ctx, isDecl + markUsed, symUse)
          }
        }
      ELSEIF exceptType.getTtype() != Type.Enum.class
                                 && exceptType.getTtype() != Type.Enum.iobject
        ++undef
        IF ctx.doError()
          ctx.error("Exepected a class or interface, got "
                                               .. exceptType.typeName(), expr)
        }
      ELSE
        exceptList.add(exceptType)

        # Use |catchList| for the caught exception classes.
        string name
        IF exceptType.getTtype() == Type.Enum.iobject
          name = exceptType.getClassType(ctx).pName .. "__I"
        ELSE
          name = exceptType.pName
        }
        FOR s IN scope.catchList
          IF name == s
            ctx.error("duplicate catch argument: " .. name, expr)
            BREAK
          }
        }
        scope.catchList.add(name)
      }
    }

    ctx.gen.try_catch(catch, exceptList, ctx)

    # Generate scope and declare the exception var.
    IF catch.hasBody() && exceptList.Size() > 0
      # Start a new block so that we can declare the exception var.
      ctx.gen.startBlock(ctx)

      # Generate exception var, it's in catch.decl.  The type is always
      # E.Exception.  Only needed when there are statements.
      Declaration.C eDecl
      Zui.Declaration zuiDecl
      IF catch.getBody().sizeStatement() > 0
        Type type = Builtin.getExceptionDotIType()
        zuiDecl = catch.getDecl()
        VAR declExt = ZuiDeclarationExt.get(zuiDecl)
        IF declExt.decl == NIL
          eDecl = NEW(zuiDecl.getName())
          eDecl.pName = "V" .. zuiDecl.getName()
          declExt.decl = eDecl
        ELSE
          eDecl = declExt.decl
        }
        eDecl.type = type
      }

      # Generate the scope and define the exception var in it.
      ScopeSym ss = NEW(zuiDecl == NIL ? NIL : zuiDecl.getName(),
                                                               eDecl, zuiDecl)
      undef += genBlockScopeWithSym([ss],
                               Scope.Stype.tryCatch, NIL, NIL,
                               catch.getBody(), ctx)

      out.writeIndent(scope.depth)
      out.write("}\n")
    }

    RETURN undef
  }

  FUNC generateBreak(Zui.Statement stmt, Zui.Statement nextStmt,
                                                             SContext ctx) int
    # check we are inside a scope where BREAK is allowed
    checkScope(stmt, ctx, TRUE)

    Scope s = ctx.scope.tryScope(TRUE, FALSE)
    IF s != NIL
      s.<TryScope>.foundBreak = TRUE
    }
    IF s != NIL && s.<TryScope>.hasFinally
      # The BREAK is inside a TRY with a FINALLY, jump there.
      ctx.gen.writeBreakGotoFinally(s, ctx)
    ELSE
      ctx.gen.writeBreak(ctx)
    }
    checkNoNextStmt(nextStmt, "BREAK", ctx)
    RETURN 0
  }

  FUNC generateContinue(Zui.Statement stmt, Zui.Statement nextStmt,
                                                             SContext ctx) int
    # check we are inside a scope where CONTINUE is allowed
    checkScope(stmt, ctx, FALSE)

    Scope s = ctx.scope.tryScope(TRUE, FALSE)
    IF s != NIL
      s.<TryScope>.foundContinue = TRUE
    }
    IF s != NIL && s.<TryScope>.hasFinally
      # The CONTINUE is inside a TRY with a FINALLY, jump there.
      ctx.gen.writeContinueGotoFinally(s, ctx)
    ELSE
      ctx.gen.writeContinue(ctx)
    }
    checkNoNextStmt(nextStmt, "CONTINUE", ctx)
    RETURN 0
  }

  # SWITCH
  FUNC generateSwitch(Zui.Statement stmt, SContext ctx) int
    Zui.Condition cond = stmt.getCondition()
    Output out = ctx.out             # normal generate output
    Scope scope = ctx.scope

    ctx.gen.beforeStatement(stmt, ctx)

    Zui.CodeBlock block = cond.hasBlock() ? cond.getBlock() : NIL

    Zui.Expression expr = cond.getCond()
    Type switchType = ctx.gen.switch(expr, block, ctx)
    int undef = ZuiExpressionExt.get(expr).undefined

    IF switchType != NIL && switchType.getTtype() != Type.Enum.int
                               && switchType.getTtype() != Type.Enum.type
                               && switchType.getTtype() != Type.Enum.enumValue
      undef++
      IF ctx.doError()
        ctx.error("SWITCH type must be int, enum or type, found "
                                            .. switchType.typeName(), stmt)
      }
    }
    IF block != NIL
      undef += generateCodeBlock(block, NIL, ctx,
                                               Scope.Stype.switch, switchType)
    }
    RETURN undef
  }

  # CASE and DEFAULT
  # Return number of undefined symbols.
  FUNC generateCase(Zui.Statement stmt, Zui.Statement nextStmt, SContext ctx
                   ) int
    Output out = ctx.out             # normal generate output
    Resolve gen = ctx.gen
    int undef

    IF ctx.scope ISNOTA SwitchScope
      ctx.error("CASE or DEFAULT not inside a SWITCH", stmt)
      RETURN 10
    }
    SwitchScope scope = ctx.scope
    Type.Enum ttype = scope.switchType?.getTtype()

    IF stmt.getType() == Zui.StatementType.eCASE
      # CASE
      Zui.Expression expr = stmt.getExpr()
      bool caseFollows = nextStmt != NIL && !stmt.hasBlock()
      string value = ctx.gen.caseString(expr, caseFollows, ctx)
      undef += ZuiExpressionExt.get(expr).undefined

      # Next CASE continues this CASE.
      scope.wroteCase = TRUE

      IF gen.writing
        # Only in the actual write round do we produce the result and can
        # we check for the value to be unique.
        IF scope.caseSet.has(value)
          IF ctx.doError()
            ctx.error("duplicate case value: " .. value, stmt)
          }
        ELSE
          scope.caseSet.add(value)
        }
      }
    ELSE
      # DEFAULT
      ctx.gen.default(ctx)
    }

    # If code is following create a new block, so that we can put
    # declarations here.
    IF stmt.hasBlock()
      undef += generateCodeBlockBody(stmt.getBlock(), NIL,
                                                  ctx, Scope.Stype.block, NIL)
      list<Zui.Statement> statements = stmt.getBlock().getStatementList()
      IF ttype == Type.Enum.type && !stmt.hasProceedPos()
        IF !endsInReturn(statements, FALSE) && !endsInThrow(statements)
          out.writeIndent(ctx.scope.depth)
          ctx.gen.jumpToReturn(ctx)
        }
      }

      # Enforce a break at the end of each block, unless PROCEED is used.
      IF stmt.hasProceedPos()
        IF nextStmt == NIL
          ctx.error("Nothing after PROCEED", stmt.getProceedPos())
        ELSEIF nextStmt.getType() != Zui.StatementType.eCASE
            && nextStmt.getType() != Zui.StatementType.eDEFAULT
          ctx.error("Statement after PROCEED", stmt.getProceedPos())
        ELSEIF ttype == Type.Enum.type
          ctx.gen.writeProceed(nextStmt, ctx)
        }
      ELSEIF ttype != Type.Enum.type && !endsInReturn(statements, FALSE)
        out.writeIndent(scope.depth + 2)
        out.write("break;\n")
      }
      out.writeIndent(ctx.scope.depth)
      out.write("}\n")

      # Next CASE starts a new sequence of CASE.
      scope.wroteCase = FALSE

    ELSEIF nextStmt == NIL && ttype != Type.Enum.type
      # No statements after last DEFAULT or CASE, need to produce a break
      # to avoid a compilation error.
      out.writeIndent(scope.depth)
      out.write("break;\n")
    }

    RETURN undef
  }

  FUNC generateCallStatement(Zui.Statement stmt, SContext ctx) int
    ctx.gen.beforeStatement(stmt, ctx)
    ctx.out.writeIndent(ctx.scope.depth)

    # "func(arg)", "class.method(arg)", "module.func(arg)", etc.
    Zui.MethodCall call = stmt.getMethodCall()
    VAR callExt = ZuiMethodCallExt.get(call)
    Type ret = generateCall(call, NIL, ctx, NIL)
    IF ret != NIL && ret.getTtype() == Type.Enum.unknown
      # Method was found but return type is unknown, need to come here again.
      ++callExt.undefined
    }
    ctx.gen.statementLineEnd(ctx.out)

    RETURN callExt.undefined
  }

  # Get the argument types of the |zuiMethod| in |expr| from |destType|.
  # Also set the return type.
  # Used for lambda expression and LAMBDA method.
  PROC getLambdaArgTypes(Zui.Expression expr, Zui.MethodType zuiMethod,
                                                  Type destType, SContext ctx)
    VAR exprExt = ZuiExpressionExt.get(expr)
    IF destType == NIL
      exprExt.undefined += 10
      IF ctx.doError()
        ctx.error("No target for closure", expr)
      }
    ELSEIF destType.getTtype() == Type.Enum.procRef
                                   || destType.getTtype() == Type.Enum.funcRef
      MethodType destMethod = destType.getMethod()
      list<Declaration.C> argList = destMethod.getArgList()

      int argCount = argList == NIL ? 0 : argList.Size()
      int mi
      FOR arg IN zuiMethod.getArgumentList()
        IF mi >= argCount
          ctx.error("Expected only " .. argCount .. " arguments", arg)
          BREAK
        }
        Declaration.C decl = argList[mi]
        IF decl == NIL || decl.type.getTtype() == Type.Enum.unknown
          ++exprExt.undefined
        ELSE
          ZuiTypeExt argExt = ZuiTypeExt.get(arg.getType())
          argExt.typeObj = decl.type
          argExt.undefined = 0
        }
        ++mi
      }
      IF mi < argCount
        ctx.error("Expected " .. argCount .. " arguments", expr)
      }

      # Set the function return type, if any.
      Type retDestType = destMethod.getReturnType()
      IF retDestType != NIL
        IF !zuiMethod.hasReturnType()
          # Add a dummy return type to set the typeObj on.
          zuiMethod.addNewReturnType()
        }
        # Always put the type on the first return type, generateMethod() knows
        # that.
        ZuiTypeExt retExt = ZuiTypeExt.get(zuiMethod.getReturnType(0))
        retExt.typeObj = retDestType
        retExt.undefined = 0
      }
    ELSE
      exprExt.undefined += 5
      IF ctx.doError()
        ctx.error("Target for lambda is not a method", expr)
      }
    }
  }

  int lambdaNr   # Sequence number for generated lambda functions.
                 # TODO: should be in the file, so that the numbering doesn't
                 # depend on other files.

  # Generate a lambda expression, it is used in an expression.
  # Returns the declaration of the resulting method reference.
  FUNC generateLambdaExpr(Zui.Expression expr, SContext ctx, Type destType
                         ) MethodRefType
    Zui.MethodType zuiMethod = expr.getMethod()
    VAR exprExt = ZuiExpressionExt.get(expr)
    Declaration closure
    MethodType methodType
    IF exprExt.decl == NIL
      string name = "Lambda" .. lambdaNr
      Type.Enum funcType = (destType == NIL
                                  || destType.getTtype() == Type.Enum.funcRef)
                                             ? Type.Enum.func : Type.Enum.proc
      methodType = MethodType.NEW(funcType, name)
      methodType.pName = name
      methodType.type = methodType
      methodType.zuiPos = expr.getPos()
      # Only store the Declaration when actually producing the argument, not
      # when guessing the type.
      IF !ctx.isNoOut()
        exprExt.decl = methodType
      }
      ++lambdaNr
      closure = methodType
    ELSE
      closure = exprExt.decl
      methodType = closure
    }
    exprExt.undefined = 0

    # Figure out the argument types from the destType.
    getLambdaArgTypes(expr, expr.getMethod(), destType, ctx)

    MethodScope funcScope
    VAR zuiMethodExt = ZuiMethodTypeExt.get(zuiMethod)
    IF zuiMethodExt.scope == NIL
      funcScope = NEW(ctx.scope, [])
      funcScope.name = closure.name .. "()"
      funcScope.scopeName = closure.pName
      funcScope.scopeType = Scope.Stype.funcDef
      funcScope.methodScope = funcScope
      funcScope.noBacktrace = FALSE
      funcScope.wantBacktrace = TRUE
      funcScope.outerDecl = closure

      # Create a reference to the closure, that's what we are going to return.
      # Create it once so that it can be marked as used.
      Type ref = methodType.getMethodRef()
      ref.name = closure.name
      ref.type = ref
      ref.pName = closure.pName
      ref.addDependsOn(closure)
      funcScope.reference = ref

      # Only store the Scope when actually producing the argument, not
      # when guessing the type.
      IF !ctx.isNoOut()
        zuiMethodExt.scope = funcScope
        methodType.scope = funcScope
      }
    ELSE
      funcScope = zuiMethodExt.scope
      funcScope.initPass(ctx.scope)
    }

    # The first part is used both for the declaration and the start of the
    # function definition.  Write to a new Output so that we can use it twice.
    Output funcOut = NEW()
    funcOut.writing = ctx.out.writing
    SContext funcOutCtx = ctx.copy(funcOut)
    funcOutCtx.scope = funcScope

    # Write any stack frame offset table.
    IF funcOutCtx.out.writing
      Output leaderOut = ctx.outs.origBodyOut ?: ctx.outs.bodyOut
      ctx.gen.methodLeader(methodType, leaderOut, funcOutCtx)
    }

    # Write the function name and arguments to another output, because we
    # can't write the return type yet.
    Output funcHeadOut = NEW()
    funcHeadOut.writing = ctx.out.writing
    SContext funcHeadOutCtx = ctx.copy(funcHeadOut)

    # Function name.
    ctx.gen.methodStart(closure, methodType.hasAnyArguments(), funcHeadOutCtx)

    # Generate function arguments and add them to the function scope.
    exprExt.undefined += generateMethodArgs(methodType,
                                         zuiMethod,
                                         funcScope,
                                         exprExt.undefined == 0,
                                         funcHeadOutCtx)
    # Generate USE arguments.
    exprExt.undefined += generateMethodUseArgs(methodType, zuiMethod, funcScope,
                                  exprExt.undefined == 0, ctx, funcHeadOutCtx)

    IF methodType.getTtype() == Type.Enum.func
      # Function return type.
      # First figure out the type.  This can only be done after adding the
      # arguments to the scope, because they are probably used to make the
      # result.
      Type retDestType = destType == NIL || destType.getMethod() == NIL
                                  ? NIL : destType.getMethod().getReturnType()
      methodType.returnType = genExpr(zuiMethod.getExpr(),
                                 funcOutCtx.copyNoOut(ctx.out.writing),
                                 retDestType)
    }
    ctx.gen.vartype(methodType.returnType, TRUE,
                                     zuiMethod.getExpr().getPos(), funcOutCtx)

    # Now append the function name and arguments.
    funcOut.append(funcHeadOut)

    # Generate the method body
    exprExt.undefined += generateMethodBody(zuiMethod, expr.getPos(),
                                methodType,
                                zuiMethod.getExpr(),
                                funcScope, funcOutCtx, ctx)

    generateMethodCallbacks(methodType, expr.getPos(), &exprExt.undefined, ctx)

    # A closure is always used where it is defined.
    IF exprExt.undefined == 0 || usedWhenUndefined
      ctx.addUsedItem(closure)
    }

    # Return a reference to the generated function.
    RETURN funcScope.reference
  }

  # Generate a method and return a symbol that refers to it.
  # proc<> p = PROC () statements }
  # func< => int> f = FUNC () int; RETURN 5; }
  # func<int => int> f = LAMBDA (x); RETURN x + 5; }
  FUNC genExprMethod(Zui.Expression expr, SContext ctx, Type destType) Type
    Zui.Declaration zuiDecl = expr.getDecl()
    VAR exprExt = ZuiExpressionExt.get(expr)

    IF !zuiDecl.hasName()
      string name = "Nameless" .. lambdaNr
      ++lambdaNr
      zuiDecl.setName(name)
    }
    exprExt.undefined = 0

    IF zuiDecl.getType().getType() == Zui.TypeEnum.eLAMBDA
      # LAMBDA: get the argument and return types from destType.
      Zui.MethodType zuiMethod = zuiDecl.getType().getMethodDecl()
      getLambdaArgTypes(expr, zuiMethod, destType, ctx)
    }

    # Generate the method.
    MethodType method = generateMethod(zuiDecl, ctx, TRUE, NIL, NIL)

    IF method != NIL
      IF exprExt.decl == NIL
        # Generate a reference to the method and return it.  Do this once and
        # keep it, so that we can mark it as used.
        exprExt.decl = Declaration.NEW(method.name)
        exprExt.decl.type = method.getMethodRef()
        exprExt.decl.pName = method.pName
        exprExt.decl.zuiPos = expr.getPos()
        exprExt.decl.addDependsOn(method)
      ELSEIF method.ttype == Type.Enum.func
                               && exprExt.decl.type.ttype == Type.Enum.procRef
        # For a LAMBDA the return type may be detected later, correct the
        # reference type to the method type, it may change from proc to func.
        exprExt.decl.type.ttype = Type.Enum.funcRef
      }
    }
    IF exprExt.decl != NIL
      generateMethodUse(&exprExt.undefined, method, exprExt.decl, ctx)
    }

    exprExt.undefined += ZuiDeclarationExt.get(zuiDecl).undefined

    RETURN exprExt.decl?.type
  }

  PROC generateMethodUse(int &undef,
                            MethodType method, Declaration decl, SContext ctx)
    IF method.hasUseArguments()
      # Need to create a closure with the extra arguments.
      generateClosureRef(undef, TRUE, NIL, NIL, NIL, method, method, ctx)
      ctx.addUsedItem(method)
    ELSE
      ctx.gen.namelessFuncUse(decl, ctx)
    }
  }

  FUNC generateTypespec(Zui.Expression expr, SContext ctx) Type
    SymUse symUse = NEW(expr.getPos(), ctx)
    Type ret = generateDeclType(expr, ctx, dotI + markUsed, symUse)
    IF ret == NIL && ctx.doError()
      symUse.doError = TRUE
      ret = generateDeclType(expr, ctx, dotI + markUsed, symUse)
    }
    RETURN ret
  }

  FUNC generateTypecast(Zui.Expression expr, SContext ctx) Type
    Zui.Expression nameExpr = expr.getTypecast().getName()
    SymUse symUse = NEW(nameExpr.getPos(), ctx)
    Type typeType = generateDeclType(nameExpr,
                                   ctx.copyNoOut(), isDecl + markUsed, symUse)
    Type ret
    IF typeType == NIL
      IF ctx.doError()
        symUse.doError = TRUE
        typeType = generateDeclType(nameExpr, ctx, isDecl + markUsed, symUse)
      }
      ret = NIL
    ELSE
      ret = genExpr(expr.getLeft(), ctx,
                                      typeType.getEffType().getValueType(ctx))
      IF typeType ISA TypedefType
        # The expression is generated with the typedef'ed type, but the result
        # is the typedef type itself.
        ret = typeType
      }
    }
    ZuiExpressionExt.get(expr).undefined =
                                      ZuiExpressionExt.get(nameExpr).undefined
                              + ZuiExpressionExt.get(expr.getLeft()).undefined
    RETURN ret
  }

  # Generate a method that possibly has a template.
  FUNC generateMethodWithTemplate(Zui.Statement stmt, SContext ctx) int
    Zui.Declaration zuiDecl = stmt.getDeclaration()
    Zui.MethodType method = zuiDecl.getType().getMethodDecl()
    VAR declExt = ZuiDeclarationExt.get(zuiDecl)

    IF !method.hasTemplateTypeName()
      # No template, generate directly.
      generateMethod(zuiDecl, ctx, FALSE, NIL, NIL)
      RETURN declExt.undefined
    }

    # Check the method name here to get an error once instead of for each type
    # it's generated with.
    string baseName = checkMethodName(zuiDecl, FALSE, ctx)
    IF baseName == NIL
      RETURN 0
    }

    # Add the method to the scope, so that it can be used with different types.
    Zui.TypeEnum typeEnum = zuiDecl.getType().getType()
    Scope scope = ctx.scope
    Declaration methodDecl
    MethodType methodType
    IF declExt.decl == NIL
      # First round, add a method Declaration.
      methodType = MethodType.createFromTypeEnum(typeEnum, zuiDecl.getName())
      methodDecl = methodType
      methodDecl.type = methodType
      scope.addTypeDecl(methodDecl, zuiDecl, TRUE, ctx)
      methodType.templateList = NEW()

      VAR names = getTemplateTypeNames(method.getTemplateTypeNameList(), ctx)
      IF names == NIL
        RETURN 99  # error in names
      }
      methodType.templateNames = names

      declExt.decl = methodDecl

      # The scope is only used to set needPass when the template is used.
      methodType.scope = NEW(scope, [])
    ELSE
      # Second round, re-use the symbol created in the first round.
      methodDecl = declExt.decl
      methodType = methodDecl.type
      IF !scope.isForwardDeclare()
        # Not re-using the scope, need to define the class again
        scope.addMember(methodDecl)
      }
    }
    methodDecl.setAttributes(zuiDecl, ctx)
    methodType.zuiAttr = zuiDecl.getType().getAttr()

    # Add the arguments so that we can use them when searching for a matching
    # function.  When a template type name is used the argument type will be
    # Zui.TypeEnum.unknown.
    # Don't report undefined counts here.
    bool saveReportUndef = reportUndef
    reportUndef = FALSE
    generateMethodArgs(methodType, method, NIL, FALSE, ctx.copyNoOut())
    reportUndef = saveReportUndef

    int undef

    # Generate the method for each combination of types in the template.
    FOR template IN methodType.templateList
      IF template.zuiDecl == NIL
        # Make a recursive copy of method, so that typeObj in each branch can
        # be used.
        string name = zuiDecl.getName() .. "__t" .. template.name

        # Make a recursive copy of the declaration.
        template.zuiDecl = zuiDecl.copy(TRUE)
        template.zuiDecl.setName(name)
      }
      generateMethod(template.zuiDecl, ctx, FALSE, template, NIL)
      VAR templDeclExt = ZuiDeclarationExt.get(template.zuiDecl)
      undef += templDeclExt.undefined
      # The generated method depends on the templated method.
      templDeclExt.decl.addDependsOn(declExt.decl)
    }

    RETURN undef
  }

  # Templated method |type| is used with |arglist| arguments.  When seen before
  # return a type for the actual method.  Otherwise add a template entry.
  # Types in |arglist| and |returnType| are used to figure out the template
  # types.
  # |pos| is where the method is used.
  FUNC findMethodTemplate(Type type, list<Declaration.C> arglist,
                               Type returnType, Zui.Position pos, SContext ctx
                         ) Declaration
   MethodType symType = type
   list<Declaration.C> symArgList = symType.getArgList()
   IF symArgList.Size() != arglist.Size()
      ctx.error("INTERNAL: member list size mismatch; expected "
          .. symArgList.Size() .. " got " .. arglist.Size(), symType.zuiDecl)
      RETURN NIL
    }

    # Make a list of the type specs, so that we can fill in the actual type
    # when we find them.
    list<Declaration> types = NEW()
    FOR name IN symType.templateNames
      Declaration.C decl = NEW(name)
      decl.type = Type.anUnknown
      decl.zuiDecl = NEW()
      types.add(decl)
    }

    status status = OK

    # Go over all the arguments and check if it uses a template type name.
    # If it does use the type from the arglist entry.
    Zui.MethodType method = symType.zuiDecl.getType().getMethodDecl()
    int idx
    FOR arg IN method.getArgumentList()
      Type t = arglist[idx].type
      IF t.ttype == Type.Enum.natval || t.ttype == Type.Enum.intval
        # When using a number argument we assume the template uses int.
        t = Type.anInt
      }
      findTemplateType(arg.getType().getName(), t, types, ctx, &status)
      ++idx
    }
    IF method.hasReturnType() && returnType != NIL
      Type t = returnType
      IF t.ttype == Type.Enum.natval || t.ttype == Type.Enum.intval
        # When using a number argument we assume the template uses int.
        t = Type.anInt
      }
      findTemplateType(method.getReturnType(0).getName(), t, types,
                                                                 ctx, &status)
    }

    FOR t IN types
      IF t.type.getTtype() == Type.Enum.unknown
        IF ctx.doError()
          ctx.error("Type for " .. t.name .. " unknown", symType.zuiDecl)
          IF pos != NIL
            ctx.error("Called from here", pos)
          }
        }
        status = FAIL
      }
    }

    Declaration ret
    IF status == OK
      # See if we have added this combination of types already.
      bool found
      FOR template IN symType.templateList
        IF Declaration.typeListMatch(template.decls, types, ctx)
          IF template.zuiDecl != NIL
            ret = ZuiDeclarationExt.get(template.zuiDecl).decl
          }
          found = TRUE
          BREAK
        }
      }

      IF !found
        # Not seen this combination of types before.  Add it to the class, the
        # next time it's encountered it will create the classSym.
        Template template = NEW(types)
        symType.templateList.add(template)
        template.name = "" .. symType.templateList.Size()
        template.firstUsePos = pos

        # Make sure the method gets another pass so that it can be generated
        # with the new template.
        symType.scope.setNeedPass(ctx)
      }
    }

    RETURN ret
  }

  # Recursively use the type of an argument and check if it is using a
  # template type name.  If so, and the type is defined, use it for the
  # template type.
  # |expr| is the item with the argument type in the templated method.
  # |argType| is the used argument type, the actual method argument
  # |types| is the list of template type names.  At first all types are
  # unknown, the types are filled in when encountered.
  # TODO: support more type constructs
  PROC findTemplateType(Zui.Expression expr, Type argType,
                      list<Declaration> types, SContext ctx, status &status)
    IF argType == NIL
      RETURN
    }
    IF expr.getType() == Zui.ExprType.eID
      string name = expr.getId().getName()
      FOR d IN types
        IF d.name == name
          IF argType != NIL && argType.getTtype() != Type.Enum.unknown
            IF d.type.getTtype() == Type.Enum.unknown
              # Replace the "unknown" type with the type that was used.
              d.type = argType
            ELSEIF ctx.doError() && !Type.compatibleTypes(d.type, argType, ctx)
              ctx.error("Inconsistent types for " .. name .. ": "
                  .. argType.typeName() .. " vs. " .. d.type.typeName(), expr)
              status = FAIL
            }
          }
        }
      }
    ELSEIF expr.getType() == Zui.ExprType.eTYPESPEC
      # check the type name: Titem<int>
      findTemplateType(expr.getLeft(), argType, types, ctx, status)

      IF expr.hasTypespec()
        # check the typespec arguments: list<Titem>
        int idx
        FOR type IN expr.getTypespecList()
          Zui.Expression typeName = type.getName()
          findTemplateType(typeName, argType.getTypespecType(idx),
                                                           types, ctx, status)
          ++idx
        }
      }
    ELSEIF argType.getTtype() == Type.Enum.unknown
      IF ctx.doError()
        ctx.error("Unknown type in template", argType.zuiDecl)
      }
      status = FAIL
    }
  }

  # Generate left == right, where both are an object of the same class:
  # turns into a method call: left.Equal(right)
  # Also for left > right, using left.Compare(right).
  PROC generateEqualCall(Zui.Expression expr, bool isCompare, SContext ctx)
    Zui.MethodCall call
    IF expr.hasCall()
      call = expr.getCall()
    ELSE
      # Create a MethodCall for "left.Equal(right)"
      call = NEW()
      call.setPos(expr.getPos())
      Zui.Expression name = call.newName().setType(Zui.ExprType.eMEMBER)
      name.newRight().setType(Zui.ExprType.eID).newId()
           .setName(isCompare ? "Compare" : "Equal")
      name.setLeft(expr.getLeft())
      call.addArgument(expr.getRight())
      expr.setCall(call)
    }

    generateCall(call, NIL, ctx, isCompare ? Type.anInt : Type.aBool)
    ZuiExpressionExt.get(expr).undefined = ZuiMethodCallExt.get(call).undefined
  }

  # Find the Compare function for |type|.
  FUNC findCompare(Type type, SContext ctx) Declaration
    ClassScope scope = type.getClassType(ctx).scope
    list<Declaration.C> argList = NEW()
    Declaration.C arg = NEW("")
    arg.type = type
    arg.zuiDecl = NEW()
    argList.add(arg)
    int undef
    Declaration ret = scope.findMatchingFunc("Compare", TRUE, &undef, argList,
                           NIL, searchParent + skipAbstract + skipShared, ctx)

    IF ret != NIL && type.getTtype() == Type.Enum.iobject
      # Need to generate an intermediate function, which is passed to sort(),
      # that figures out the actual function to call.
      IF type.compareWrapper == NIL
        type.compareWrapper = NEW("Compare")
        type.compareWrapper.pName =
                         WriteCommon.getUid(ctx.scope.ToString() .. "/Compare")
        type.compareFunc = ret
      }
      ret = type.compareWrapper
    }

    RETURN ret
  }

  # Information returned by functions that generate a call.  When present the
  # code generation produces the arguments for a callback and fill in
  # CallbackInfo with information about the method.
  CLASS CallbackInfo @items=public
    MethodType          $methodType
    list<Declaration.C> $arguments
    CallbackType        $callback
  }

  # Generate a function call for |call|.
  # Use |destType| as a hint for the destination type.
  # When |cbInfo| is not NIL produce arguments for a callback and fill in
  # information about the function.
  # Put the number of undefined symbols in |call.undefined|.
  # Note: This may call us back recursively, e.g. for foo(bar()).
  # Return the type of the result.
  FUNC generateCall(Zui.MethodCall call, CallbackInfo cbInfo,
                                          SContext ctx, Declaration dest) Type
    Type ret
    Type destType = dest?.type
    VAR callExt = ZuiMethodCallExt.get(call)
    IF destType == NIL
      ret = Type.anUnknown
    ELSEIF destType.getTtype() == Type.Enum.class
      ret = destType.getValueType(ctx)
    ELSE
      ret = destType
    }
    callExt.undefined = 0

    Zui.Expression nameExpr = call.getName()
    IF nameExpr.getType() == Zui.ExprType.eID
      # "method(arg)"
      ret = generateMethodCall(call, cbInfo, ret, ctx, destType)
    ELSEIF nameExpr.getType() == Zui.ExprType.eMEMBER
      # "foo.method(arg)"
      string memberName = nameExpr.getRight().getId().getName()
      IF memberName == "NEW"
        int undef
        # Pass "dest" itself, needed for not allocated objects.
        ret = generateNewCall(&undef,
                                   call, nameExpr.getLeft(), ctx, FALSE, dest)
        callExt.undefined += undef
        IF cbInfo != NIL
          ctx.error("Not yet supported for DEFER (NEW)", nameExpr)
        }
        RETURN ret
      }
      # "object.member.method(arg)"
      # "module.method(arg)"
      ret = generateMemberCall(call, cbInfo, ctx, destType)
    ELSEIF nameExpr.getType() == Zui.ExprType.eEXPRMETHOD
      # "object.member.(expr)(arg)"
      IF nameExpr.hasDotnil() && nameExpr.getDotnil()
        ctx.error("Sorry, ?. not implemented yet for expr method.", nameExpr)
      }
      ret = ctx.gen.memberExpr(call, cbInfo, ctx, destType)
    ELSEIF nameExpr.getType() == Zui.ExprType.eLAMBDA
      # Define a lambda function and call it right away:
      # "{ => expr }(args)"
      bool isProc = destType == NIL || destType.getTtype() == Type.Enum.unknown
      MethodType mtype = NEW(isProc ? Type.Enum.proc : Type.Enum.func,
                                                                    "closure")
      mtype.arguments = getDeclListFromArguments(call.getArgumentList(),
                                                       ctx.copyNoOut(), FALSE)
      mtype.returnType = destType
      Type funcDestType = mtype.getMethodRef()
      Declaration methodDecl = generateLambdaExpr(nameExpr, ctx, funcDestType)
      ret = ctx.gen.functionRefCall(call, methodDecl, NIL, destType, ctx)
      IF cbInfo != NIL
        ctx.error("Not yet supported for DEFER (lambda)", nameExpr)
      }
    ELSE
      ctx.error("Cannot call a method here", nameExpr)
    }
    RETURN ret
  }

  # Generate a method call for a Module or SHARED method of a class.
  FUNC generateModuleCall(Type moduleType, Zui.MethodCall call,
                              CallbackInfo cbInfo, SContext ctx, Type destType
                        ) Type
    Type ret
    Zui.Expression nameExpr = call.getName()
    string methodName = nameExpr.getRight().getId().getName()
    VAR callExt = ZuiMethodCallExt.get(call)
    callExt.undefined = 0

    IF methodName == "Type"
      IF call.hasArgument()
        ctx.error("Type() does not take arguments", call.getPos())
      ELSE
        IF moduleType ISA ModuleType
          ctx.gen.callModuleType(moduleType, ctx)
        ELSE
          ctx.gen.callClassType(moduleType, ctx)
        }
        ret = Type.aType
      }
      IF cbInfo != NIL
        ctx.error("Not yet supported for DEFER (module.Type)", nameExpr)
      }
    ELSE
      int undef
      Declaration symDecl = findMethod(moduleType, methodName, FALSE,
                                     call, ctx, FALSE, searchParent,
                                     ctx.doError(), "", &undef)
      Type symType = symDecl?.type
      callExt.undefined += undef
      IF symType == NIL
        callExt.undefined += 1
        IF ctx.doError()
          ctx.error(moduleType.typeName() .. " member not found: "
                                                      .. methodName, nameExpr)
        }
      ELSEIF symType.getTtype() == Type.Enum.func
                                       || symType.getTtype() == Type.Enum.proc
        ret = generateFunctionCall(symDecl, call, cbInfo, ctx, destType)
      ELSE
        ret = generateBuiltinMethodCall(symDecl, call, cbInfo, ctx)
      }
    }
    RETURN ret
  }

  FUNC generateIncDec(Zui.Statement stmt, SContext ctx) int
    Output out = ctx.out             # normal generate output
    Scope scope = ctx.scope
    Zui.Expression expr = stmt.getExpr()  # what is being in/decremented

    ctx.gen.beforeStatement(stmt, ctx)

    out.writeIndent(scope.depth)
    IF stmt.getType() == Zui.StatementType.eINC
      out.write("++(")
    ELSE
      out.write("--(")
    }
    Declaration decl = generateLVarname(expr, TRUE, ctx, Type.anInt)
    out.write(")")
    ctx.gen.statementLineEnd(out)
    IF isArg(expr, ctx)
      ctx.error("++/-- for argument not allowed", stmt)
    ELSEIF decl?.type != NIL && !decl.type.isNumberType()
      ctx.error("Expected a number type", stmt)
    }
    RETURN ZuiExpressionExt.get(expr).undefined
  }

  # Return TRUE if |expr| is an argument name.
  FUNC isArg(Zui.Expression expr, SContext ctx) bool
    IF expr.getType() == Zui.ExprType.eID
      # Using the argument name directly.
      Declaration decl = ctx.scope.getDecl(expr.getId(), NIL)
      IF decl != NIL && decl.pName[0] == 'A'
        RETURN TRUE
      }
    }

    IF expr.getType() == Zui.ExprType.eMEMBER
      # Using a member of an argument that is a bits type.
      Zui.Expression lhs = expr.getLeft()
      IF lhs.getType() == Zui.ExprType.eID
        Declaration decl = ctx.scope.getDecl(lhs.getId(), NIL)
        IF decl != NIL && decl.pName[0] == 'A'
                               && decl.type?.getTtype() == Type.Enum.bitsValue
          RETURN TRUE
        }
      }
    }

    RETURN FALSE
  }

  # var = expr, var += expr, var -= expr, var ..= expr
  # Return number of undefined symbols.
  FUNC generateAssign(Zui.Statement stmt, SContext ctx) int
    Output out = ctx.out             # normal generate output
    Scope scope = ctx.scope
    Resolve gen = ctx.gen
    int undef
    Zui.Assignment assign = stmt.getAssign()
    Zui.Expression lhs = assign.getLhs()
    Zui.Expression rhs = assign.getRhs()
    VAR rhsExt = ZuiExpressionExt.get(rhs)

    gen.beforeStatement(stmt, ctx)

    # b ..= "hello" for varByteString and varString uses a function call.
    IF assign.hasType() && assign.getType() == Zui.ExprType.eCONCAT
      Declaration decl = generateLVarname(lhs, TRUE, ctx.copyNoOut(), NIL)
      IF decl != NIL && decl.type != NIL
                && (decl.type.getTtype() == Type.Enum.varByteString
                 || decl.type.getTtype() == Type.Enum.varString)
        RETURN gen.varStringConcatAssign(assign, ctx)
      }
    }

    IF lhs.getType() == Zui.ExprType.eLIST
      # a, b = tupleExpr
      # a, b = multiReturnfunction()
      # a, b = b, a
      list<LhsEntry> lhsList = NEW()
      FOR e IN lhs.getListItemList()
        lhsList.add(genOneLhs(e, &undef, ctx))
      }

      IF assign.hasType()
        ctx.error("this assignment not supported", stmt)
      ELSE
        IF ctx.out.writing
          IF rhsExt.resultType == NIL
            IF ctx.doError()
              ctx.error("Unknown type", rhs)
            }
          ELSEIF rhsExt.resultType.getTtype() == Type.Enum.tuple
              || rhsExt.resultType.getTtype() == Type.Enum.multiple
            string tmpName
            IF rhs.getType() == Zui.ExprType.eLIST
              #   a, b = b, a
              # generated as
              #   t.a1 = b
              #   t.a2 = a
              #   a = t.a1
              #   b = t.a2
              FOR i IN 0 UNTIL lhsList.Size()
                LhsEntry e = lhsList[i]
                Zui.Expression expr = rhs.getListItem(i)
                out.writeIndent(scope.depth)
                gen.multiReturnItem(rhsExt.tempDecl, i, expr.getPos(),
                                                                 ctx.out, ctx)
                out.write(" = ")
                genExprDoConv(expr, ctx, e.type)
                gen.statementLineEnd(ctx.out)
              }
            ELSEIF rhsExt.tempDecl != NIL
              #   a, b = multiReturnfunction()
              #   a, b = tupleExpr
              # for other expr generated as:
              #   t = tupleExpr | multiReturnfunction()
              #   a = t.a
              #   b = t.b
              tmpName = rhsExt.tempDecl.pName
              out.writeIndent(scope.depth)
              genExpr(rhs, ctx)
              gen.statementLineEnd(ctx.out)
            ELSE
              #   a, b = tupleExpr
              # For simple tuple expr generated as:
              #   a = tupleExpr.a
              #   b = tupleExpr.b
              Output nameOut = NEW()
              nameOut.writing = TRUE
              genExpr(rhs, ctx.copy(nameOut))
              tmpName = nameOut.ToString()
            }

            FOR i IN 0 UNTIL lhsList.Size()
              LhsEntry e = lhsList[i]
              out.writeIndent(scope.depth)
              out.write(e.varname)
              out.write(" = ")
              IF rhsExt.resultType.getTtype() == Type.Enum.tuple
                gen.tupleItem(tmpName, i, e.pos, ctx)
              ELSE
                MultipleType mt = rhsExt.resultType
                Output exprOut = NEW()
                exprOut.writing = TRUE
                gen.multiReturnItem(rhsExt.tempDecl, i, e.pos, exprOut, ctx)

                # Generate a conversion when needed.
                ExprArg ea = NEW(e.type, FALSE)
                Zui.Expression expr = mt.getExpr(i)
                expr.setPos(e.pos)
                Type type = gen.conversion(expr, mt.getType(i).type,
                                                             exprOut, ctx, ea)
                Type.matchingTypesCheck(type, e.type, e.pos, ctx)
              }
              gen.statementLineEnd(out)
            }
          ELSE
            IF ctx.doError()
              ctx.error("Type mismatch; expected " .. lhsList.Size()
                       .. " types, got " .. rhsExt.resultType.typeName(), rhs)
            }
          }
        ELSE
          # Not writing, only need to evaluate the rhs expression.
          IF rhs.getType() == Zui.ExprType.eLIST
            # a, b = b, a: evaluate each expression separately.
            list<Declaration> typeList = NEW()
            FOR i IN 0 UNTIL lhsList.Size()
              LhsEntry e = lhsList[i]
              Zui.Expression expr = rhs.getListItem(i)
              Type t = genExprDoConv(expr, ctx, e.type)
              typeList.add(Declaration.NEW("", t))
              undef += ZuiExpressionExt.get(expr).undefined
            }
            rhsExt.resultType = MultipleType.NEW(typeList, "mult")
          ELSE
            Type type = genExpr(rhs, ctx)
            undef += rhsExt.undefined
            IF type.getTtype() == Type.Enum.multiple
              # Check each assignment for possible implicit conversion.
              MultipleType mt = type.getEffType()
              FOR i IN 0 UNTIL lhsList.Size()
                LhsEntry e = lhsList[i]
                ExprArg ea = NEW(e.type, FALSE)
                Zui.Expression expr = mt.getExpr(i)
                expr.setPos(e.pos)
                gen.conversion(expr, mt.getType(i).type, NIL, ctx, ea)
              }
            ELSEIF type.getTtype() != Type.Enum.tuple
              undef += 10
            }
          }
        }

      }
    ELSE
      # lhs = rhs
      LhsEntry lhsEntry = genOneLhs(lhs, &undef, ctx)
      Type lhsType = lhsEntry.type
      Declaration lhsDecl = lhsEntry.decl
      IF lhsEntry.toplevelVar != NIL
        rhsExt.toplevelVar = lhsEntry.toplevelVar
      }

      bool toInterface
      IF lhsType?.getTtype() == Type.Enum.iobject
        # The expression can either be of the same type or an object that
        # matches the interface.  If it's not the same type we need to
        # assign to the pointer field and set the type.
        # Pass the declaration for the type, needed for not allocated objects.
        Type t = genExpr(rhs, ctx.copyNoOut(), lhsDecl)
        IF t != NIL && t.getTtype() != Type.Enum.iobject
                                                 && t.getClassType(ctx) != NIL
          toInterface = TRUE
        }
      }

      out.writeIndent(scope.depth)
      string close = ""

      # For a not allocated variable a function is called, no assignment.
      IF lhsType != NIL && !lhsType.isNoAlloc()
        out.write(lhsEntry.varname)

        bool lhsOnRhs
        IF !assign.hasType()
          out.write(" = ")
        ELSE
          SWITCH assign.getType()
            CASE Zui.ExprType.eSUBTRACT
                IF lhsType != NIL && lhsType.isNumberType()
                  out.write(" -= ")
                ELSE
                  # Turn into lhs = lhs - {expr}
                  lhsOnRhs = TRUE
                }
            CASE Zui.ExprType.eADD
                IF lhsType != NIL && lhsType.isNumberType()
                  out.write(" += ")
                ELSE
                  # Turn into lhs = lhs + {expr}
                  lhsOnRhs = TRUE
                }
            CASE Zui.ExprType.eMULTIPLY
                IF lhsType != NIL && lhsType.isNumberType()
                  out.write(" *= ")
                ELSE
                  # Turn into lhs = lhs + {expr}
                  lhsOnRhs = TRUE
                }
            CASE Zui.ExprType.eDIVIDE
                IF lhsType != NIL && lhsType.isNumberType()
                  out.write(" /= ")
                ELSE
                  # Turn into lhs = lhs + {expr}
                  lhsOnRhs = TRUE
                }
            CASE Zui.ExprType.eCONCAT
                IF lhsType != NIL && (lhsType.getTtype() == Type.Enum.string
                                || lhsType.getTtype() == Type.Enum.byteString)
                  close = gen.stringConcat(lhs, NIL, ctx)
                  undef += ZuiExpressionExt.get(lhs).undefined
                ELSE
                  # Turn into lhs = lhs .. {expr}
                  lhsOnRhs = TRUE
                }
            DEFAULT
                ctx.internalError("Unknown assign type: "
                                .. assign.getType().ToString(), stmt.getPos())
          }
        }

        IF lhsOnRhs
          # TODO: this is not right if Lhs has side effects.
          # E.g. array[i++] += 8
          out.write(" = ")
          Zui.Expression newRhs = NEW()
          newRhs.setType(assign.getType())
          newRhs.setLeft(lhs)
          newRhs.setRight(rhs)
          newRhs.setPos(rhs.getPos())
          rhs = newRhs
          rhsExt = ZuiExpressionExt.get(rhs)
        }
      }

      Type exprType
      IF lhsType != NIL
        IF lhsType.getTtype() == Type.Enum.var
          # First assignment for VAR variable
          Type r = genExpr(rhs, ctx)
          IF !Type.typeDefined(r) || rhsExt.undefined != 0
            undef++
            IF ctx.doError()
              ctx.error("Cannot determine type for VAR variable "
                                                         .. lhsDecl.name, rhs)
            }
            LOG.verbose("\(lhsDecl.name) VAR type not detected")
            lhsType = Type.anUnknown
          ELSE
            lhsDecl.type = r
            IF r.ttype == Type.Enum.natval || r.ttype == Type.Enum.intval
              # For "x = 1" use type int.
              lhsDecl.type = Type.anInt
            }
            lhsType = lhsDecl.type
          }
        ELSEIF lhsType.getTtype() == Type.Enum.bitsValue
                                                  && lhsDecl.bitsMember != NIL
          # Assignment to a BITS field.
          undef += gen.bitsAssign(lhs, rhs, lhsDecl.bitsMember, ctx)
        ELSEIF lhsType.getTtype() == Type.Enum.iobject
          # The expression can either be of the same type or an object that
          # matches the interface.
          IF toInterface
            # Write type cast to reference, if needed.
            # TODO: more specific type cast useful?
            gen.refCast(ctx)
            exprType = genExpr(rhs, ctx)
          ELSE
            # Pass the declaration itself, NEW() may need the variable name.
            genTopExprDoConv(rhs, ctx, lhsDecl)
          }
        ELSEIF lhsType.getTtype() == Type.Enum.byRef
          genTopExprDoConv(rhs, ctx,
                                lhsType.<ReferenceType.C>.getReferencedType())
        ELSEIF lhsType.isNoAlloc()
          # Pass the declaration itself, NEW() may need the variable name.
          genTopExprDoConv(rhs, ctx, lhsDecl)
        ELSE
          genTopExprDoConv(rhs, ctx, lhsType)
        }

        # Check for a valid RHS when assigning to a not allocated variable.
        checkNoAllocAssign(lhsType, rhs, ctx)

        undef += rhsExt.undefined

        out.write(close)
      }

      IF lhsType != NIL && lhsType.getClassType(ctx) != NIL
                       && exprType != NIL && exprType.getClassType(ctx) != NIL
        undef += gen.iobjectType(lhs, lhsType, exprType, ctx)

      }
      gen.statementLineEnd(ctx.out)
    }

    RETURN undef
  }

  # Check that an assignment to a variable on stack uses NEW()
  # Everything else is not allowed.
  PROC checkNoAllocAssign(Type type, Zui.Expression rhs, SContext ctx)
    IF type.isNoAlloc()
      IF rhs.getType() == Zui.ExprType.eNIL
        # Assigning NIL is OK.
        RETURN
      }

      IF rhs.getType() == Zui.ExprType.eCALL
        Zui.Expression nameExpr = rhs.getMethodCall().getName()
        IF nameExpr.getType() == Zui.ExprType.eMEMBER
                             && nameExpr.getRight().getId().getName() == "NEW"
          # SomeModule.SomeClass.NEW() is OK.
          RETURN
        }
      }

      IF type.getTtype() == Type.Enum.iobject
        # Assigning to an iobject means filling in the "ptr" field, which is
        # OK even when the iobject is not allocated.
        RETURN
      }

      IF rhs.getType() != Zui.ExprType.eNEWCALL
                        && rhs.getType() != Zui.ExprType.eLIST
                        && rhs.getType() != Zui.ExprType.eDICT
                        && !((type.getTtype() == Type.Enum.varString
                                || type.getTtype() == Type.Enum.varByteString)
                               && rhs.getType() == Zui.ExprType.eSTRING)
        ctx.error("Cannot assign to not allocated variable", rhs)
      }
    }
  }

  CLASS LhsEntry
    string       $varname      # what goes before the "="
    Type         $type
    Declaration  $decl
    string       $toplevelVar
    Zui.Position $pos
  }

  # Handle one lhs of an assignment.
  FUNC genOneLhs(Zui.Expression lhs, int &undef, SContext ctx) LhsEntry
    LhsEntry entry = NEW()
    Output varnameOut = NEW()
    varnameOut.writing = ctx.out.writing
    SContext varnameCtx = ctx.copy(varnameOut)
    entry.decl = generateLVarname(lhs, TRUE, varnameCtx, NIL)
    undef += ZuiExpressionExt.get(lhs).undefined
    entry.varname = varnameOut.ToString()
    entry.pos = lhs.getPos()
    bool isNoAlloc
    IF entry.decl != NIL
      # Only check for variable names to be on the stack, entry.decl can be a
      # type returned by a function that happens to have the name of an
      # existing variable, e.g. "Titem".
      isNoAlloc = lhs.getType() == Zui.ExprType.eID
                                            && ctx.scope.isNoAlloc(entry.decl)
      IF isNoAlloc && ctx.scope.inTry()
        # May need to add "volatile" to the declaration.
        entry.decl.isUsedInTry = TRUE
      }
      IF lhs.getType() == Zui.ExprType.eID && !lhs.getId().getDollar()
        # Can use the name directly.
        entry.toplevelVar = entry.decl.pName
      }

      entry.type = entry.decl.type
      IF entry.type != NIL && isArg(lhs, ctx)
        ctx.error("Assignment to argument not allowed", lhs)
      }
      IF entry.type != NIL && entry.type.getTtype() == Type.Enum.class
        ctx.error("Cannot assign to a class "
                      .. "(declaration with the variable name missing?)", lhs)
      }
    }

    IF entry.type == NIL || entry.type.getTtype() == Type.Enum.unknown
      ++undef
      IF ctx.doError()
        ctx.error("Destination type unknown", lhs)
      }
    }

    RETURN entry
  }

  # Check that |id| and |type| either both have % or neither.
  # |expr| is used for the position in the error message.
  PROC checkPercentMatch(Zui.Id id, Type type, Zui.Expression expr,
                                                                 SContext ctx)
    IF id.getPercent() != type.isNoAlloc()
      ctx.error(id.getPercent() ? "% unexpected" : "Missing %", expr)
    }
  }

  FUNC isInitName(string name) bool
    RETURN name == "Init" || name.startsWith("Init__")
  }

  CLASS StandardMethodInfo
    bool             $objectMethod
    Type.Enum        $returnType   # use nil for a PROC
    list<Type.Enum>  $arguments    # use unknown if any type is OK
    int              $optional     # nr of arguments that are optional

    NEW(bool objectMethod,
             Type.Enum returnType,
             list<Type.Enum> arguments,
             int optional)
      $objectMethod = objectMethod
      $returnType = returnType
      $arguments = arguments
      $optional = optional
    }
  }

  # Init is not here, because it can be PROC $Init() or FUNC Init().
  dict<string, StandardMethodInfo> %standardMethods = [
      "Compare": NEW(TRUE, Type.Enum.int, [Type.Enum.unknown], 0),
      "EarlyInit": NEW(FALSE, Type.Enum.status, [], 0),
      "Equal": NEW(TRUE, Type.Enum.bool, [Type.Enum.unknown], 0),
      "Finish": NEW(TRUE, Type.Enum.status, [Type.Enum.enumValue], 1),
      "FromString": NEW(TRUE, Type.Enum.enumValue, [Type.Enum.string], 0),
      "Iterator": NEW(TRUE, Type.Enum.iobject, [], 0),
      "KeyIterator": NEW(TRUE, Type.Enum.iobject, [], 0),
      "Size": NEW(TRUE, Type.Enum.int, [], 0),
      "ToString": NEW(TRUE, Type.Enum.string, [Type.Enum.string], 1),
      "Type": NEW(TRUE, Type.Enum.type, [], 0),
      ]

  # Maps the method name to a list with min and max argument count.
  dict<string, list<int>> %predefMethodArgs = [
      "Compare": [1, 1],
      "Equal": [1, 1],
      "FromString": [1, 1],
      "Iterator": [0, 0],
      "KeyIterator": [0, 0],
      "Size": [0, 0],
      "ToString": [0, 1],
      "Type": [0, 0],
      ]

  # Generate a method.
  # When |nameless| is TRUE this is for a nameless method used in an
  # expression.
  # |template| is NIL when the method has no template.
  # |useDecl| is an existing declaration to use when not NIL, for generating a
  # method in a class that comes from a parent class.
  # Return the declaration of the method.
  FUNC generateMethod(Zui.Declaration zuiDecl, SContext ctx,
                       bool nameless, Template template, Declaration useDecl
                     ) Declaration
    Zui.MethodType method = zuiDecl.getType().getMethodDecl()
    VAR methodExt = ZuiMethodTypeExt.get(method)
    Zui.Attributes attr = zuiDecl.getType().getAttr()
    Zui.TypeEnum typeEnum = zuiDecl.getType().getType()
    string name = zuiDecl.getName()

    # Main() is handled separately
    IF name == "Main"
      generateMain(zuiDecl, ctx)
      RETURN NIL
    }

    IF attr.getAbstract() && method.hasBody()
      ctx.error("Abstract method cannot have statements", zuiDecl)
    }

    Output   out = ctx.out             # normal generate output
    int      undef
    Resolve  gen = ctx.gen
    Scope    scope = ctx.scope
    bool     isBuiltinMethod = scope ISA ModuleScope
                                                && scope.<ModuleScope>.builtin
    bool isNew = (typeEnum == Zui.TypeEnum.eNEW)
    bool isInit = isInitName(name) && scope.isTopClassScope()
    string baseName = checkMethodName(zuiDecl, nameless, ctx)
    IF baseName == NIL
      RETURN NIL
    }

    list<MethodType.C> otherMethods = NEW()
    Declaration methodDecl
    MethodType methodType
    VAR declExt = ZuiDeclarationExt.get(zuiDecl)
    IF scope.pass <= 1 || declExt.decl == NIL
      # Get here in the first pass: Create a symbol for the method.
      # Also in a later pass, when a nameless method was defined in a nested
      # way or a new template was encountered.
      # NOTE: this depends on addDecl ordering, getDecl() must return the
      # last added symbol with the same name.
      int identNumber
      Declaration prevDecl = scope.getDecl(name,
                              zuiDecl.getDollar(), NEW(zuiDecl.getPos(), ctx))
      IF prevDecl != NIL
        # Allow PROC and FUNC with the same name.
        IF prevDecl.type.getTtype() != Type.Enum.builtinMethod
            && (prevDecl.type.getTtype() == Type.Enum.new)
                                            != (typeEnum == Zui.TypeEnum.eNEW)
          ctx.error("Method \"" .. name .. "\" redefined as "
                                         .. prevDecl.type.typeName(), zuiDecl)
          IF prevDecl.zuiDecl != NIL
            ctx.error("Previous definition here", prevDecl.zuiDecl)
          }
        ELSEIF prevDecl.type ISNOTA MethodType
          ctx.error("\"" .. name .. "\" already declared", zuiDecl)
          IF prevDecl.zuiDecl != NIL
            ctx.error("Previously declared as " .. prevDecl.type.typeName(),
                                                             prevDecl.zuiDecl)
          }
        ELSE
          # Defining another method with this name, use a different identifier.
          # However, when redefining a method from a parent class (abstract or
          # default) with the same signature we need to use the same
          # identifier, this is corrected below.
          # Because of that the method found may not have the highest number,
          # go over all methods to find the max.
          MethodType.C otherMethod = prevDecl.type.<MethodType.C>
          identNumber = otherMethod.identNumber + 1
          otherMethods.add(otherMethod)

          IF scope.pass >= 1 && scope ISA ClassScope && scope.classType != NIL
            ClassScope cs = scope.<ClassScope.C>
            IF cs.objectMembers != NIL
              list<Declaration> mlist = cs.objectMembers.get(name, NIL)
              IF mlist != NIL
                int max
                FOR m IN mlist
                  IF m.type ISA MethodType
                    MethodType.C mtype = m.type.<MethodType.C>
                    IF max < mtype.identNumber
                      max = mtype.identNumber
                    }
                    otherMethods.add(mtype)
                  }
                }
                IF identNumber <= max
                  identNumber = max + 1
                }
              }
            }
          }
        }
      }

      IF useDecl != NIL
        methodDecl = useDecl
        methodType = methodDecl.type
      ELSE
        methodType = MethodType.createFromTypeEnum(typeEnum, name)
        methodDecl = methodType
        scope.addTypeDecl(methodDecl, zuiDecl, TRUE, ctx)
      }
      methodType.identNumber = identNumber
      IF declExt.decl == NIL
        declExt.decl = methodDecl
        declExt.typeObj = methodType
      }
      undef += 99  # always do one more pass, because identNumber may change
                   # TODO: how can we know that a matching method in the
                   # parent is defined properly?
    ELSE
      methodDecl = declExt.decl
      methodType = methodDecl.type
      IF !scope.isForwardDeclare()
        # Not re-using the scope, need to define the method again.
        scope.addTypeDecl(methodDecl, zuiDecl, TRUE, ctx)
      }
      IF skip_zero_undefined && !gen.writing
            && methodExt.scope != NIL
            && !methodExt.scope.needPass
            && declExt.undefined == 0
        # No need to process this method again
        # When the scope is NIL (abstract method) we always do a pass because
        # the argument types may have changed.
        RETURN methodDecl
      }

      IF gen.writing && skipUnused() && !gen.isDeclUsed(methodDecl)
        # This method is not used from Main().
        RETURN methodDecl
      }
    }
    int prevUndef = declExt.undefined

    methodDecl.setAttributes(zuiDecl, ctx)
    methodType.zuiAttr = attr
    IF attr.hasVisibility()
                          && attr.getVisibility() == Zui.Visibility.ePROTECTED
                                                     && scope.classType == NIL
      ctx.error("@protected not allowed, not inside a class", zuiDecl)
    }

    methodType.parentLevel = declExt.parentLevel
    methodType.defined = TRUE

    # Set the name of the method in the output.
    setMethodOutputName(methodDecl, scope)

    MethodScope funcScope
    IF !attr.getAbstract()
      IF methodExt.scope == NIL
        funcScope = NEW(scope, method.hasBody()
                                   ? method.getBody().getStatementList() : [])
        IF methodType.identNumber == 0
          funcScope.name = name .. "()"
        ELSE
          funcScope.name = name .. "/" .. methodType.identNumber .. "()"
        }
        funcScope.scopeName = methodDecl.pName
        funcScope.scopeType = Scope.Stype.procDef
        funcScope.methodScope = funcScope
        funcScope.noBacktrace = attr.getNoBacktrace()
        funcScope.wantBacktrace = attr.getWantBacktrace()
        funcScope.primitive = attr.getPrimitive()
        funcScope.notOnExit = attr.getNotOnExit()
        funcScope.outerDecl = methodDecl
        methodExt.scope = funcScope
        methodType.scope = funcScope

        IF name == "Finish" && scope.classType != NIL
          addFinishDependencies(methodDecl, scope.classType)
          funcScope.flags.insideFinish = TRUE
        }
      ELSE
        funcScope = methodExt.scope
        funcScope.initPass(scope)

        # For a class method the scope may be different in a child class.
        funcScope.outer = scope
      }

      IF template != NIL
        # For a templated method: Add type specifications from the template to
        # the scope.  This is done every pass, in case the type is resolved.
        FOR decl IN template.decls
          funcScope.addMember(decl)
        }
      }
    }

    # If the function signature of the other functions change we need to come
    # back here.
    FOR otherMethod IN otherMethods
      otherMethod.addUser(funcScope == NIL ? scope : funcScope)
    }

    # We need to be able to define a function inside a function.  To avoid
    # problems with nesting, we write the function declaration and body to
    # a separate output and append it all at once to the actual
    # declaration and body out.
    # First part is written to function declarations in the file.
    # First and second part are written to function body in the file.
    Output funcOut
    IF attr.getAbstract()
      # We don't write anything for an abstract method.
      funcOut = Output.noOut
    ELSE
      funcOut = NEW()
      funcOut.writing = out.writing
    }
    SContext funcOutCtx = ctx.copy(funcOut)
    IF funcScope != NIL
      funcOutCtx.scope = funcScope
    }

    declExt.undefined = 0

    # Generate the stack frame offset table.  Always goes to the body out.
    IF funcOutCtx.out.writing
      Output leaderOut = ctx.outs.origBodyOut ?: ctx.outs.bodyOut
      gen.methodLeader(methodType, leaderOut, funcOutCtx)
    }

    Type retType
    IF zuiDecl.getType().getType() == Zui.TypeEnum.eLAMBDA
      IF method.hasReturnType()
        # Get the actual return type from the first return type, that's where
        # getLambdaArgTypes() puts it.
        retType = ZuiTypeExt.get(method.getReturnType(0)).typeObj
      }
      ctx.gen.vartype(retType, TRUE, zuiDecl.getPos(), funcOutCtx)

      # Correct the method type based on the return type.
      methodType.ttype = retType == NIL ? Type.Enum.proc : Type.Enum.func
    ELSE
      retType = gen.methodReturnType(zuiDecl, isNew, isInit, funcOutCtx)
      IF retType == NIL && method.hasReturnType()
        undef++
        IF ctx.doError()
          ctx.error("Unknown return type",
                                  method.getReturnType(0).getName().getPos())
        }
        methodType.defined = FALSE
        retType = Type.anUnknown
      }
    }
    # If the return type is a class we return an object of that class.
    IF retType != NIL
      IF funcScope != NIL && (undef == 0 || usedWhenUndefined)
        # Mark the return type as used by this method.
        funcScope.addUsedItem(retType)
      }
      retType = retType.getValueType(funcOutCtx)
      methodType.returnType = retType
    }

    gen.methodStart(methodDecl, methodType.hasAnyArguments(), funcOutCtx)

    StandardMethodInfo methodInfo = %standardMethods.get(baseName, NIL)
    IF methodInfo != NIL
      IF methodInfo.returnType == Type.Enum.nilval
        IF retType != NIL
          ctx.error(name .. " must not return anything", zuiDecl)
        }
      ELSEIF ctx.doError()
        IF retType == NIL || retType.getTtype() != methodInfo.returnType
          ctx.error(name .. " must return " .. methodInfo.returnType.ToString(),
                                                                      zuiDecl)
        }
      }
    }

    IF name == "Init"
      IF scope.isClassScope()
                          && zuiDecl.getType().getType() != Zui.TypeEnum.ePROC
        ctx.error("Init() must be a PROC", zuiDecl)
      }
      IF !scope.isClassScope()
                 && (retType == NIL || retType.getTtype() != Type.Enum.status)
        ctx.error("Init() must return status, not "
                .. (retType == NIL ? "unknown" : retType.typeName()), zuiDecl)
      }
    }

    # Generate function arguments and add them to the function scope.
    undef += generateMethodArgs(methodType, method, funcScope, undef == 0,
                                                                   funcOutCtx)

    # Generate USE arguments.
    undef += generateMethodUseArgs(methodType, method, funcScope, undef == 0,
                                                              ctx, funcOutCtx)

    # Now that return type and argument types are set the (new) function
    # signature can be computed.
    methodType.setSignature(ctx)

    # Check arguments for predefined methods.
    list<Declaration.C> argList = methodType.getArgList()

    # A builtin module method has an extra "this" argument.
    list<Declaration.C> checkArgList = argList
    IF isBuiltinMethod && argList.Size() >= 1 && argList[0].name == "this"
      checkArgList = argList.slice(1)
    }

    # Check the properties of predefined methods.
    IF methodInfo != NIL
      int expected = methodInfo.arguments.Size()
      int optional = methodInfo.optional
      IF checkArgList.Size() > expected
                                  || checkArgList.Size() < expected - optional
        IF expected == 0
          ctx.error(name .. " must have no arguments", zuiDecl)
        ELSEIF expected == 1 && optional == 1
          ctx.error(name .. " must have no or one argument", zuiDecl)
        ELSEIF optional > 0
          ctx.error(name .. " must have " .. (expected - optional)
                               .. " to " .. expected .. " arguments", zuiDecl)
        ELSEIF expected == 1
          ctx.error(name .. " must have one argument", zuiDecl)
        ELSE
          ctx.error(name .. " must have " .. expected .. " arguments", zuiDecl)
        }
      }
      IF ctx.doError() && !isBuiltinMethod
        # Check argument types.
        IF (baseName == "Equal" || baseName == "Compare")
          IF checkArgList[0].type.getTtype() != Type.Enum.object
                       && checkArgList[0].type.getTtype() != Type.Enum.iobject
            ctx.error(name .. " argument must be an object", zuiDecl)
          ELSEIF checkArgList[0].type.getClassType(ctx).childIndex(
                                                 scope.classType, FALSE) == -1
            # The argument must be equal to the class or a parent of the
            # class.
            ctx.error(name .. " argument is "
                          .. checkArgList[0].type.getClassType(ctx).typeName()
                .. ", expected " .. scope.classType.typeName(), zuiDecl)
          }
        ELSE
          FOR ai IN 0 UNTIL expected
            IF ai < checkArgList.Size()
              && (checkArgList[ai] == NIL
               || checkArgList[ai].type.getTtype() != methodInfo.arguments[ai])
              ctx.error("Expected " .. methodInfo.arguments[ai].ToString()
                  .. " but found " .. (checkArgList[ai] == NIL ? "unknown"
                                      : checkArgList[ai].typeName()), zuiDecl)
            }
          }
          IF name == "Finish" && checkArgList.Size() == 1
                              && checkArgList[0].type.getTypeName(ctx)
                                        != Builtin.getFinishReasonType().pName
              ctx.error("Expected Z.FinishReason but found "
                              .. checkArgList[0].type.typeToString(), zuiDecl)
          }
        }
      }
    ELSEIF name == "Init"
      IF checkArgList != NIL && checkArgList.Size() != 0
        ctx.error(name .. "() must not have an argument", zuiDecl)
      }
    }

    # If dyn == dyn or dyn.Equal() is used then $Equal() in every class must
    # be marked as used.
    IF zuiDecl.getDollar() && name == "Equal"
      Declaration.dynEqual.addDependsOn(methodDecl)
    }
    # If dyn == dyn or dyn.Compare() is used then $Compare() in every class
    # must be marked as used.
    IF zuiDecl.getDollar() && name == "Compare"
      Declaration.dynCompare.addDependsOn(methodDecl)
      Declaration.dynEqual.addDependsOn(methodDecl)
    }
    # If dyn.Size() is used then $Size() in every class must be marked as
    # used.
    IF zuiDecl.getDollar() && name == "Size"
      Declaration.dynSize.addDependsOn(methodDecl)
    }

    IF scope.pass >= 1 && scope ISA ClassScope && scope.classType != NIL
      ClassScope cs = scope.<ClassScope.C>

      # If all the arguments are defined now, while previously there were
      # undefined items, need to go through virtual functions that may find
      # this function as matching now.
      IF undef == 0 && prevUndef != 0
        cs.setNeedPassInDependencies(ctx)
        FOR itf IN scope.classType.interfaces
          ClassType itfClass = itf.type.getClassType(ctx)
          IF itfClass != NIL
            itfClass.scope.setNeedPassInDependencies(ctx)
          }
        }
      }

      # Find another method with the same name and matching arguments.
      Type other
      WHILE TRUE
        MethodType.Skip skip = NEW(methodDecl)
        skip.skipWhenFound = FALSE
        Declaration otherDecl = scope.findMatchingFunc(
                                            name, zuiDecl.getDollar(), &undef,
                                              argList, skip,
                                              onlyDefined + methodArgs, ctx)
        other = otherDecl?.type
        MethodType otherMethod = other
        IF other != NIL && otherMethod.parentLevel > 0
          # Method defined in this class replaces one inherited from the
          # parent class, remove the inherited one.
          IF ctx.doError() && !Type.matchingTypes(
                           otherMethod.returnType, methodType.returnType, ctx)
            ctx.error("Return type does not match with parent method", zuiDecl)
            ctx.error("Location of parent method", otherDecl.zuiDecl)
          }
          IF zuiDecl.getDollar()
            # Remove the inherited method in this class.
            cs.removeObjectMember(other)

            # Remove the inherited method from child classes that made a copy.
            FOR ct IN otherMethod.childMethodClasses
              FOR dl IN ct.scope.objectMembers.values()
                FOR d IN dl
                  IF d ISA MethodType
                    MethodType parentMethod = d.<MethodType>.parentMethod
                    IF parentMethod IS otherMethod
                                   || parentMethod IS otherMethod.parentMethod
                      ct.removeObjectMember(d)
                    }
                  }
                }
              }
            }
          ELSE
            cs.removeMember(other)
          }
          CONTINUE  # need to search for any other match
        }
        BREAK
      }

      string errorMsg
      string errorMsgOther
      Declaration otherDecl
      IF other != NIL
        # Method is redefined in the same scope.  Don't report if there
        # already was an error defining the method.
        IF other.defined && methodType.defined
          errorMsg = "Redefining " .. name .. "() with same signature"
        }
        undef += 3
      ELSEIF isInit
        IF ctx.doError() && (methodType.zuiAttr.getReplace()
                          || methodType.zuiAttr.getDefine()
                          || methodType.zuiAttr.getIsdefault())
          ctx.error("$Init() does not take attributes", zuiDecl)
        }
      ELSEIF scope.classType != NIL
        # check if method is already defined in a parent class
        ClassType parent = scope.classType
        bool foundOther
        WHILE TRUE
          parent = parent.parent
          IF parent == NIL
            BREAK
          }

          # Function prototypes may still change if the class isn't fully
          # defined.
          IF parent.zuiDecl != NIL
                        && ZuiDeclarationExt.get(parent.zuiDecl).undefined > 0
            undef += 17
          }

          otherDecl = parent.findMatchingMethod(name, zuiDecl.getDollar(),
                                        argList, NIL, methodArgs, &undef, ctx)
          IF otherDecl != NIL
            foundOther = TRUE
            Type otherType = otherDecl.type
            MethodType otherSymType = otherType.<MethodType.C>

            # If the function signature of the other function changes we
            # need to come back here.
            otherSymType.addUser(funcScope)

            IF otherType.zuiAttr.getIsdefault()
                                           && !methodType.zuiAttr.getReplace()
              errorMsg = "Replacing default method "
                                       .. name .. " without @replace"
              errorMsgOther = "Previously defined method is here"
            ELSEIF otherType.isAbstract() && !methodType.zuiAttr.getDefine()
              errorMsg = "Defining abstract method "
                                        .. name .. " without @define"
              errorMsgOther = "Previously defined method is here"
            ELSEIF !otherType.isAbstract() && !otherType.zuiAttr.getIsdefault()
              errorMsg = "Cannot redefine " .. name
              errorMsgOther = "Previously defined method does not have "
                                          .. "@abstract or @default attribute"
            ELSEIF otherType.getTtype() != methodType.getTtype()
              errorMsg = "Cannot redefine " .. otherType.typeName()
                                         .. " with " .. methodType.typeName()
            ELSEIF otherType.getTtype() == Type.Enum.func
                  && otherSymType.returnType != NIL
                  && methodType.returnType != NIL
                  && !Type.matchingTypes(otherSymType.returnType,
                                                   methodType.returnType, ctx)
              errorMsg = "Expected return type "
                      ..  otherSymType.returnType.typeName()
                      .. " but found "
                      .. methodType.returnType.typeName()
            ELSEIF methodType.identNumber != otherSymType.identNumber
              # Redefining a parent method, re-use its identifier.  This is
              # required for Javascript.
              methodType.identNumber = otherSymType.identNumber
              IF !scope.flags.isParentMethod
                methodDecl.pName = NIL  # force getting a new pName
              }
              setMethodOutputName(methodDecl, scope)
              IF out.writing
                ctx.internalError("method index changed after methodStart()",
                                                  zuiDecl.getPos())
                ctx.internalError("Other method found: " .. otherDecl.name,
                                                             otherDecl.zuiPos)
              }

              # It's possible we already have a method with this identNumber.
              # If so, change it.
              list<Declaration> mlist = cs.objectMembers.get(name, NIL)
              IF mlist != NIL
                Declaration.C found
                int max
                FOR m IN mlist
                  IF m.type ISA MethodType
                    MethodType mtype = m.type.<MethodType.C>
                    IF mtype.identNumber > max
                      max = mtype.identNumber
                    }
                    IF mtype ISNOT methodType && m.pName == methodDecl.pName
                      IF found != NIL
                        ctx.internalError("found a second one: " .. m.pName,
                                                                 found.zuiPos)
                      }
                      found = m
                    }
                  }
                }
                IF found != NIL
                  found.type.<MethodType.C>.identNumber = max + 1
                  setMethodOutputName(found, scope)
                }
              }

            }
            BREAK
          }
        }
        IF !foundOther && methodType.zuiAttr.getReplace()
          errorMsg = "method " .. name
                            .. " has @replace but does not replace any method"
        }
      }
      IF errorMsg != NIL
        IF ctx.doError()
          ctx.error(errorMsg, zuiDecl)
          IF errorMsgOther != NIL
            ctx.error(errorMsgOther, otherDecl.zuiDecl)
          }
        ELSE
          ++undef
        }
      }
    ELSEIF ctx.doError()
      # Check for defining a method not in class scope.  Includes the SHARED
      # scope of a class.
      MethodType.Skip skip = NEW(methodDecl)
      Declaration otherDecl = scope.findMatchingFunc(
                                 name, zuiDecl.getDollar(), &undef,
                                 argList, skip,
                                 onlyDefined + searchParent + methodArgs, ctx)
      IF otherDecl != NIL
        # Method is redefined in this scope or another visible scope.  Don't
        # report if there already was an error defining the method.
        ctx.error("Redefining " .. name .. " with the same signature", zuiDecl)
        ctx.error("Other method is here", otherDecl.zuiPos)
        # Avoid giving the error twice.
        methodType.defined = FALSE
      }
    }

    # Generate the method body
    # There is no function body for an abstract method.
    # For C we don't produce methods for an abstract class.  But do produce it
    # when there were undefined items, indicating an error.
    # When resolving we need to go in here in case the code is produced for
    # JS.
    IF !(attr.getAbstract()
          || (gen.skipAbstractMethod()
              && scope.isClassScope()
              && scope.classType.isAbstract()
              && prevUndef == 0))
      undef += generateMethodBody(method, zuiDecl.getPos(), methodType, NIL,
                                                   funcScope, funcOutCtx, ctx)
    }

    # used in generateParentMethod()
    declExt.undefined = undef

    # produce callbacks for this method
    generateMethodCallbacks(methodType, zuiDecl.getPos(),
                                                      &declExt.undefined, ctx)

    RETURN methodDecl
  }

  # Check the function name to be valid.
  # Return the base name, without __t1 and __p1 added for templates and parent
  # methods.
  # Returns NIL if there is an error.
  FUNC checkMethodName(Zui.Declaration zuiDecl, bool nameless, SContext ctx
                      ) string
    string name = zuiDecl.getName()
    string baseName = name
    int tailIdx = name.find("__p")
    IF tailIdx < 0
      tailIdx = name.find("__t")
    }
    IF tailIdx > 0
      baseName = name.slice(0, tailIdx - 1)
    }

    # NEW() is different, it is a PROC and returns THIS.
    Zui.TypeEnum typeEnum = zuiDecl.getType().getType()
    bool isNew = (typeEnum == Zui.TypeEnum.eNEW)
    IF isNew
      IF !ctx.scope.isTopClassScope()
        ctx.error(name .. " not in a class scope", zuiDecl)
        RETURN NIL
      }
    ELSEIF %standardMethods.has(baseName)
      StandardMethodInfo methodInfo = %standardMethods[baseName]
      IF methodInfo.returnType == Type.Enum.nilval
                                             && typeEnum != Zui.TypeEnum.ePROC
        ctx.error(baseName .. " must be a PROC", zuiDecl)
      ELSEIF typeEnum != Zui.TypeEnum.eFUNC
        ctx.error(baseName .. " must be a FUNC", zuiDecl)
      }
      IF ctx.scope.isTopClassScope()
        IF !methodInfo.objectMethod
          ctx.error(baseName .. " must be in the SHARED section", zuiDecl)
        ELSEIF !zuiDecl.getDollar()
          ctx.error("Missing $", zuiDecl)
        }
      ELSEIF !(ctx.scope ISA ModuleScope && ctx.scope.<ModuleScope>.builtin)
        IF methodInfo.objectMethod
          ctx.error(baseName .. " must be outside of the SHARED section",
                                                                      zuiDecl)
        ELSEIF zuiDecl.getDollar()
          ctx.error("Cannot use $ here", zuiDecl)
        }
      }
    ELSEIF name == "Init"
      IF ctx.scope.isTopClassScope()
        IF !zuiDecl.getDollar()
          ctx.error("Missing $ or Init() must be in SHARED section", zuiDecl)
        }
      ELSE
        IF zuiDecl.getDollar()
          ctx.error("Cannot use $Init() here", zuiDecl)
        }
      }
    ELSE
      # Check the name and appropriate use of $.  Not for a method added by
      # generateParentMethod()
      IF ZuiDeclarationExt.get(zuiDecl).parentLevel == 0
        IF !nameless
          checkItemName(zuiDecl, typeEnum == Zui.TypeEnum.ePROC
                                                       ? "proc" : "func", ctx)
        }
        IF zuiDecl.getDollar()
          IF !ctx.scope.isTopClassScope()
            IF ctx.scope.flags.insideShared
              ctx.error("Cannot use $name() in SHARED section", zuiDecl)
            ELSE
              ctx.error("Cannot use $name() outside of class scope", zuiDecl)
            }
            RETURN NIL
          }
        ELSE
          IF ctx.scope.isTopClassScope()
            ctx.error("Missing $; must use $name() in class scope", zuiDecl)
            RETURN NIL
          }
        }
      }
    }

    RETURN baseName
  }

  PROC generateMethodCallbacks(MethodType methodType,
                                   Zui.Position pos, int &undef, SContext ctx)
    IF methodType.callback != NIL
      # The method is used in an expression, a callback is filled in.
      # Declare the structure to store the info and produce an alloc function.
      CallbackType callback = methodType.callback
      callback.arguments = NEW()
      FOR arg IN methodType.useArguments
        callback.addArgument(arg)
      }
      FOR arg IN methodType.autoArguments
        callback.addArgument(arg)
      }
      callback.scopeBase = methodType.scopeBase
      setCalledMethodType(callback, ctx)
      ctx.gen.writeCallbackDecl(callback, pos, ctx)
      ctx.addUsedItem(Declaration.funcRef)
    }

    # If there are USE arguments and the method is called directly we need a
    # callback.  The USE argument values are taken where the method is defined
    # (right here).  This also uses methodType.callback as generated above.
    IF methodType.callbackStmt != NIL
      Zui.Declaration callbackZuiDecl = methodType.callbackStmt.getDeclaration()
      Declaration.C callbackDecl = ZuiDeclarationExt.get(callbackZuiDecl).decl
      CallbackType type = callbackDecl.type
      IF callbackDecl.pName == NIL
        callbackDecl.pName = WriteCommon.getUid(ctx.scope.ToString() .. "+cb")
        callbackDecl.zuiPos = pos
        callbackDecl.scopeBase = ctx.scope

        # Set items used in gen.declaration().
        callbackZuiDecl.setPos(pos)
        Zui.Expression init = callbackZuiDecl.newInit()
        init.setPos(pos)
        ZuiExpressionExt.get(init).decl = methodType
      }
      IF ctx.scope.isClassScope()
        # Add callback to the object
        ctx.scope.classType.addOwnMemberInit(callbackZuiDecl)
        ctx.gen.declaration(callbackDecl, callbackDecl.type,
                              methodType.callbackStmt, FALSE, NIL, FALSE, ctx)
      ELSEIF !ctx.scope.isInitVar()
        ctx.error("Cannot define a method with USE here", pos)
      ELSE
        mayPutDeclInMethodScope(callbackDecl, ctx)

        # Declare the callback in the current scope. Use an init with the alloc
        # function to create and fill the struct.
        Output exprOut = NEW(NEW())
        exprOut.writing = ctx.out.writing
        ctx.gen.writeClosureAlloc(type, methodType, FALSE, undef,
                                                            ctx.copy(exprOut))
        ctx.gen.declaration(callbackDecl, callbackDecl.type,
                          methodType.callbackStmt, FALSE, exprOut, FALSE, ctx)
      }
      ctx.addUsedItem(Declaration.funcRef)
      ctx.addUsedItem(type.calledMethodType)
    }
  }

  # Return a $Init() method in |scope| that is not an empty default method.
  FUNC findUsefulInit(Scope scope) Declaration
    IF scope == NIL
      RETURN NIL
    }
    Declaration fake
    FOR decl IN Declaration.findAll(scope.getObjectDeclDict(), "Init")
      IF !decl.fake
        # A $Init() defined in the class.
        RETURN decl
      }
      IF decl.type.getTtype() == Type.Enum.proc && decl.type.defined
        # A fake $Init() with contents
        fake = decl
      }
    }
    RETURN fake
  }

  # Return the name of a Finish() method if the |scope| has one.
  # NIL otherwise.
  FUNC getFinishMethod(Scope scope, SContext ctx) Declaration
    IF scope == NIL
      RETURN NIL
    }
    Declaration decl = Declaration.find(scope.getObjectDeclDict(), "Finish")
    IF decl != NIL
      # When @notOnExit then hasFinish depends on GC.run()
      IF decl.type.<MethodType>.scope?.notOnExit
        Declaration.hasFinish.addDependsOn(Declaration.gcRun)
      ELSE
        ctx.addUsedItem(Declaration.hasFinish)
      }
    }
    RETURN decl
  }

  # Mark the Finish method |methodDecl| is used inside the class of the scope.
  PROC addFinishDependencies(Declaration methodDecl, ClassType classType)
    # Always mark Finish() as used if the class and hasFinish is used.
    classType.addDependsOnCond(methodDecl, Declaration.hasFinish)
    # When calling Finish the equivalent of TRY is added.
    methodDecl.addDependsOnCond(Declaration.try, Declaration.hasFinish)
    # When an exception is thrown it is written to stderr.
    methodDecl.addDependsOn(DeclStore.getDecl("MEModule", "FwriteToStderr"))
  }

  # Generate the method body.  Shared between a normal method and a closure.
  # Only a closure has |expr| set.
  FUNC generateMethodBody(Zui.MethodType zuiMethod, Zui.Position pos,
                          MethodType method, Zui.Expression expr,
                          MethodScope funcScope, SContext funcOutCtx,
                          SContext ctx
                         ) int
    Output funcOut = funcOutCtx.out
    Resolve gen = ctx.gen
    bool isNew = method.name == "NEW" || method.name.startsWith("NEW__")
    bool isInit = isInitName(method.name) && ctx.scope.isClassScope()
    funcOutCtx.scope = funcScope

    string methodName = method.name
    IF ctx.scope.scopeName != NIL
      methodName = ctx.scope.scopeName .. "." .. methodName
    }

    # Here we split up the declaration and the implementation.
    # The declaration is only needed for C, not for JS.
    IF funcOut.writing && gen.doWriteDecl() && funcOut ISNOT Output.noOut
      ctx.outs.declOut.append(funcOut)
      ctx.outs.declOut.write("); /* \(methodName) */\n")
    }

    funcOut.write(") {")
    IF !gen.doWriteDecl()
      # For JS add a comment with the function name.
      funcOut.write(" // \(methodName)")
    }
    funcOut.write("\n")

    int undef
    list<Zui.Statement> statements
    IF expr == NIL && zuiMethod.hasBody()
      statements = zuiMethod.getBody().getStatementList()
    }
    IF expr != NIL || (statements != NIL && statements.Size() > 0)
                                                            || isNew || isInit
      funcScope.depth = 1
      IF method.returnType != NIL
        funcScope.returnType = method.returnType
      }
      funcScope.flags.insideNew = isNew
      funcScope.flags.insideInit = isInit
      # No THIS in a closure.
      funcScope.thisName = expr != NIL ? NIL : gen.thisName(isNew || isInit)

      # Generated code is written to ctx.outs.bodyOut.  Create a new output
      # and append it later, so that variable declarations go first.
      # Set origBodyOut so that nested methods and classes are written to the
      # toplevel.
      Output.Group newOuts = ctx.outs.startNewBlock()
      IF newOuts.origBodyOut == NIL
        newOuts.origBodyOut = ctx.outs.bodyOut
      }
      newOuts.varOut = funcOut
      SContext funcCtx = NEW(ctx.topScope, funcScope, ctx.gen, newOuts)
      funcCtx.out.writing = ctx.out.writing

      gen.methodBodyStart(method, isNew, isInit, pos, funcCtx)
      IF isNew
        # Create a new object when not passed in.
        # When there is a $Init() method use that.
        Declaration initDecl = findUsefulInit(ctx.scope)
        IF initDecl != NIL
          method.addDependsOn(initDecl)
        }
        gen.writeNewThis(method, initDecl, getFinishMethod(ctx.scope, ctx),
                                                                 pos, funcCtx)
      }

      IF expr != NIL
        # Defining a closure, generate the expression.
        VAR exprExt = ZuiExpressionExt.get(expr)
        gen.returnBefore(method.returnType == NIL, FALSE, funcCtx)
        exprExt.toplevelVar = "r"
        genExpr(expr, funcCtx, funcScope.returnType)
        undef = exprExt.undefined
        gen.statementLineEnd(funcCtx.out)
      ELSE
        IF zuiMethod.hasBody() || isInit
          # Defining a method, generate a list of statements.
          IF isInit
            # For $Init() produce the statements of $Init() methods in parent
            # classes and object member inits.
            undef = generateObjectInit(ctx.scope.classType, TRUE, funcCtx)
          }

          # Produce the statements, unless it is $Init() coming from the
          # parent.
          IF zuiMethod.hasBody() && !method.name.startsWith("Init__")
            undef += generate(statements, funcCtx)
          }

          IF undef == 0
            # Symbols used in this block are also used in the containing scope.
            ctx.addUsedScope(funcScope)
          }
        }
      }

      newOuts.endNewBlock()

      IF funcScope.wantBacktrace && funcScope.outer != NIL
        funcScope.outer.wantBacktrace = TRUE
      }

      Zui.Position retPos = pos
      IF statements != NIL && statements.Size() > 0
        retPos = statements[-1].getPos()
      }
      IF isNew || isInit
        gen.writeScopeEnd(TRUE, TRUE, NIL, pos, funcOutCtx)
        gen.writeNewReturn(retPos, funcOutCtx)
      ELSEIF expr != NIL
        # return for a closure.
        gen.returnAfter(method.returnType, TRUE, retPos, funcOutCtx)
      ELSE
        bool needReturn
        IF zuiMethod.hasReturnType()
          # Need a return statement if there isn't one at the end already.
          needReturn = !checkMethodHasReturn(zuiMethod, pos, ctx)
        ELSE
          # If the last statement is a THROW we never get to the return.
          needReturn = !endsInThrow(statements)
        }
        IF needReturn
          gen.returnAfter(method.returnType,
                          !endsInReturn(statements, TRUE), retPos, funcOutCtx)
        }
      }
    ELSEIF zuiMethod.hasReturnType()
      # Empty method block for a func.
      ctx.error("Missing RETURN", pos)
    }

    funcOut.write("}\n")
    IF ctx.outs.origBodyOut != NIL
      ctx.outs.origBodyOut.append(funcOut)
    ELSE
      ctx.outs.bodyOut.append(funcOut)
    }
    RETURN undef
  }

  # Generate the member inits and statements for an $Init() method in a parent
  # class.
  # When |doOwn| is TRUE also do members owned by the class (not in children).
  FUNC generateObjectInit(ClassType class, bool doOwn, SContext ctx) int
    int undef
    IF class != NIL && class.parent != NIL && class.parent.scope != NIL
      # Depth first: do $Init() of parent's parent.
      ClassType parent = class.parent
      undef = generateObjectInit(parent, FALSE, ctx)

      # Find $Init() in the parent
      Declaration initDecl = findUsefulInit(parent.scope)
      IF initDecl != NIL
        Zui.MethodType method = initDecl.zuiDecl.getType().getMethodDecl()
        IF method.hasBody()
          list<Zui.Statement> statements = method.getBody().getStatementList()
          IF statements != NIL && statements.Size() > 0
            # Annotate Init() that was automatically generated.
            IF ctx.out.writing && initDecl.fake
              Annotator.getProps(statements, ctx)
            }
            undef += generate(statements, ctx)
          }
        }
      }
    }

    undef += generateMemberInits(class, doOwn, ctx)

    RETURN undef
  }

  # Generate the member inits for an $Init() method in |class|.
  # When |doOwn| is TRUE also do members owned by the class (not in children).
  # Return the number of undefined symbols.
  FUNC generateMemberInits(ClassType class, bool doOwn, SContext ctx) int
    int undef
    FOR l IN [class.memberInits, (doOwn ? class.ownMemberInits : NIL)]
      FOR zuiDecl IN l
        Zui.Expression initExpr = zuiDecl.getInit()
        VAR initExprExt = ZuiExpressionExt.get(initExpr)

        # Annotate the statement.
        bool pauseGC
        IF initExprExt.decl != NIL
          pauseGC = TRUE
        ELSEIF ctx.out.writing
          CodeProperties props = Annotator.getProps(zuiDecl.getInit(), ctx)
          pauseGC = props.methodCall || props.allocMem
        }

        Declaration decl = ZuiDeclarationExt.get(zuiDecl).decl
        ctx.gen.beforeStatement(decl.zuiPos, pauseGC, ctx)

        # Get the name of the location to write to.
        Output varnameOut = NEW()
        varnameOut.writing = ctx.out.writing
        SContext varnameCtx = ctx.copy(varnameOut)
        ctx.gen.writeSymName(decl, decl.type, FALSE, varnameCtx)
        string varname = varnameOut.ToString()

        ctx.out.writeIndent(1)
        ctx.out.write(varname)
        ctx.out.write(" = ")

        IF initExprExt.decl != NIL
          # A callback has a fake initExpr where .decl is set to the method
          # for the callback in generateMethodCallbacks().
          ctx.gen.writeClosureAlloc(decl.type, initExprExt.decl,
                                                           FALSE, &undef, ctx)
        ELSE
          genExprDoConv(initExpr, ctx, decl.type.getValueType(ctx))
          undef += initExprExt.undefined
        }
        ctx.gen.statementLineEnd(ctx.out)
      }
    }
    RETURN undef
  }

  # Generate function arguments.  In each round we redo this, because
  # types may have resolved.
  # |methodType| is the symbol for the method.
  # Return the number of undefined items
  FUNC generateMethodArgs(MethodType methodType, Zui.MethodType zuiMethod,
                            MethodScope funcScope, bool markUsed, SContext ctx
                         ) int
    int undef

    # make the argument list empty
    IF methodType.arguments == NIL
      methodType.arguments = NEW()
    ELSE
      methodType.arguments.clear()
    }
    methodType.optionalArgCount = 0

    bool first = TRUE
    VAR argList = zuiMethod.getArgumentList()
    FOR idx IN 0 UNTIL argList.Size()
      VAR arg = argList[idx]
      Zui.Type zuiType = arg.getType()
      VAR zuiTypeExt = ZuiTypeExt.get(zuiType)
      Type argType
      string name = arg.getName()

      argType = generateObjDeclType(zuiType, ctx.copyNoOut())
      undef += zuiTypeExt.undefined

      # funcArgType is the same as argType, except for varargs, then it's an
      # array of argType.
      Type funcArgType = argType

      IF argType == NIL || argType.getTtype() == Type.Enum.unknown
                                                   || zuiTypeExt.undefined > 0
        undef += 10
        LOG.verbose("argument \(name) type undefined")
        IF ctx.doError()
          argType = generateObjDeclType(zuiType, ctx)
          IF argType == NIL || argType.getTtype() == Type.Enum.unknown
            ctx.error("argument " .. name .. " type undefined",
                                                             zuiType.getPos())
          }
        }
        argType = Type.anUnknown
        methodType.defined = FALSE
      ELSEIF argType ISA MethodType
        ctx.error("Cannot use method as a type", zuiType.getPos())
      ELSEIF argType ISA ModuleType
        ctx.error("Cannot use module as a type", zuiType.getPos())
      ELSEIF arg.getThreeDots() && idx == argList.Size() - 1
        # A varargs argument works like tuple<array, array>
        methodType.varargs = TRUE
        IF methodType.varargsTuple == NIL
          funcArgType = TupleType.getVarargsTuple(argType, arg.getPos(), ctx)
          methodType.varargsTuple = funcArgType
        ELSE
          # Update the argument value type.
          funcArgType = methodType.varargsTuple
          funcArgType.<TupleType>.types[1].type.<ContainerType>.itemType =
                                                                       argType
        }
      }
      methodType.addArgument(name, argType, arg)
      IF arg.hasInit()
        ++methodType.optionalArgCount
      }

      IF zuiTypeExt.undefined > 0
        zuiTypeExt.typeObj = Type.anUnknown
      ELSE
        zuiTypeExt.typeObj = argType
      }

      Type extraArgType
      string extraArgName

      # Define the argument in the method scope.  Skip this for an
      # abstract method.
      IF funcScope != NIL
        # Define the var with the actual type
        # Keep it in arg.decl so that it's re-used in later passes.
        Declaration.C decl =
                         funcScope.addDecl(name, funcArgType, arg, FALSE, ctx)
        ZuiDeclarationExt.get(arg).decl = decl

        # The type of the argument is also used (when the function is used)
        # Only do this when in the last pass.
        IF undef == 0 && markUsed
          ctx.addUsedItem(funcArgType)
        }
        string argName
        IF decl.type?.getTtype() == Type.Enum.byRef
          # By-reference args have a different leader, so that we can
          # recognize them and allow writing to them.
          argName = "R" .. name
        ELSE
          argName = "A" .. name
        }
        decl.pName = argName
        decl.isArg = TRUE

        IF argType.getTtype() != Type.Enum.unknown
          ctx.gen.argWithType(first, funcArgType, arg.getPos(), argName, ctx)
          first = FALSE

          IF extraArgName != NIL
            ctx.gen.argWithType(first, extraArgType, arg.getPos(),
                                                            extraArgName, ctx)
          }
        }
      }
    }

    # When Finish() is defined without argument, generate an extra argument so
    # that they can all be called the same way.
    IF methodType.name.startsWith("Finish") && zuiMethod.sizeArgument() == 0
      Type argType = EnumType.NEW(Type.Enum.enum, "fr")
      Zui.Declaration arg = NEW()
      arg.setPos(methodType.zuiPos)
      ctx.gen.argWithType(FALSE, argType, arg.getPos(), "_fr", ctx)
    }

    RETURN undef
  }

  # Generate function USE arguments.  In each round we redo this, because
  # types may have resolved.
  # |symType| is the symbol for the method.
  # Return the number of undefined items
  FUNC generateMethodUseArgs(MethodType symType, Zui.MethodType method,
                             MethodScope funcScope, bool markUsed,
                             SContext ctx, SContext funcCtx
                            ) int
    int undef

    symType.useArguments = NEW()  # no USE arguments yet

    int argIndex
    bool first = symType.arguments.Size() == 0
    FOR arg IN method.getUseList()
      string name
      IF arg.hasName()
        name = arg.getName()  # AS name
      ELSEIF arg.getDotName().getType() == Zui.ExprType.eID
        name = arg.getDotName().getId().getName()
      ELSE
        funcCtx.error("expression must use AS name", arg.getDotName())
        BREAK
      }

      SymUse symUse = NEW(arg.getPos(), ctx)
      Declaration usedDecl = ctx.scope.findExprDecl(arg.getDotName(),
                                                                  ctx, symUse)
      IF usedDecl == NIL
        IF funcCtx.doError()
          funcCtx.error("Cannot find variable", arg.getDotName())
        }
        undef += 8
        CONTINUE
      }
      funcScope.addUsedItem(usedDecl)

      Zui.Type zuiType = arg.getType()
      bool isRef = zuiType.getType() == Zui.TypeEnum.eREF
      IF isRef && !usedDecl.needAlloc && usedDecl.getClass() == NIL
        # For "USE &x" x needs to be allocated, not on the stack.
        # And then we use the one member of the generated class.
        usedDecl.needAlloc = TRUE
        IF Type.typeDefined(usedDecl.type)
          usedDecl.type = usedDecl.type.getAllocType(ctx)
        }
      }

      Declaration argDecl = usedDecl
      IF usedDecl.type ISA MethodType
        argDecl = NEW("refArg")
        argDecl.type = usedDecl.type.<MethodType>.getMethodRef()
        argDecl.pName = usedDecl.pName
      ELSEIF isRef && !usedDecl.type.isAllocType(ctx)
        # The argument is a reference to the original type.
        argDecl = NEW("refArg")
        argDecl.type = usedDecl.type.getRefType()
        argDecl.pName = usedDecl.pName
        argDecl.scopeBase = usedDecl.scopeBase
      }
      symType.useArguments.add(argDecl)

      IF usedDecl.type.isAllocType(ctx)
        # The argument is a reference to the original type.
        argDecl = NEW("refArg")
        argDecl.type = usedDecl.type.getClassType(ctx)
                                                  .allocDecl.type.getRefType()
        argDecl.pName = usedDecl.pName
      }

      # Define the argument in the method scope.
      addUseArg(arg, name, argDecl, undef == 0 && markUsed, isRef,
                                        &first, &argIndex, funcScope, funcCtx)
    }

    # Now do the automatically added USE arguments.  The declaration is a
    # callback, its autoZuiDecl is a dummy to hold the reference to the
    # argument declaration.
    FOR arg IN symType.autoArguments
      IF arg.autoZuiDecl == NIL
        arg.autoZuiDecl = NEW()
        arg.autoZuiDecl.setPos(arg.zuiDecl.getPos())
      }
      # Define the argument in the method scope.
      addUseArg(arg.autoZuiDecl, arg.name, arg, markUsed,
                                  TRUE, &first, &argIndex, funcScope, funcCtx)
    }

    RETURN undef
  }

  PROC addUseArg(Zui.Declaration arg, string name, Declaration argDecl,
                        bool markUsed, bool isRef, bool &first, int &argIndex,
                                      MethodScope funcScope, SContext funcCtx)
    # Skip this for an abstract method.
    IF funcScope != NIL
      # Define the var with the actual type
      # Keep it in arg.decl so that it's re-used in later passes.
      Declaration.C decl = funcScope.addDecl(name, argDecl.type, arg,
                                                              TRUE, funcCtx)
      ZuiDeclarationExt.get(arg).decl = decl

      # The type of the argument is also used (when the function is used)
      # Only do this when in the last pass.
      IF markUsed
        funcCtx.addUsedItem(decl.type)
      }
      string argName
      IF isRef
        # By-reference args have a different leader, so that we can
        # recognize them and allow writing to them.
        argName = "R" .. argIndex
      ELSE
        argName = "A" .. argIndex
      }
      decl.pName = argName
      decl.isArg = TRUE

      IF argDecl.type.getTtype() != Type.Enum.unknown
        funcCtx.gen.argWithType(first, argDecl.type,
                                               arg.getPos(), argName, funcCtx)
      }
      ++argIndex
      first = FALSE
    }
  }

  # Check that the function |method| ends in a RETURN statement.
  # Returns TRUE if there is an actual RETURN at the end, not another
  # statement where each possible alternative ends in a RETURN.
  FUNC checkMethodHasReturn(Zui.MethodType method,
                                          Zui.Position pos, SContext ctx) bool
    list<Zui.Statement> statements
    IF method.hasBody()
      statements = method.getBody().getStatementList()
    }
    IF !endsInReturn(statements, FALSE)
      ctx.error("Missing RETURN", pos)
      RETURN FALSE
    }
    RETURN endsInReturn(statements, TRUE)
  }

  # When |strict| is TRUE only return TRUE if the last statement is a
  # RETURN/EXIT/THROW.
  # When |strict| if FALSE also accept a conditional statement where all
  # alternatives end in RETURN/EXIT/THROW
  # Exception: GENERATE_IF is not considered a conditional statement.
  FUNC endsInReturn(list<Zui.Statement> statements, bool strict) bool
    IF statements == NIL || statements.Size() == 0
      RETURN FALSE
    }
    Zui.Statement stmt = statements[-1]
    SWITCH stmt.getType()
      CASE Zui.StatementType.eRETURN
      CASE Zui.StatementType.eEXIT
      CASE Zui.StatementType.eTHROW
        RETURN TRUE

      CASE Zui.StatementType.eIF
      CASE Zui.StatementType.eIFNIL
        IF strict
          BREAK
        }
        PROCEED
      CASE Zui.StatementType.eGENERATEIF
        Zui.Condition cond = stmt.getCondition()
        IF !endsInReturn(cond.hasBlock()
                          ? cond.getBlock().getStatementList() : NIL, FALSE)
          BREAK
        }
        IF cond.hasElseif()
          FOR elseif IN cond.getElseifList()
            IF !endsInReturn(elseif.hasBlock()
                        ? elseif.getBlock().getStatementList() : NIL, FALSE)
              BREAK
            }
          }
        }
        IF cond.hasElse()
          IF !endsInReturn(cond.getElse().getStatementList(), FALSE)
            BREAK
          }
        ELSE
          BREAK
        }
        RETURN TRUE

      CASE Zui.StatementType.eSWITCH
        IF strict
          BREAK
        }
        # All CASE statements must end in RETURN and there must be a DEFAULT
        # ending in RETURN
        Zui.Condition cond = stmt.getCondition()
        IF cond.hasBlock()
          bool hasDefault
          FOR switchStmt IN cond.getBlock().getStatementList()
            IF switchStmt.hasBlock()
              IF switchStmt.getType() == Zui.StatementType.eDEFAULT
                hasDefault = TRUE
              }
              IF !endsInReturn(switchStmt.getBlock().getStatementList(), FALSE)
                   && !switchStmt.hasProceedPos()
                RETURN FALSE
              }
            }
          }
          IF hasDefault
            RETURN TRUE
          }
        }
    }
    RETURN FALSE
  }

  # Simple check if the last statement is a THROW.
  FUNC endsInThrow(list<Zui.Statement> statements) bool
    RETURN statements != NIL && statements.Size() > 0
                       && statements[-1].getType() == Zui.StatementType.eTHROW
  }

  # Set the name of the method in the output.
  PROC setMethodOutputName(Declaration decl, Scope scope)
    int identNumber = decl.type.<MethodType.C>.identNumber
    IF scope.flags.isParentMethod
      decl.jsMName = decl.name
      IF identNumber > 0
        decl.jsMName ..= "__" .. identNumber
      }
    ELSEIF scope.isClassScope()
      IF decl.pName == NIL
        decl.scopeName = scope.scopeName
        decl.pName = WriteCommon.getUid(scope.ToString() .. "/" .. decl.name)
        # For JS a method is local to the class, use a short name.
        decl.jsMName = decl.name

        string name = decl.name
        IF identNumber > 0
          string extra = "__" .. identNumber
          decl.jsMName ..= extra
          name ..= extra
        }
        # Prepend "M" for Method.  It must be different from F for proc/func
        # in the SHARED section.
        DeclStore.storePName(scope.scopeName ?: "", "M" .. name, decl)

        # Use the C function name for the JavaScript function name.  |pName|
        # may be changed later when producing a child class.
        decl.jsFName = decl.pName
      }
    ELSE
      IF decl.pName == NIL
        decl.scopeName = scope.scopeName
        decl.pName = WriteCommon.getUid(scope.ToString() .. "/" .. decl.name)
        string name = decl.name
        IF identNumber > 0
          string extra = "__" .. identNumber
          name ..= extra
        }

        # Prepend "F" for Func/proc.
        # For a ZWT module init() is called in startup, force storing the
        # name.
        DeclStore.storePName(scope.ToString(), "F" .. name, decl,
                                scope.scopeName != NIL && decl.name == "init")
      }
    }
  }

  # Check if |decl| should be declared at the method scope level.
  # Must only be called after setting pName.
  PROC mayPutDeclInMethodScope(Declaration decl, SContext ctx)
    IF decl.type != NIL
         && (decl.type.isManaged() || decl.type.isNoAlloc())
         && !decl.inMethodScope
      # For reference type variables inside a method, it will be declared
      # at the start of the method so that the mark phase of the garbage
      # collection can find it.
      MethodScope ms = ctx.scope.methodScope
      IF ms != NIL
        IF ms.refVars == NIL
          ms.refVars = NEW(TRUE)
        }
        IF ms.refVars.has(decl.pName)
          int extra = 1
          WHILE ms.refVars.has(decl.pName .. extra)
            ++extra
          }
          decl.pName ..= extra
        }
        ms.refVars[decl.pName] = decl
        decl.inMethodScope = TRUE
      }
    }
  }

  # Add |pName| to the stack frame.
  # Differs from mayPutDeclInMethodScope() above in that the pName is not
  # changed and only to be called at the method level.
  # Used for the return value.
  PROC putRefInMethodScope(string pName, Type type, SContext ctx)
    MethodScope ms = ctx.scope
    IF ms.refVars == NIL
      ms.refVars = NEW(TRUE)
    }
    IF ms.refVars.has(pName)
      # Already added, update the type.
      ms.refVars.get(pName).type = type
    ELSE
      # New item.
      Declaration decl = NEW("ref")
      decl.pName = pName
      decl.type = type
      decl.isArg = TRUE
      ms.refVars[pName] = decl
    }
  }

  # Check |declDict| for arguments which need to be in the stack frame.
  PROC checkRefScope(multiDict<string, Declaration> declDict, SContext ctx)
    FOR l IN declDict.values()
      FOR decl IN l
        IF decl.isArg
          IF decl.type != NIL && decl.type.isManaged()
            # Add the argument to the stack frame.  Not for references,
            # e.g., "int &undef".
            putRefInMethodScope(decl.pName, decl.type, ctx)
          }
        }
      }
    }
  }

  # Generate a member or variable declaration.
  # "Type member = expr", "class.type var", etc.
  FUNC generateDeclare(Zui.Statement stmt, SContext ctx) int
    Output    out = ctx.out             # normal generate output
    int       undef
    Resolve   gen = ctx.gen
    Scope     scope = ctx.scope
    Zui.Declaration zuiDecl = stmt.getDeclaration()
    string    name = zuiDecl.getName()
    bool      useInit = zuiDecl.hasInit()
    bool      isShared = zuiDecl.getShared()

    # Check the name and appropriate use of $.
    checkItemName(zuiDecl, "member", ctx)
    IF zuiDecl.getDollar()
      IF !scope.isTopClassScope()
        # Check being at the class level.
        IF scope.flags.insideShared
          ctx.error("Cannot use $name in SHARED section", stmt)
        ELSE
          ctx.error("Cannot use $name outside of class scope", stmt)
        }
      ELSEIF zuiDecl.hasInit()
        scope.classType.addMemberInit(zuiDecl)
        useInit = FALSE
      }
    ELSE
      # Check not being at the class level.
      IF scope.isTopClassScope()
        ctx.error("Must use $name in class scope", stmt)
      }
    }

    Type typeType
    Zui.Expression typeExpr = zuiDecl.getType().getName()
    VAR typeExprExt = ZuiExpressionExt.get(typeExpr)
    VAR declExt = ZuiDeclarationExt.get(zuiDecl)
    bool varType
    IF typeExpr.getType() == Zui.ExprType.eID
                                        && typeExpr.getId().getName() == "VAR"
      varType = TRUE
      IF declExt.decl == NIL
        typeType = Type.aVar
        undef++
        LOG.verbose("\(name) is a VAR, undefined")
      ELSE
        #  VAR var in second round: use type detected in first round
        #  TODO: should be able to use typeDefined(typeType)
        typeType = declExt.decl.type
        IF !Type.typeDefined(typeType)
          typeType = Type.aVar  # type used below
          declExt.decl.type = typeType
          undef++
          LOG.verbose("\(name) VAR type not yet detected")
          IF ctx.doError()
            ctx.error("Could not determine type for " .. name, typeExpr)
          }
        ELSE
          # Go back from value type to reference type.
          IF typeType.getTtype() == Type.Enum.object
#                                This doesn't work for SomeClass.I
#                                        || typeType.type == Type.Enum.iobject
            typeType = typeType.getClassType(ctx)
          ELSEIF typeType.getTtype() == Type.Enum.enumValue
            typeType = typeType.<EnumValueType.C>.enumType
          ELSEIF typeType.getTtype() == Type.Enum.bitsValue
            typeType = typeType.<BitsValueType.C>.bitsType
          }
        }
      }
    ELSEIF gen.writing && declExt.decl != NIL
                       && declExt.decl.type.getTtype() != Type.Enum.unknown
                       && typeExprExt.undefined == 0
      # Use the type found previously, no need to look in the context.
      typeType = declExt.decl.type
    ELSE
      SymUse symUse = NEW(typeExpr.getPos(), ctx)
      IF gen.writing
        symUse.doError = TRUE
      }

      DeclFlags flags = isDecl + dotI + markUsed
      IF zuiDecl.getPercent()
        flags.noAlloc = TRUE
      }
      typeType = generateDeclType(typeExpr, ctx, flags, symUse)
      undef += typeExprExt.undefined
      IF reportUndef && undef > 0
        ctx.error("generateDeclare() type undef: " .. undef, typeExpr)
      }
      IF declExt.decl != NIL && declExt.decl.needAlloc
        typeType = typeType.getAllocType(ctx)
      }
    }

    IF zuiDecl.getPercent()
      IF !(scope.methodScope != NIL   # inside a method - on stack
          || scope.isSharedScope()    # inside SHARED - static
          || scope ISA ModuleScope    # inside a MODULE - static
          || scope ISA FileScope)     # inside the main file - static
        ctx.error("Cannot use % in this scope", zuiDecl)
      ELSEIF typeType != NIL
        IF typeType.isValueType()
          ctx.error("Cannot use % on a value type", zuiDecl)
        ELSEIF typeType.getTtype() == Type.Enum.string
                                || typeType.getTtype() == Type.Enum.byteString
          ctx.error("Cannot use % on a " .. typeType.getTtype().ToString(),
                                                                      zuiDecl)
        }
      }
    }

    # On first pass type may not be known.  When writing we already gave an
    # error message, use some type to keep the code simple.
    IF typeType == NIL
      typeType = Type.anUnknown
    }

    # Generate the RHS expression before declaring the symbol, so that we get
    # an error for "int b = someFunc(b)".
    bool varTypeUnknown
    Output initExprOut
    Type exprType
    Zui.Expression initExpr
    VAR initExprExt
    IF scope.isInitVar() && useInit
      # "VAR v = expr"  init
      IF typeType.getTtype() == Type.Enum.var
        # Type not known yet.
        # Set type to |Type.unknown|, genExpr doesn't handle |Type.var|
        typeType = Type.anUnknown
        varTypeUnknown = TRUE
      }
      initExpr = zuiDecl.getInit()
      initExprExt = ZuiExpressionExt.get(initExpr)
      initExprExt.undefined = 0
      IF declExt.decl != NIL
        initExprExt.toplevelVar = declExt.decl.pName  # use lhs as a temp var
      }
    }

    Declaration.C decl
    Type valueType = typeType
    SWITCH typeType.getTtype()
      CASE Type.Enum.class
      CASE Type.Enum.classDotC
      CASE Type.Enum.interface
      CASE Type.Enum.enum
      CASE Type.Enum.bits
        # The type of the variable is something we make an instance of.
        valueType = typeType.getValueType(ctx)
        decl = scope.addDecl(name, valueType, zuiDecl, FALSE, ctx)

      CASE Type.Enum.object
      CASE Type.Enum.iobject
      CASE Type.Enum.int
      CASE Type.Enum.int8
      CASE Type.Enum.int16
      CASE Type.Enum.int32
      CASE Type.Enum.nat
      CASE Type.Enum.byte
      CASE Type.Enum.nat16
      CASE Type.Enum.nat32
      CASE Type.Enum.float
      CASE Type.Enum.float32
      CASE Type.Enum.float80
      CASE Type.Enum.float128
      CASE Type.Enum.varString
      CASE Type.Enum.string
      CASE Type.Enum.varByteString
      CASE Type.Enum.byteString
      CASE Type.Enum.bool
      CASE Type.Enum.status
      CASE Type.Enum.enumValue
      CASE Type.Enum.bitsValue
      CASE Type.Enum.var
      CASE Type.Enum.dyn
      CASE Type.Enum.type
      CASE Type.Enum.array
      CASE Type.Enum.list
      CASE Type.Enum.dict
      CASE Type.Enum.tuple
      CASE Type.Enum.procRef
      CASE Type.Enum.funcRef
      CASE Type.Enum.callback
      CASE Type.Enum.ctype
        decl = scope.addDecl(name, typeType, zuiDecl, FALSE, ctx)

      DEFAULT
        decl = scope.addDecl(name, typeType, zuiDecl, FALSE, ctx)
        undef++
        IF ctx.doError()
          ctx.error("Declaration of " .. name
                 .. " for unsupported type " .. typeType.typeName(), typeExpr)
        }
    }

    IF decl.pName == NIL
      IF (scope.isClassScope() || scope.scopeName == NIL
                                        || scope.hasStatements()) && !isShared
        # No need to use a long name, the variable is only visible in the
        # current scope and nested scopes.
        decl.pName = "V" .. name

        IF scope ISA PieceScope
          # A member in an included piece may conflict with other members of
          # the class, give it a unique number.
          decl.pName = "V__" .. scope.<PieceScope>.pieceNr .. name
        }
      ELSE
        # Variable in global scope, prepend the current scope name.
        # Also for a SHARED declaration.
        decl.scopeName = scope.scopeName
        decl.pName = WriteCommon.getUid(scope.ToString() .. "/V" .. name)
        DeclStore.storePName(scope.scopeName, "V" .. name, decl)
      }
    }
    declExt.decl = decl

    IF !isShared
      mayPutDeclInMethodScope(decl, ctx)
    }

    # Only generate the init while resolving or when the declaration is used.
    # It may have side effects. (spec: WriteC may write the ZCB).
    bool unused = !scope.hasStatements() && skipUnused()
                                                      && !gen.isDeclUsed(decl)
    IF initExpr != NIL && mayHaveSideEffects(initExpr, ctx)
      # The initExpr may have side effects, always use the variable when the
      # module/class it is located in is used.
      IF scope.outerDecl != NIL
        scope.outerDecl.addDependsOn(decl)
      }
    }
    # If the declaration is used the containing module or class must be marked
    # as used.
    decl.addDependsOn(scope.outerDecl)

    bool initIsConstant
    IF initExpr != NIL && (!gen.writing || !unused)
      initExprOut = NEW(NEW())
      initExprOut.writing = ctx.out.writing
      SContext initExprContext = ctx.copy(initExprOut)

      # For a Module or Shared section in a class a declared item is not
      # always used.  When it is, the used items in the init must be marked as
      # used.  In other scopes it's done with the used items in the scope.
      set<Declaration> usedDecl
      IF !scope.hasStatements()
        usedDecl = scope.swapUsedDecl(declExt.initUsedDecl)
      }
      Type initType = typeType.getValueType(ctx)
      IF initType.isAllocType(ctx)
        # Variable is used in "USE &" argument
        initType = initType.getClassType(ctx).allocDecl.type
      }
      IF initType.isNoAlloc()
        checkNoAllocAssign(initType, initExpr, ctx)

        # Use the declaration itself as the destination type, the variable
        # name is needed for NEW().
        exprType = genTopExprDoConv(initExpr, initExprContext, decl)
      ELSE
        exprType = genTopExprDoConv(initExpr, initExprContext, initType)
      }
      IF exprType != NIL
        initIsConstant = isConstantExpression(initExpr, exprType,
                                                              initExprContext)
      ELSE
        initExprExt.undefined += 10
      }

      undef += initExprExt.undefined
      IF reportUndef && undef > 0
        ctx.error("generateDeclare() init undef: " .. undef, initExpr)
      }

      IF !scope.hasStatements()
        # Remember which Declarations were used in the init expr.
        declExt.initUsedDecl = scope.restoreUsedDecl(usedDecl)
      }
    }

    IF !scope.hasStatements() && declExt.initUsedDecl != NIL
      # When the declared item is used the declarations in the init will also
      # be used.
      decl.addDependsOn(declExt.initUsedDecl)
    }

    IF gen.writing && unused
      # This declaration is not used from Main().
      RETURN 0
    }

    # Set visibility of the symbol.
    decl.setVisibilityAttr(zuiDecl, ctx)

    # Generate the declaration and initialization.
    gen.declaration(decl, valueType.getEffType(), stmt, isShared, initExprOut,
                                                          initIsConstant, ctx)

    # for "VAR x = init" always set the type, it may slightly change in a
    # following pass (e.g., for iobject).
    IF scope.isInitVar() && useInit && varType
      IF !Type.typeDefined(exprType) || initExprExt.undefined != 0
        # type not known yet
        typeType = Type.anUnknown
      ELSE
        # now we know the type for "VAR name = expr"
        IF varTypeUnknown
          undef--
        }
        typeType = exprType
        IF typeType.ttype == Type.Enum.natval
                                         || typeType.ttype == Type.Enum.intval
          # for "VAR x = 1" assume int type.
          typeType = Type.anInt
        }
        LOG.verbose("\(name) VAR type detected: \(typeType.typeName())")
        IF decl.needAlloc && !typeType.isAllocType(ctx)
          typeType = typeType.getAllocType(ctx)
        }
      }
      decl.type = typeType
    }

    # When the declared item is used the type will also be used.
    IF typeType ISNOT Type.anUnknown
      decl.addDependsOn(typeType.getEffType())
      IF typeType.zuiAttr != NIL && typeType.zuiAttr.getEarlyInit()
        # TODO: Not always used?
        typeType.addDependsOn(decl)
      }
    }
    IF reportUndef && undef > 0
      ctx.error("generateDeclare() undef: " .. undef, stmt)
    }
    RETURN undef
  }

  # Generate an alias.
  FUNC generateAlias(Zui.Statement stmt, SContext ctx) int
    int undef
    Zui.Declaration zuiDecl = stmt.getDeclaration()
    Zui.AliasType alias = zuiDecl.getType().getAlias()
    SymUse symUse = NEW(stmt.getPos(), ctx)
    Zui.Expression fromExpr = alias.getFrom()
    Type typeType = generateDeclType(fromExpr, ctx.copyNoOut(),
                                                    isDecl + markUsed, symUse)
    undef += ZuiExpressionExt.get(fromExpr).undefined

    # Add the ID as representing the aliased type.
    # This is tricky:
    #    "decl" has the position of the ALIAS and decl.type is "alias"
    #    "decl.type.decl" is the declaration of the ALIAS target.
    #    Thus "decl" ISNOT "decl.type.decl"!
    # TODO: allow variables?
    IF typeType != NIL && (typeType.getTtype() == Type.Enum.class
                       || typeType.getTtype() == Type.Enum.proc
                       || typeType.getTtype() == Type.Enum.func
                       || typeType.getTtype() == Type.Enum.procRef
                       || typeType.getTtype() == Type.Enum.funcRef
                       || typeType.getTtype() == Type.Enum.callback
                       || typeType.getTtype() == Type.Enum.enum)
      Declaration.C decl = ctx.scope.addDecl(alias.getName(),
                                                typeType, zuiDecl, FALSE, ctx)
      ZuiDeclarationExt.get(zuiDecl).decl = decl  # recycle for next pass
      decl.pName = typeType.pName     # needed for proc
      decl.addDependsOn(typeType)
      decl.scopeBase = ctx.scope
      decl.setAttributes(zuiDecl, ctx)
    ELSE
      ++undef
      IF ctx.doError()
        IF typeType == NIL || typeType.getTtype() == Type.Enum.unknown
          symUse.doError = TRUE
          generateDeclType(alias.getFrom(), ctx, isDecl + markUsed, symUse)
        ELSE
          ctx.error("Cannot use ALIAS for " .. typeType.typeName(), stmt)
        }
      }
    }

    RETURN undef
  }

  # Generate a TYPE, aka typedef.
  FUNC generateTypedef(Zui.Statement stmt, SContext ctx) int
    Scope scope = ctx.scope
    Zui.Declaration zuiDecl = stmt.getDeclaration()
    Zui.AliasType alias = zuiDecl.getType().getAlias()
    VAR declExt = ZuiDeclarationExt.get(zuiDecl)
    string name = alias.getName()
    IF name[0] < 'A' || name[0] > 'Z'
      ctx.error("type name must start with an upper case letter", zuiDecl)
    }

    Zui.Expression fromExpr = alias.getFrom()
    SymUse symUse = NEW(stmt.getPos(), ctx)
    Type typeType = generateDeclType(fromExpr, ctx.copyNoOut(),
                                                    isDecl + markUsed, symUse)
    int undef = ZuiExpressionExt.get(fromExpr).undefined
    IF typeType == NIL || typeType.getTtype() == Type.Enum.unknown
      ++undef
      IF ctx.doError()
        symUse.doError = TRUE
        generateDeclType(fromExpr, ctx, isDecl + markUsed, symUse)
      }
    ELSE
      TypedefType type
      IF declExt.decl == NIL
        type = NEW(name, typeType)
        scope.addTypeDecl(type, zuiDecl, FALSE, ctx)
        IF scope.scopeName == NIL
          type.pName = "T_" .. name
        ELSE
          type.pName = scope.scopeName .. "__T_" .. name
        }
        type.scopeBase = scope
        type.setAttributes(zuiDecl, ctx)
        type.type.zuiAttr = zuiDecl.getType().getAttr()
        declExt.decl = type
      ELSE
        type = declExt.decl
        IF !scope.isForwardDeclare()
          # Not re-using the scope, need to define the enum again
          scope.addMember(type)
        }
      }
      type.addDependsOn(typeType)
    }

    RETURN undef
  }

  # GENERATE_IF
  FUNC generateGenerateIf(Zui.Statement stmt, SContext ctx) int
    int undef
    Output.Group noOuts = NEW()

    int state  # 0: IF part, 1: ELSEIF part, 2: ELSE part
    bool didBlock
    Zui.Condition cond = stmt.getCondition()
    Zui.Expression expr = cond.getCond()
    Zui.CodeBlock block = cond.getBlock()
    int elseifIndex

    # Evaluate the expression once.  Catches errors early.
    bool isContextFree = TRUE
    bool evalResult = ExprEval.evalBool(expr, ctx, TRUE, &isContextFree)
    WHILE TRUE
      bool doGenerate
      IF !ctx.out.writing && !isContextFree
        # Always generate when not writing but resolving symbols and the
        # expression depends on the context.  This doesn't work for a class
        # scope, we need to know whether or not to add members when not
        # generating.
        IF ctx.scope ISA ClassScope
          ctx.error("Sorry, GENERATE_IF in a class only works with constants",
                                                                         expr)
          RETURN 10
        }
        doGenerate = TRUE
      ELSEIF didBlock
        # Don't generate when a previous block was generated.
        doGenerate = FALSE
      ELSEIF state == 2
        # Always generate the else block when we didn't generate any of the
        # "if" or "elseif" blocks.
        doGenerate = TRUE
      ELSE
        # Use the result of evaluating the expression.
        doGenerate = evalResult
      }

      # Generate code, but without doing the end-of-block stuff.
      # Note: When not writing output some things can still happen, e.g.
      # adding members to a class.  That's why this is skipped if the the
      # expression is a constant.
      IF block.hasStatement() && (doGenerate || !isContextFree)
        SContext newCtx = NEW(ctx, ctx.scope, doGenerate ? ctx.outs : noOuts)
        undef += generateStatements(block.getStatementList(), newCtx)
      }
      IF doGenerate
        didBlock = TRUE
      ELSEIF ctx.gen.writing && block.hasStatement() && skipUnused()
        # Not writing a block, give an error for used items.  Avoids that the
        # error is reported by the C compiler.
        errorForUsedItems(block.getStatementList(), ctx)
      }
      IF state == 0
        # Did the IF, ELSEIF is next.
        state = 1
      ELSEIF state == 1
        # Did an ELSEIF, do the next one.
        ++elseifIndex
      ELSEIF state == 2
        # Did the ELSE, done.
        BREAK
      }
      IF state == 1
        IF elseifIndex < cond.sizeElseif()
          # Next ELSEIF.
          VAR elseif = cond.getElseif(elseifIndex)
          expr = elseif.getCond()
          block = elseif.getBlock()
        ELSE
          # Did the last ELSEIF, continue with ELSE if there is one
          IF !cond.hasElse()
            BREAK
          }
          state = 2
          block = cond.getElse()
        }
      }
    }

    RETURN undef
  }

  # GENERATE_ERROR "can't do this"
  FUNC generateGenerateError(Zui.Statement stmt, SContext ctx) int
    int undef
    Zui.Expression expr = stmt.getExpr()
    bool isContextFree = TRUE
    string msg = ExprEval.evalString(expr, ctx, TRUE, &isContextFree)
    IF ctx.gen.writing && ctx.out.writing && msg != NIL
      ctx.error(msg, stmt)
    }
    RETURN 0
  }

  PROC errorForUsedItems(list<Zui.Statement> statements, SContext ctx)
    FOR stmt IN statements
      IF stmt.getType() == Zui.StatementType.eCLASS_DECL
        Declaration decl = ZuiDeclarationExt.get(stmt.getDeclaration()).decl
        IF decl != NIL && ctx.gen.isDeclUsed(decl)
          ctx.error(stmt.getDeclaration().getName()
                                        .. " is used but not generated", stmt)
        }
      }
    }
  }

  # INCLUDE
  FUNC generateInclude(Zui.Statement includeStmt, SContext ctx) int
    IF !ctx.scope.isTopClassScope()
      ctx.error("Cannot use INCLUDE here", includeStmt)
      RETURN 10
    }

    ClassScope classScope = ctx.scope

    int undef
    Zui.Include include = includeStmt.getInclude()
    FOR stmt IN include.getStatementList()
      IF stmt.getType() == Zui.StatementType.eVAR_DECL
        # The included piece looks like a declaration:
        #    Type $name
        #    Type<Titem> $name
        Zui.Declaration zuiDecl = stmt.getDeclaration()
        IF zuiDecl.hasInit()
          ctx.error("Init not allowed here", zuiDecl)
        ELSEIF !zuiDecl.getDollar()
          ctx.error("missing $", zuiDecl)
        ELSE
          string name = zuiDecl.getName()
          Zui.Expression typeExpr = zuiDecl.getType().getName()
          SymUse symUse = NEW(typeExpr.getPos(), ctx)
          IF ctx.gen.writing
            symUse.doError = TRUE
          }
          Type type = generateDeclType(typeExpr, ctx.copyNoOut(),
                                             isDecl + dotI + markUsed, symUse)
          undef += ZuiExpressionExt.get(typeExpr).undefined
          IF type == NIL
            IF ctx.doError()
              ctx.error("Piece not found", typeExpr)
            }
          ELSEIF type.getTtype() != Type.Enum.piece
              && type.getTtype() != Type.Enum.class
              && type.getTtype() != Type.Enum.interface
            ctx.error("Type is not a piece, class or interface", typeExpr)
          ELSE
            ClassType classType = type
            VAR declExt = ZuiDeclarationExt.get(zuiDecl)
            PieceScope pieceScope = declExt.pieceScope
            IF pieceScope == NIL
              # Make a copy of the statements, how they are generated depends
              # on the current context.
              list<Zui.Statement> statements = NEW()
              FOR s IN classType.scope.statements
                statements.add(s.copy(TRUE))
              }
              pieceScope = NEW(ctx.scope, statements)
              pieceScope.scopeName = ctx.scope.scopeName .. "__P" .. type.name
              declExt.pieceScope = pieceScope
              declExt.typeObj = type

              STATIC int nextPieceNr # Unique number for each included piece.
              pieceScope.pieceNr = ++nextPieceNr
              Zui.Type zuiType = classType.zuiDecl.getType()
              pieceScope.zuiAttr = zuiType.getAttr()

              Zui.ClassType zuiClassType = zuiType.getClassDecl()
              IF zuiClassType.hasShared()
                # Make a copy of the whole SHARED section, so that we can call
                # generateShared() on it.
                pieceScope.sharedBlock = zuiClassType.getShared().copy(TRUE)
                pieceScope.sharedAttr = zuiClassType.getSharedAttr()
              }
            ELSE
              IF declExt.typeObj ISNOT type
                ctx.error("INTERNAL: type changed from previous pass", stmt)
              }
              pieceScope.initPass(ctx.scope)
              pieceScope.needPass = FALSE
            }

            # Remove the template types of the class, these cannot be used in
            # the included Pieces.
            classScope.removeTemplateTypes()

            # Lookup template types used in the declaration and add them to
            # the class scope with the name used in the Piece declaration:
            #     PIECE Foo<Tpiece>
            #     INCLUDE  Foo<TypeName>
            # -> Declare Tpiece with the type of TypeName
            # They are added every time, they may have changed.
            FOR decl IN classType.templateTypes
              pieceScope.addMember(decl)
            }

            # Hack: Set filename to that of the piece to get correct error
            # messages.
            ZimbuFile currentTop = classScope.topZimbuFile()
            ZimbuFile pieceTop = classType.scope.topZimbuFile()
            string savedFilename
            IF currentTop != NIL && pieceTop != NIL
              savedFilename = currentTop.filename
              currentTop.filename = pieceTop.filename
            }

            # Generate the code in the included piece.
            SContext pieceCtx = NEW(ctx, pieceScope, ctx.outs)
            undef += generate(pieceScope.statements, pieceCtx)

            IF pieceScope.sharedBlock != NIL
              undef += generateShared(pieceScope.sharedBlock,
                                      pieceScope.sharedAttr,
                             NEW(ctx.topScope, pieceScope, ctx.gen, ctx.outs))
            }

            # From the included piece, add object members not declared with
            # @local to the class.
            FOR dl IN pieceScope.objectMembers?.values()
              FOR decl IN dl
                IF !decl.hasLocalAttr()
                  bool found
                  IF classScope.objectMembers?.has(decl.name)
                    FOR cDecl IN classScope.objectMembers.get(decl.name)
                      found = TRUE
                      IF cDecl.zuiDecl ISNOT decl.zuiDecl
                        ctx.error("Piece declares member already declared "
                                    .. "in class: " .. decl.name, decl.zuiPos)
                        ctx.error("Declaration in class here", cDecl.zuiPos)
                        BREAK
                      }
                    }
                  }
                  IF !found
                    classScope.addObjectMember(decl)
                  }
                }
              }
            }

            # From the included piece, add SHARED members not declared with
            # @local to the class.
            FOR dl IN pieceScope.declDict?.values()
              FOR decl IN dl
                IF !decl.hasLocalAttr()
                  bool found
                  IF classScope.declDict?.has(decl.name)
                    FOR cDecl IN classScope.declDict.get(decl.name)
                      found = TRUE
                      IF cDecl.zuiDecl ISNOT decl.zuiDecl
                        ctx.error("Piece declares SHARED member already "
                           .. "declared in class: \(decl.name)", decl.zuiPos)
                        ctx.error("Declaration in class here", cDecl.zuiPos)
                        BREAK
                      }
                    }
                  }
                  IF !found
                    classScope.addMemberPlain(decl)
                  }
                }
              }
            }

            IF savedFilename != NIL
              currentTop.filename = savedFilename
            }

            # Remove the template types of the piece.
            FOR decl IN classType.templateTypes
              pieceScope.removeMember(decl)
            }

            # Put back the class template types.
            classScope.addTemplateTypes()
          }
        }
      ELSE
        ctx.error("Exected a declaration", stmt)
      }
    }

    RETURN undef
  }

  # Handle the IMPLEMENTS list after CLASS.
  # Return the number of undefined symbols.
  FUNC handleImplements(Zui.ClassType zuiClassType, ClassType class,
                                                                  SContext ctx
                       ) int
    # Clear the list every round to get errors for duplicates.
    class.interfaces = NIL

    # Use the class scope to pick up template type names.
    Scope scope = class.scope

    int undef
    FOR impl IN zuiClassType.getImplementsList()
      SymUse symUse = NEW(impl.getPos(), ctx)
      Declaration decl = scope.findExprDecl(impl, FALSE, FALSE, TRUE,
                                                             ctx, symUse)
      IF decl == NIL
        undef += 2
        IF ctx.doError()
          symUse.doError = TRUE
          IF scope.findExprDecl(impl, FALSE, TRUE, TRUE, ctx, symUse) == NIL
            ctx.error("Interface not found", impl)
          }
        }
      ELSEIF decl.type.getTtype() != Type.Enum.interface
                                  && decl.type.getTtype() != Type.Enum.iobject
        undef++
        IF ctx.doError()
          ctx.error("Not an interface", impl)
        }
      }
      IF decl != NIL
        Type itf = decl.type
        # Add the interface to our class.  Use the class in case it's an
        # alias.
        Type itfClass = (itf.getTtype() == Type.Enum.iobject
                || itf.getClassType(ctx) == NIL) ? itf : itf.getClassType(ctx)
        class.addInterface(itfClass, decl.zuiDecl, ctx)

        # Add ourselves as a child to the interface.
        IF itf.getTtype() == Type.Enum.iobject
          itf.getClassType(ctx).addChild(class, ctx)
        ELSE
          itfClass.<ClassType.C>.addChild(class, ctx)
        }
      }
    }
    RETURN undef
  }

  # Generate a CodeBlock scope.
  # Use |scopeType| for SWITCH, FOR, IF, etc.
  # Use |switchType| in the scope of a SWITCH.
  FUNC generateCodeBlock(
      Zui.CodeBlock block,
      Zui.Statement loopStmt,  # only when in a loop
      SContext ctx,
      Scope.Stype scopeType,
      Type switchType
      ) int
    int undef = generateCodeBlockBody(block, loopStmt, ctx,
                                                        scopeType, switchType)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("}\n")
    RETURN undef
  }

  # Like generateCodeBlock() but without the final "}".
  FUNC generateCodeBlockBody(
      Zui.CodeBlock block,
      Zui.Statement loopStmt,  # only when in a loop
      SContext ctx,
      Scope.Stype scopeType,
      Type switchType
      ) int
    VAR blockExt = ZuiCodeBlockExt.get(block)
    IF skip_zero_undefined && !ctx.gen.writing
        && blockExt.scope != NIL
        && !blockExt.scope.needPass && blockExt.undefined == 0
      # No need to process this block again.
      RETURN 0
    }

    ctx.gen.startBlock(ctx)
    Output out = ctx.outs.out           # normal generate output
    int undef
    IF block.hasStatement()
      undef = genBlockScopeWithSym(NIL, scopeType, switchType, NIL, block, ctx)
    }

    IF loopStmt != NIL
      # Generate the position of the WHILE since that's what happens next.
      ctx.gen.beforeStatement(loopStmt, ctx)
    }
    RETURN undef
  }

  # Generate the return type of a method from the type.
  PROC generateMethodReturnType(MethodType type, SContext ctx)
    Type retType = type.returnType
    IF type.name == "NEW"
      ctx.out.write(type.scopeBase.scopeName .. "*")
    ELSEIF type.getTtype() == Type.Enum.func
      ctx.gen.vartype(retType, FALSE, NIL, ctx)
    ELSE
      ctx.out.write("void")
    }
  }

  PROC generateMethodArgTypes(MethodType type, SContext ctx)
    string sep = ""
    IF type.name != "NEW"
      # pass THIS as the first argument
      ctx.out.write("void*")
      sep = ", "
    }
    FOR d IN type.getArgList()
      ctx.out.write(sep)
      ctx.gen.vartype(d.type, FALSE, NIL, ctx)
      sep = ", "
    }
  }

  #
  # Handle an IMPORT statement.
  # |usedFile| is the file that contains the IMPORT statement.
  # Return the number of undefined items.
  #
  FUNC generateImport(UsedFile usedFile, Zui.Import import, SContext ctx) int
    VAR importExt = ZuiImportExt.get(import)
    IF importExt.usedFile == NIL
      # Haven't parsed this import yet, or it's IMPORT.CHEADER.
      usedFile.parseImport(import, ctx)
      IF importExt.usedFile == NIL
        RETURN 0
      }
    }

    TopScope topScope = ctx.topScope
    string pluginName = import.hasPlugin() ? import.getPlugin() : NIL

    IF pluginName == "ZWT"
      # Use the TopScope of the ZWT file tree from the first pass.
      topScope = importExt.topScope

      # Use the pass number from the outer topScope so that scope.pass in
      # every place does not depend on how files import each other.
      topScope.pass = ctx.topScope.pass

      # Also use the builtins from the C TopScope for the JS TopScope. They
      # are processed only once and an import used by C may also be used by
      # JS indirectly.  Used declaration tracking will prevent from unused
      # code to be actually produced.
      FOR name IN ctx.topScope.usedBuiltins.keys()
        topScope.usedBuiltins[name] = Builtin.availableModules.get(name, NIL)
      }
    }
    ZimbuFile zimbuFile = importExt.usedFile.zimbuFile
    IF zimbuFile == NIL
      RETURN 0  # error already reported
    }

    # If a file is not imported with IMPORT.ZWT its use depends on the path
    # how it was imported.
    IF pluginName != "ZWT"
      # TODO: use |=
      IF usedFile.zimbuFile.usedAsZwt
        zimbuFile.usedAsZwt = TRUE
      }
      IF usedFile.zimbuFile.usedAsZimbu
        zimbuFile.usedAsZimbu = TRUE
      }
    }

    FileScope scope = ctx.scope
    IF scope.pass <= 1
      # First round: add the zimbuFile in the current scope.  Note that
      # zimbuFile.fileScope and zimbuFile.fileScope.declDict may still be NIL.
      scope.addImport(importExt.usedFile)
    }

    int undef

    # We need to go into the imported file if we haven't done it yet for the
    # current top file (Main() or ZWT file).
    # Rationale: "foo.zu" may be included below the file containing Main() and
    # also below a ZWT file.  It must then be generated and included in both.
    # This must be known at the toplevel, also for builtin modules.
    IF topScope.isNewImport(zimbuFile) && !ctx.out.writing
                                && (LOG.errorCount == 0 || continueAfterError)
      # Do the first pass now, it's always needed.
      # This collects the symbols, some forward declared types may still be
      # unknown.
      # This recursively imports files!
      resolve(importExt.usedFile, scope.importIndent .. "  ",
                               NEW(ctx, importExt.usedFile.scope(), ctx.outs))

      Zui.Statement stmt = zimbuFile.fileScope.getFirstStatement()
      IF stmt != NIL
        undef = ZuiStatementExt.get(stmt).undefined
      }
    }

    IF LOG.errorCount == 0 || continueAfterError
      undef += processImport(importExt.usedFile, NEW(topScope, ctx.scope,
                                                           ctx.gen, ctx.outs))
    }

    IF zimbuFile.item == NIL && zimbuFile.fileScope?.declDict?.Size() == 1
      # Usually the file defines one item (module, class, etc).
      # Put this item in the ZimbuFile for quick lookup.
      zimbuFile.item = zimbuFile.fileScope.declDict.values()[0][0]
    }

    RETURN undef
  }

  # Turn the relative name |nameArg| into a file name relative to the top
  # ZUDIR directory.
  FUNC relativeName(UsedFile usedFile, string nameArg) string
    string name = nameArg
    IF usedFile.zimbuFile.dirName != NIL && usedFile.zimbuFile.dirName != ""
      # Prepend the directory of the current file.
      string dir = usedFile.zimbuFile.dirName
      WHILE name.slice(0, 2) == "../"
        name = name.slice(3)
        int slash = dir.findLast('/')
        IF slash < 0
          dir = ""
          BREAK
        }
        dir = dir.slice(0, slash - 1)
      }
      name = IO.concatPath(dir, name)
    }
    RETURN name
  }

  #
  # Resolve or write a parsed zimbuFile.
  # This is shared between the IMPORT statement and builtin modules.
  # Return the number of undefined items.
  #
  FUNC processImport(UsedFile usedFile, SContext ctx) int
    Resolve gen = ctx.gen
    Scope scope = ctx.scope
    ZimbuFile zimbuFile = usedFile.zimbuFile

    string name = zimbuFile.filename
    int undef

    # Need to do another round of collecting symbols only when:
    # - we didn't do this pass yet
    # - there was no error somewhere
    # - we are in a resolve pass
    # - there were undefined symbols in this zimbuFile.
    IF zimbuFile.startedPass < ctx.topScope.pass
        && (LOG.errorCount == 0 || continueAfterError)
        && !gen.writing
      zimbuFile.startedPass = ctx.topScope.pass
      IF zimbuFile.fileScope.getFirstStatement() != NIL
        IF !skip_zero_undefined || zimbuFile.fileScope.undefined > 0
                                               || zimbuFile.fileScope.needPass
          zimbuFile.fileScope.needPass = FALSE
          resolve(usedFile, scope.importIndent .. "  ",
                                         NEW(ctx, usedFile.scope(), ctx.outs))
          undef = zimbuFile.fileScope.undefined
        ELSE
          LOG.info("\(scope.importIndent)  \(name): Skipping")
          zimbuFile.fileScope.pass++
        }
      }
    }

    # Need to write code only when:
    # - we didn't do this pass yet
    # - there was no error somewhere
    # - we are in a write pass
    IF gen.needWrite(zimbuFile) && (LOG.errorCount == 0 || continueAfterError)
                                                                && gen.writing
      zimbuFile.fileScope.pass = scope.pass

      # When a module is used with IMPORT.ZWT we start writing a JavaScipt
      # file.  It includes all imported files.
      # TODO: When already writing JS we should load it from the higher level
      # JS file.
      IF zimbuFile.topZwtFile
        MainFile.generateJSFile(usedFile, ctx)
      }

      # Write the code in the current language.
      Output.Group outputs = gen.getCS(zimbuFile).outputs
      SContext newCtx = NEW(ctx.topScope, usedFile.scope(), gen, outputs)
      write(usedFile, newCtx, outputs, scope.importIndent .. "  ")
      undef = zimbuFile.fileScope.undefined

      # Write the code of the import to "outs".
      gen.writeIncludeImport(zimbuFile, scope, ctx.outs)

      # Check for toplevel items.
      Output mainOut = gen.getCS(zimbuFile).outputs.mainOut
      IF !mainOut.empty()
        LOG.internal(
                  "Lines at toplevel of imported file \(zimbuFile.filename):")
        IO.print(mainOut.ToString())
      }
    }

    RETURN undef
  }

  # Check if a BREAK or CONTINUE is in a valid scope.
  PROC checkScope(Zui.Statement stmt, SContext ctx, bool isBreak)
    Scope s = ctx.scope
    WHILE s != NIL
      IF isBreak
        s.hasBreak = TRUE
      ELSE
        s.hasContinue = TRUE
      }
      IF s.isLoopScope() || isBreak && s.scopeType == Scope.Stype.switch
        BREAK
      }
      IF s.isMethodType()
        s = NIL  # don't look above proc level
        BREAK
      }
      s = s.outer
    }
    IF s == NIL
      IF isBreak
        ctx.error("BREAK not inside FOR, WHILE, DO or SWITCH", stmt)
      ELSE
        ctx.error("CONTINUE not inside FOR, DO or WHILE", stmt)
      }
    }
  }

  # Like generateDeclType() and turn a class into an object type.
  # And turn an enum into an enumValue.
  # Returns NIL if no type was found.
  FUNC generateObjDeclType(Zui.Type type, SContext ctx) Type
    SymUse symUse = NEW(type.getPos(), ctx)

    Type ret = generateDeclType(type, ctx, isDecl + dotI + markUsed, symUse)
    IF ret == NIL
      IF ctx.doError()
        symUse.doError = TRUE
        generateDeclType(type, ctx, isDecl + dotI + markUsed, symUse)
      }
      RETURN NIL
    }

    RETURN type2valueType(ret, ctx)
  }

  FUNC type2valueType(Type ret, SContext ctx) Type
    Type.Enum ttype = ret.getTtype()
    IF ttype == Type.Enum.class
        || ttype == Type.Enum.classDotC
        || ttype == Type.Enum.interface
        || ttype == Type.Enum.enum
        || ttype == Type.Enum.bits
      RETURN ret.getValueType(ctx)
    ELSEIF ttype == Type.Enum.byRef
      ret.<ReferenceType.C>.makeValueType(ctx)
    ELSEIF ttype == Type.Enum.object
      # It is possible that a child is found for a class later, then the
      # type changes from object to iobject and we need to come back here to
      # take care of that.
      ClassType ct = ret.getClassType(ctx)
      IF ct != NIL
        ct.scope.addScopeDependency(ctx.scope)
      }
    }
    RETURN ret
  }

  # Like generateDeclType() and turn a class into an object type.
  # And turn an enum into an enumValue.
  # Returns NIL if no type was found.
  FUNC generateObjDeclType(Zui.Expression expr, SContext ctx) Type
    SymUse symUse = NEW(expr.getPos(), ctx)

    Type ret = generateDeclType(expr, ctx, isDecl + dotI + markUsed, symUse)
    IF ret == NIL
      IF ctx.doError()
        symUse.doError = TRUE
        generateDeclType(expr, ctx, isDecl + dotI + markUsed, symUse)
      }
      RETURN NIL
    }
    RETURN type2valueType(ret, ctx)
  }

  BITS DeclFlags
    bool $isDecl
    bool $dotI
    bool $addingTypeSpec
    bool $markUsed
    bool $noAlloc
  }

  # Generate the type part of a declaration.
  # When |isDecl| is TRUE, accept type names, such as "string", "thread", etc.
  # When FALSE they must be "T.string", "T.thread", etc.
  # When |addingTypeSpec| is TRUE a type spec is going to be added, thus
  # accept a templated class.
  # When |markUsed| is TRUE mark the type declaration as used in this scope.
  # Return the type.
  FUNC generateDeclType(Zui.Type type,
                        SContext ctx,
                        DeclFlags flags,
                        SymUse symUse
                      ) Type
    Type ret
    VAR typeExt = ZuiTypeExt.get(type)
    SWITCH type.getType()
      CASE Zui.TypeEnum.eREF
        Type declType = generateDeclType(type.getRef(), ctx, flags, symUse)
        IF declType == NIL
          declType = Type.anUnknown
        }
        typeExt.undefined = ZuiTypeExt.get(type.getRef()).undefined
        ReferenceType.C typeObj = NEW(Type.Enum.byRef, declType, "ref")
        ret = typeObj

      CASE Zui.TypeEnum.eUSE
        # Type specified by variable in context and stored in typeObj
        ret = typeExt.typeObj
        IF ret != NIL
          ctx.gen.vartype(ret, TRUE, type.getPos(), ctx)
        }

      CASE Zui.TypeEnum.eNAME
        ret = generateDeclType(type.getName(), ctx, flags, symUse)
        typeExt.undefined = ZuiExpressionExt.get(type.getName()).undefined

      DEFAULT
        ctx.error("INTERNAL: generateDeclType() not supported "
                                  .. type.getType().ToString(), type.getPos())
    }
    RETURN ret
  }

  # Generate the type part of a declaration specified with an expression.
  # When |isDecl| is TRUE, accept type names, such as "string", "thread", etc.
  # When FALSE they must be "T.string", "T.thread", etc.
  # When |dotI| is TRUE then MyClass stands for MyClass.I when it has children.
  # When |addingTypeSpec| is TRUE a type spec is going to be added, thus
  # accept a templated class.
  # When |markUsed| is TRUE mark the type declaration as used in this scope.
  # Return the type.
  FUNC generateDeclType(Zui.Expression expr,
                        SContext ctx,
                        DeclFlags flags,
                        SymUse symUse
                       ) Type
    Declaration ret
    Type retType
    VAR exprExt = ZuiExpressionExt.get(expr)
    exprExt.undefined = 0

    SWITCH expr.getType()
      CASE Zui.ExprType.eID
      CASE Zui.ExprType.eMEMBER
        IF expr.getType() == Zui.ExprType.eID
          # Some special handling of IDs.  TODO: Is this needed?
          string name = expr.getId().getName()
          ret = Type.typeFromName(name)
          IF (ret != NIL && ret ISA ContainerType)
                                           || name == "proc" || name == "func"
            ctx.error("Missing <type specification>", expr)
          }
        }
        IF ret == NIL
          ret = ctx.scope.findExprDecl(expr, flags.dotI, ctx.doError(),
                                                    flags.isDecl, ctx, symUse)
        }
        IF ret == NIL || ret.type == NIL
          exprExt.undefined++
          IF reportUndef
            ctx.error("generateDecltype() type", expr)
          }
        ELSE
          retType = ret.type
          IF flags.noAlloc
            retType = getNoAllocType(retType, expr)
          }
          generateSomeDeclType(expr, retType, ctx, flags.addingTypeSpec)
          IF reportUndef && exprExt.undefined > 0
            ctx.error("generateDecltype() some type", expr)
          }
          IF flags.markUsed
            SWITCH retType.getTtype()
              CASE Type.Enum.varString
                ctx.addUsedItem(Declaration.varString)
              CASE Type.Enum.varByteString
                ctx.addUsedItem(Declaration.varByteString)
              DEFAULT
                ctx.addUsedItem(ret)
            }
          }
        }

      CASE Zui.ExprType.eCTYPE
        # C type: write the string and return a ctype.
        string name = expr.getId().getName()
        ctx.out.write(name)
        IF exprExt.decl == NIL
          ret = Type.NEW(Type.Enum.ctype, name)
          ret.type.setCtypeName(name)
          exprExt.decl = ret
          IF flags.noAlloc
            ret.type = getNoAllocType(ret.type, expr)
          }
        ELSE
          # Re-use the type from the first pass.
          ret = exprExt.decl
        }
        retType = ret.type

      CASE Zui.ExprType.eSUBSCRIPT
        ctx.error("Use array<> to declare an array", expr)

      CASE Zui.ExprType.eTYPESPEC
        ret = generateTypespecType(expr, ctx, symUse)
        retType = ret?.type
        IF flags.noAlloc && retType != NIL
          retType = getNoAllocType(retType, expr)
        }

      CASE Zui.ExprType.eMETHOD
        ctx.error("cannot have method in type", expr)

      DEFAULT
        ctx.error("unknown type for declaration: " .. expr.getType().ToString(),
                                                                         expr)
    }
    RETURN retType
  }

  FUNC getNoAllocType(Type type, Zui.Expression expr) Type
    VAR exprExt = ZuiExpressionExt.get(expr)
    IF exprExt.noAllocType != NIL
      # Use the NoAllocType created in a previous pass.  Set the wrapped type
      # again if it changed.  The ttype can change from object to iobject
      # while the type stays the same.
      NoAllocType nat = exprExt.noAllocType
      IF nat.wrappedType ISNOT type || nat.wrappedType.ttype != type.ttype
        nat.wrappedType = type
        nat.ttype = type.ttype
        nat.valueType = NIL  # clear cached value
      }
    ELSE
      # Create a new NoAllocType and store it for the next pass.
      exprExt.noAllocType = type.getNoAllocType()
    }
    RETURN exprExt.noAllocType
  }

  # Generate declaration type for |type|, and special handling for interface
  # and class.
  PROC generateSomeDeclType(Zui.Expression expr, Type type,
                                            SContext ctx, bool addingTypeSpec)
    IF !addingTypeSpec && type.getTtype() == Type.Enum.class
                        && type.getEffType().<ClassType.C>.templateList != NIL
      ctx.error("Missing type spec for templated class", expr)
    }
    ctx.gen.vartype(type, TRUE, expr.getPos(), ctx)
  }

  #
  # Generate type for list<Type>, dict<Type, Type>, SomeClass<Type> etc.
  #
  FUNC generateTypespecType(Zui.Expression expr, SContext ctx, SymUse symUse
                           ) Type
    Zui.Expression nameExpr = expr.getLeft()
    string name
    Zui.ExprType type = nameExpr.getType()
    IF type == Zui.ExprType.eID
      name = nameExpr.getId().getName()
    ELSEIF type == Zui.ExprType.eMEMBER
      name = nameExpr.getRight().getId().getName()
    ELSE
      ctx.error("Expected identifier or type before <>, found "
                                                     .. type.ToString(), expr)
      RETURN NIL
    }
    IF !expr.hasTypespec() && name != "proc"
      ctx.error("Missing type in <>", expr)
      RETURN NIL
    }

    # Check for predefined types.
    IF name == "array"
      RETURN generateArrayType(expr, ctx)
    }
    IF name == "list"
      RETURN generateListType(expr, ctx)
    }
    IF name == "dict"
      RETURN generateDictType(expr, ctx)
    }
    IF name == "varargs"
      RETURN generateVarargsType(expr, ctx)
    }
    IF name == "func" || name == "proc"
      RETURN generateMethodType(expr, name, ctx)
    }
    IF name == "callback"
      RETURN generateCallbackType(expr, name, ctx)
    }
    IF name == "tuple"
      RETURN generateTupleType(expr, name, ctx)
    }

    # Must be a templated class, interface or piece.
    Type leftType = generateDeclType(nameExpr, ctx.copyNoOut(),
                            isDecl + dotI + addingTypeSpec + markUsed, symUse)
    ZuiExpressionExt.get(expr).undefined =
                                      ZuiExpressionExt.get(nameExpr).undefined
    RETURN generateTemplatedClasstype(expr, leftType, ctx, symUse)
  }

  # Handle using templated class or interface.
  # |type| is the expr.getLeft() handled (can be NIL).
  FUNC generateTemplatedClasstype(Zui.Expression expr,
                                  Type type, SContext ctx, SymUse symUse) Type
    Type classType
    VAR exprExt = ZuiExpressionExt.get(expr)
    Zui.Expression leftExpr = expr.getLeft()
    exprExt.undefined = ZuiExpressionExt.get(leftExpr).undefined
    IF type == NIL
      IF ctx.doError()
        symUse.doError = TRUE
        IF generateDeclType(leftExpr, ctx.copyNoOut(),
                     isDecl + dotI + addingTypeSpec + markUsed, symUse) == NIL
          ctx.error("Unknown type for class", leftExpr)
        }
      }
    ELSE
      ClassType ct = type.getClassType(ctx)
      IF ct == NIL || ct.templateList == NIL
        ctx.error((ct.getTtype() == Type.Enum.interface ? "Interface" : "Class")
                       .. " does not use a template: " .. type.name, leftExpr)
      ELSE
        # Parse types inside <> and make a list of them.
        list<Declaration> types = NEW()
        list<Zui.Type> zuiTypeList = expr.getTypespecList()
        Zui.Type firstType = zuiTypeList[0]

        status typesStatus = getTypeList(zuiTypeList, types, ctx)
        exprExt.undefined += ZuiTypeExt.get(firstType).undefined

        # Check the type spec count.
        int expectedTypeCount = ct.templateNames.Size()
        IF types.Size() < expectedTypeCount
          ctx.error("Insufficient types", firstType)
          ctx.error("Expected type list declared here", type.zuiDecl)
          typesStatus = FAIL
        ELSEIF types.Size() > expectedTypeCount
          ctx.error("Too many types", firstType)
          ctx.error("Expected types list declared here", type.zuiDecl)
          typesStatus = FAIL
        }

        # Only lookup a defined class if we recognized the types.
        IF typesStatus == OK
          # lookup symbol of class with this list of types, check type count.
          bool found
          FOR template IN ct.templateList
            IF Declaration.typeListMatch(template.decls, types, ctx)
              IF template.stmt != NIL
                classType = ZuiStatementExt.get(template.stmt).typeObj
              ELSE
                # Existing list of types, but it hasn't been processed yet.
                ++exprExt.undefined
              }
              found = TRUE
              BREAK
            }
          }

          setTemplateTypeNames(ct.templateNames, types)
          IF !found
            # Not seen this combination of types before.  Add it to the class,
            # the next time it's encountered it will create the classType.
            Template template = NEW(types)
            ct.templateList.add(template)
            template.name = "" .. ct.templateList.Size()

            # Make sure the class gets another pass so that it can be
            # generated with the new template.
            ct.scope.setNeedPass(ctx)
          ELSEIF classType != NIL
            # Remember the types, used when a Piece is included.
            classType.<ClassType>.templateTypes = types
          }
        }
      }
    }

    RETURN classType
  }

  # Get the name of types from |names|.
  PROC setTemplateTypeNames(list<string> names, list<Declaration> types)
    FOR i IN 0 UNTIL names.Size()
      IF types[i] != NIL
        # need to make a copy to change the name, can be Type.aString.
        IF types[i].name != names[i]
          types[i] = NEW(names[i], types[i].type)
        }
      }
    }
  }

  # Add the types of |zuiTypeList|  to |types|
  FUNC getTypeList(list<Zui.Type> zuiTypeList, list<Declaration> types,
                                                                  SContext ctx
                  ) status
    int undef
    status ret = OK
    FOR zuiType IN zuiTypeList
      Zui.Expression expr = zuiType.getName()
      Type type = generateObjDeclType(expr, ctx.copyNoOutUseItems())
      undef += ZuiExpressionExt.get(expr).undefined
      IF type == NIL || type.getTtype() == Type.Enum.unknown
        IF ctx.doError()
          ctx.error("Uknown type", expr)
        }
        ret = FAIL
      }
      # Actual name will be set in setTemplateTypeNames()
      Declaration.C decl = NEW("type")
      decl.type = type
      types.add(decl)
    }
    ZuiTypeExt.get(zuiTypeList[0]).undefined = undef
    RETURN ret
  }

  # Handle "list<Type>".
  FUNC generateListType(Zui.Expression expr, SContext ctx) Type
    IF expr.sizeTypespec() != 1
      ctx.error("list<> requires one type", expr)
      RETURN NIL
    }
    # Get the type of the items.
    Zui.Expression typeExpr = expr.getTypespec(0).getName()
    Type itemType = generateObjDeclType(typeExpr, ctx.copyNoOutUseItems())
    IF (itemType == NIL || itemType.getTtype() == Type.Enum.unknown)
                                                              && ctx.doError()
      ctx.error("Unknown item type", typeExpr)
    }

    ContainerType type = NEW(Type.Enum.list, itemType, "list")
    ZuiExpressionExt.get(expr).undefined =
                                      ZuiExpressionExt.get(typeExpr).undefined
    ctx.addUsedItem(Declaration.list)
    ctx.gen.vartype(type, FALSE, expr.getPos(), ctx)
    RETURN type
  }

  # Handle "dict<Type, Type>".
  FUNC generateDictType(Zui.Expression expr, SContext ctx) Type
    IF expr.sizeTypespec() != 2
      ctx.error("dict<> requires two types", expr)
      RETURN NIL
    }
    Type.Enum ttype = Type.Enum.dict
    # Get the type of the key and items.
    Zui.Expression typeExprKey = expr.getTypespec(0).getName()
    Zui.Expression typeExprItem = expr.getTypespec(1).getName()
    Type keyType = generateObjDeclType(typeExprKey, ctx.copyNoOutUseItems())
    Type itemType = generateObjDeclType(typeExprItem, ctx.copyNoOutUseItems())
    Type dict = ContainerType.NEW(ttype, itemType, keyType, "dict")
    IF ctx.doError()
      IF keyType == NIL
        ctx.error("Unknown key type", typeExprKey)
      }
      IF itemType == NIL
        ctx.error("Unknown item type", typeExprItem)
      }
    }
    ZuiExpressionExt.get(expr).undefined =
                                   ZuiExpressionExt.get(typeExprKey).undefined
                                + ZuiExpressionExt.get(typeExprItem).undefined
    ctx.addUsedItem(Declaration.dict)
    ctx.gen.vartype(dict, FALSE, expr.getPos(), ctx)
    RETURN dict
  }

  # Get a list of Types from a typespec.
  # When |itemNames| is TRUE accept item names.
  FUNC getArgTypes(Zui.Expression expr, int start,
                             bool itemNames, SContext ctx) list<Declaration.C>
    list<Declaration.C> argTypes = NEW()
    FOR i IN start UNTIL expr.sizeTypespec()
      Zui.Type zuiType = expr.getTypespec(i)
      Zui.Expression typeExpr
      IF zuiType.getType() == Zui.TypeEnum.eREF
        typeExpr = zuiType.getRef().getName()
      ELSE
        typeExpr = zuiType.getName()
      }
      Type argType = generateObjDeclType(typeExpr, ctx.copyNoOutUseItems())
      ZuiExpressionExt.get(expr).undefined +=
                                      ZuiExpressionExt.get(typeExpr).undefined
      IF zuiType.getType() == Zui.TypeEnum.eREF
        argType = ReferenceType.NEW(Type.Enum.byRef, argType, "ref")
      }

      Declaration.C decl = NEW("")
      decl.type = argType
      IF itemNames && zuiType.hasItemName()
        decl.name = zuiType.getItemName()
        decl.zuiPos = zuiType.getItemNamePos()
      }
      argTypes.add(decl)
    }
    RETURN argTypes
  }

  # Handle func<arg1Type, arg2Type => retType>
  # And proc<arg1Type, arg2Type>
  # Return a reference to the method.
  FUNC generateMethodType(Zui.Expression expr, string name, SContext ctx) Type
    bool isFunc = name == "func"
    bool foundReturnType
    MethodType mt
    VAR exprExt = ZuiExpressionExt.get(expr)
    IF isFunc
      mt = NEW(Type.Enum.func, "func")
      list<Type> returnTypes = NEW()

      # A function must have a return value:
      # func< => int>
      # func< => int, int>
      # func<int => int>
      FOR type IN expr.getTypespecList()
        IF type.getIsReturn()
          foundReturnType = TRUE
          Type t = generateObjDeclType(type, ctx.copyNoOutUseItems())
          exprExt.undefined = ZuiTypeExt.get(type).undefined
          IF (t == NIL || exprExt.undefined > 0) && ctx.doError()
            generateObjDeclType(type, ctx)
          }
          returnTypes.add(t ?: Type.anUnknown)
        ELSEIF foundReturnType
          ctx.error("found argument type after return type", type)
        }
      }

      IF !foundReturnType
        ctx.error("missing return type", expr)
      ELSEIF returnTypes.Size() == 1
        # One return type.
        mt.returnType = returnTypes[0]
      ELSE
        # Multiple return types.
        # TODO: use mapTo() when it works for iobject
        list<Declaration> decls = NEW()
        FOR t IN returnTypes
          decls.add(Declaration.NEW("ret", t))
        }
        mt.returnType = MultipleType.NEW(decls, "ret")
      }
    ELSE
      mt = NEW(Type.Enum.proc, "proc")
      exprExt.undefined = 0
    }

    IF expr.getLeft().getType() == Zui.ExprType.eMEMBER
      # Class.func<int>
      Zui.Expression ll = expr.getLeft().getLeft()
      mt.classType = generateObjDeclType(ll, ctx.copyNoOutUseItems())
      exprExt.undefined += ZuiExpressionExt.get(ll).undefined
    }

    # Add the argument types (can be empty).
    # Redo this in every pass, types may have become available.
    int undef
    mt.arguments = getDeclListFromTypes(expr.getTypespecList(), ctx,
                       useType
                     + unknownIsUndef
                     + (ctx.doError() ? reportError : 0)
                     + (foundReturnType ? dropLast : 0),
                     &undef)
    exprExt.undefined += undef

    # If there is an existing method with these properties, use it.
    # This reduces the number of callbacks generated.
    mt = MethodType.findMethod(mt, ctx)
    mt.zuiPos = expr.getPos()

    Type refType = mt.getMethodRef()
    refType.addDependsOn(Declaration.funcRef)
    ctx.gen.vartype(refType, FALSE, expr.getPos(), ctx)
    RETURN refType
  }

  # Handle array<Type>
  FUNC generateArrayType(Zui.Expression expr, SContext ctx) Type
    IF expr.sizeTypespec() < 1 || expr.sizeTypespec() > 2
      ctx.error("array<> requires one type and an optional dimension", expr)
      RETURN NIL
    }
    VAR exprExt = ZuiExpressionExt.get(expr)

    ContainerType type = NEW(Type.Enum.array, "array")
    # TODO: multi-dimensional arrays
    # type.arraySize = NEW()

    Zui.Expression typeExpr = expr.getTypespec(0).getName()
    type.itemType = generateObjDeclType(typeExpr, ctx.copyNoOutUseItems())
    exprExt.undefined = ZuiExpressionExt.get(typeExpr).undefined

    IF expr.sizeTypespec() == 2
      # Handle array<Type, 3>
      Zui.Expression dimExpr = expr.getTypespec(1).getName()
      bool isContextFree
      type.dimensions = ExprEval.evalInt(dimExpr, ctx, TRUE, &isContextFree)
      IF type.dimensions != 1
        ctx.error("Only one dimension supported yet.", dimExpr)
      }
      exprExt.undefined = 0
    }

    ctx.addUsedItem(Declaration.array)
    ctx.gen.vartype(type, FALSE, expr.getPos(), ctx)
    RETURN type
  }

  # Handle varargs<Type>
  FUNC generateVarargsType(Zui.Expression expr, SContext ctx) Type
    IF expr.sizeTypespec() != 1
      ctx.error("varargs<> requires one type", expr)
      RETURN NIL
    }

    Zui.Expression typeExpr = expr.getTypespec(0).getName()
    Type argType = generateObjDeclType(typeExpr, ctx.copyNoOutUseItems())
    ZuiExpressionExt.get(expr).undefined =
                                      ZuiExpressionExt.get(typeExpr).undefined

    TupleType type = TupleType.getVarargsTuple(argType, expr.getPos(), ctx)
    ctx.gen.vartype(type, FALSE, expr.getPos(), ctx)
    RETURN type
  }

  # Handle callback<funcType, arg1Type, arg2Type>
  # Return a reference to the type.
  FUNC generateCallbackType(Zui.Expression expr, string name, SContext ctx
                           ) CallbackType
    # Redo the method and argument types, they may have changed.

    # The method type.
    Zui.Expression typeExpr = expr.getTypespec(0).getName()
    Type tt = generateObjDeclType(typeExpr, ctx.copyNoOutUseItems())
    int typeUndef = ZuiExpressionExt.get(typeExpr).undefined
    ZuiExpressionExt.get(expr).undefined = typeUndef
    IF ctx.doError() && (tt == NIL || typeUndef > 0)
      generateObjDeclType(typeExpr, ctx)
    }
    IF tt == NIL
      RETURN NIL
    }
    MethodType method = tt.getMethod()
    IF method == NIL || (method.getTtype() != Type.Enum.proc
                                       && method.getTtype() != Type.Enum.func)
      ctx.error("First type in callback<> must be a method.", expr)
      RETURN NIL
    }

    # Collect the argument types.
    list<Declaration.C> argTypes = getArgTypes(expr, 1, FALSE, ctx)

    CallbackType cb = method.getCallback(argTypes, ctx)
    setCalledMethodType(cb, ctx)
    ctx.addUsedItem(cb)

    RETURN cb
  }

  # For |callback| where .methodType and .arguments have been set, fill in
  # .calledMethodType with the concatenation of normal and USE arguments.
  PROC setCalledMethodType(CallbackType callback, SContext ctx)
    # The called method is the same as the methodType but with the additional
    # arguments.  Make a copy so that we can add arguments.
    # Only create a new one when needed, otherwise the "Used" information gets
    # deleted.
    IF callback.calledMethodType == NIL
                                     || callback.calledMethodType.pName == NIL
      callback.calledMethodType = callback.methodType.copyType()
    ELSE
      callback.methodType.copyMethodValues(callback.calledMethodType)
    }
    # Set the type, used when the called method isused as a Declaration, e.g.
    # in gen.writeCallbackFunc().
    callback.calledMethodType.type = callback.calledMethodType

    # Copy the argument list so that we can add more arguments.
    MethodType method = callback.calledMethodType
    method.arguments = callback.methodType.arguments.copy()
    FOR arg IN callback.arguments
      IF arg.type != NIL
        IF arg.type.isAllocType(ctx)
          method.addArgument("",
                  arg.type.getClassType(ctx).allocDecl.type.getRefType(), NIL)
        ELSE
          method.addArgument("", arg.type, NIL)
        }
      }
    }
  }


  # Handle using a method as a reference, where the method has USE arguments.
  PROC generateClosureRef(int &undef, bool nameless,
                          Zui.Expression expr, Type leftDestType,
                          Type objectType,
                            Declaration decl, MethodType method, SContext ctx)
    CallbackType callback
    IF nameless
      # A nameless method does not need a declaration.
      callback = method.getCallback(ctx)
      IF callback == NIL
        undef += 5
      ELSEIF callback.calledMethodType == NIL && ctx.doError()
        LOG.internal("calledMethodType is NIL for \(method.name)")
      ELSE
        ctx.gen.writeClosureAlloc(callback, method, TRUE, undef, ctx)
      }
    ELSE
      Declaration callbackDecl = method.getCallbackDecl(ctx)
      callback = callbackDecl.type
      ctx.gen.refCast(ctx)
      IF expr != NIL
        IF objectType.getTtype() == Type.Enum.iobject
          # iobject.method
          ctx.gen.iobjectCallbackMember(decl, callbackDecl, objectType, expr,
                                              FALSE, ctx, leftDestType, FALSE)
        ELSE
          # object.method
          Output varnameOut = NEW()
          varnameOut.writing = ctx.out.writing
          genExpr(expr.getLeft(), ctx.copy(varnameOut), leftDestType)
          ctx.gen.member(varnameOut, NIL, objectType, callback,
                                               FALSE, callbackDecl.pName, ctx)
        }
      ELSE
        # Module.method
        ctx.gen.writeSymName(callbackDecl, callback, FALSE, ctx)
      }
    }

    # Call the alloc function to create and fill the struct.
    ctx.addUsedItem(Declaration.funcRef)
    IF callback != NIL
      ctx.addUsedItem(callback.calledMethodType)
    }
  }

  # Handle tuple<type1, type2>
  # Return the TupleType.
  FUNC generateTupleType(Zui.Expression expr, string name, SContext ctx
                        ) TupleType
    # Collect the argument types.
    list<Declaration.C> argTypes = getArgTypes(expr, 0, TRUE, ctx)

    # At the first pass check for duplicate names.
    IF ctx.scope.pass == 1
      set<string> names = NEW()
      FOR a IN argTypes
        IF a.name != ""
          IF names.has(a.name)
            ctx.error("Duplicate item name: " .. a.name, a.zuiPos)
          ELSE
            names.add(a.name)
          }
        }
      }
    }

    TupleType tt = TupleType.getTupleType(argTypes, expr.getPos(), ctx)
    ctx.addUsedItem(tt)

    RETURN tt
  }

  # "function(args)": method call
  FUNC generateMethodCall(Zui.MethodCall call, CallbackInfo cbInfo,
                            Type defaultRet, SContext ctx, Type destType) Type
    Type ret = defaultRet
    Zui.Expression nameExpr = call.getName()
    string funcName = nameExpr.getId().getName()
    bool isObjectMethod = nameExpr.getId().getDollar()
    VAR callExt = ZuiMethodCallExt.get(call)

    Type.Enum type = ctx.scope.getAType(
                              nameExpr.getId(), NEW(nameExpr.getPos(), ctx))
    int undef
    IF type == Type.Enum.proc || type == Type.Enum.func
                                          || type == Type.Enum.builtinMethod
      list<Zui.Expression> args = call.getArgumentList()
      list<Declaration.C> argTypeList =
                                  getDeclListFromArguments(args, ctx, FALSE)
      MethodType.FindFuncOptions options = searchParent

      # When producing C we never call an abstract class, because the method
      # is redefined in the context of the subclass.  For JS a non-abstract
      # method may call an abstract method, it will be defined by the
      # subclass later (make sure it has the same jsMName!).
      options.skipAbstract = ctx.gen.skipAbstractMethod()

      Declaration funcDecl = MethodType.findMatchingMethod(
                                   funcName, NIL, ctx.scope, isObjectMethod,
                                   argTypeList, args,
                              options, &undef, TRUE, call.getPos(), "", ctx)
      IF funcDecl != NIL
        IF funcDecl.type.<MethodType>.templateList != NIL
          # When using a template method, find it or add it.
          funcDecl = findMethodTemplate(funcDecl.type, argTypeList, ret,
                                                         call.getPos(), ctx)
        }
        IF funcDecl != NIL
          callExt.undefined += undef
          undef = 0
          ret = generateFunctionCall(funcDecl, call, cbInfo, ctx, destType)
        }
      }
    ELSEIF type == Type.Enum.procRef
        || type == Type.Enum.funcRef
        || type == Type.Enum.callback
      Declaration decl = ctx.scope.getDecl(funcName,
                                isObjectMethod, NEW(nameExpr.getPos(), ctx))
      IF decl == NIL
        undef = 2
      ELSE
        IF cbInfo != NIL
          ctx.error("Not yet supported for DEFER (callback)", nameExpr)
        }
        ret = ctx.gen.functionRefCall(call, decl, funcName, destType, ctx)
      }
    ELSE
      undef = 4
      IF ctx.doError()
        ctx.error("unknown function: " .. funcName, call.getPos())
      }
    }
    ZuiExpressionExt.get(nameExpr).undefined = undef
    callExt.undefined += undef

    RETURN ret
  }

  # "expr.method(args)" or "expr?.method(args)"
  # |destType| is a hint for the return type.
  # When |cbInfo| is not NIL produce arguments for a callback and fill in
  # information about the function.
  # Return the type of the result.
  FUNC generateMemberCall(Zui.MethodCall call, CallbackInfo cbInfo,
                                                   SContext ctx, Type destType
                         ) Type
    Zui.Expression nameExpr = call.getName()
    Zui.Expression objExpr = nameExpr.getLeft()

    # Figure out the type of what's before the last dot.  Pass NIL to get
    # the type as-is, without automatic conversions.
    Type type = genExpr(objExpr, ctx.copyNoOut())
    IF type == NIL || type.getTtype() == Type.Enum.unknown
      # We need to pass "destType" for NEW().something().  But we don't want
      # automatic conversion, so don't use genExpr().
      type = genExprChecked(objExpr, ctx.copyNoOut(), NEW(destType, FALSE))
    }

    IF type == NIL
      IF objExpr.getType() == Zui.ExprType.eINT
                                     || objExpr.getType() == Zui.ExprType.eNAT
        # Allow 123.Size().
        type = Type.anInt
      ELSEIF  objExpr.getType() == Zui.ExprType.eSTRING
        # Allow "123".Size().
        type = Type.aString
      }
    }

    VAR callExt = ZuiMethodCallExt.get(call)
    callExt.undefined = 0
    IF type == NIL || type.getTtype() == Type.Enum.unknown
      callExt.undefined = 3
      IF ctx.doError()
        # Do generate the objExpr to get the error message.
        int n = LOG.errorCount
        genExprChecked(objExpr, ctx, NEW(destType, FALSE))
        IF n == LOG.errorCount
          # If objExpr is a call to a PROC genExprChecked() does not produce
          # an error.
          ctx.error("Missing value", objExpr)
        }
      }
      RETURN Type.anUnknown
    }

    # Check the argument counts for predefined methods.
    string methodName = nameExpr.getRight().getId().getName()
    list<int> argCounts = %predefMethodArgs.get(methodName, NIL)
    IF argCounts != NIL
      checkArgCount(call, argCounts[0], argCounts[1], ctx)
    }

    # Use the effective type (in case it's a typedef).
    Type origType = type
    type = type.getEffType()
    Type.Enum ttype = type.getTtype()
    Type retType
    bool checkedCbInfo
    SWITCH ttype
      CASE Type.Enum.int
      CASE Type.Enum.int8
      CASE Type.Enum.int16
      CASE Type.Enum.int32
      CASE Type.Enum.intval
        retType = generateIntMethod(type, call, ctx)
      CASE Type.Enum.nat
      CASE Type.Enum.byte
      CASE Type.Enum.nat16
      CASE Type.Enum.nat32
      CASE Type.Enum.natval
        retType = generateNatMethod(type, call, ctx)
      CASE Type.Enum.float
      CASE Type.Enum.float32
      CASE Type.Enum.float80
      CASE Type.Enum.float128
      CASE Type.Enum.floatval
        retType = generateFloatMethod(type, call, ctx)
      CASE Type.Enum.bool
        retType = generateBoolMethod(type, call, ctx)
      CASE Type.Enum.status
        retType = generateStatusMethod(type, call, ctx)
      CASE Type.Enum.enum
        retType = generateEnumMethod(type, call, ctx)
      CASE Type.Enum.bits
        retType = generateBitsMethod(type, call, ctx)
      CASE Type.Enum.enumValue
      CASE Type.Enum.bitsValue
        retType = generateValueMethod(type, call, ctx)
      CASE Type.Enum.string
        retType = generateStringMethod(type, call, ctx)
      CASE Type.Enum.varString
        retType = generateVarStringMethod(type, call, ctx)
      CASE Type.Enum.byteString
        retType = generateByteStringMethod(type, call, ctx)
      CASE Type.Enum.varByteString
        retType = generateVarByteStringMethod(type, call, ctx)
      CASE Type.Enum.dyn
        retType = generateDynMethod(type, call, ctx)
      CASE Type.Enum.type
        retType = generateTypeMethod(type, call, ctx)
      CASE Type.Enum.array
        retType = generateArrayMethod(type, call, ctx, destType)
      CASE Type.Enum.list
        retType = generateListMethod(type, call, ctx, destType)
      CASE Type.Enum.dict
        retType = generateDictMethod(type, call, ctx, destType)
      CASE Type.Enum.tuple
        retType = generateTupleMethod(type, origType, call, ctx)
      CASE Type.Enum.object
      CASE Type.Enum.iobject
        retType = generateObjectCall(type, call, cbInfo, ctx, destType)
        checkedCbInfo = TRUE
      CASE Type.Enum.class
      CASE Type.Enum.module
      CASE Type.Enum.builtinModule
        retType = generateModuleCall(type, call, cbInfo, ctx, destType)
        checkedCbInfo = TRUE
      DEFAULT
        callExt.undefined++
        unsupportedMethod(methodName, ttype.ToString(), objExpr, ctx)
    }

    IF cbInfo != NIL && !checkedCbInfo
      ctx.error("Not yet supported for DEFER (member)", nameExpr)
    }

    RETURN retType
  }

  PROC unsupportedMethod(string methodName, string type,
                                         Zui.Expression objExpr, SContext ctx)
    IF ctx.doError()
      ctx.error("Method " .. methodName .. "() not supported for "
                                                             .. type, objExpr)
    }
  }

  # Call a library method.
  PROC genLibCall(Zui.MethodCall call, string moduleName, string methodName,
                  Zui.Expression objExpr, Type objType,
                  list<Type> argTypes, Type retType, SContext ctx)
    genLibCall(call, moduleName, methodName, objExpr, objType, argTypes,
                                                            NIL, retType, ctx)
  }

  PROC genLibCall(Zui.MethodCall call, string moduleName, string methodName,
                  Zui.Expression objExpr, Type objType,
                  list<Type> argTypes, Type varargsType,
                  Type retType, SContext ctx)
    Declaration methodDecl = DeclStore.getDecl(moduleName, methodName)
    VAR callExt = ZuiMethodCallExt.get(call)
    IF methodDecl == NIL
      # Module not loaded yet?
      IF ctx.doError()
        ctx.error("Cannot find " .. moduleName .. "." .. methodName,
                                                                call.getPos())
      }
      callExt.undefined = 6
      RETURN
    }
    IF varargsType == NIL ? argTypes.Size() != call.sizeArgument()
                          : argTypes.Size() > call.sizeArgument()
      IF ctx.doError()
        ctx.error("Expected \(argTypes.Size()) arguments"
            .. "\(varargsType == NIL ? "" : " or more"), "
            .. "found \(call.sizeArgument())", call.getPos())
      }
      callExt.undefined = 4
      RETURN
    }
    IF methodDecl.pName == NIL
      # May still have to load the module or it's a templated function.
      # Drop the leading "M" and trailing "MODULE".
      string mname = moduleName.slice(1, -7)
      Declaration mdecl = ctx.scope.getDecl(mname, NIL)
      IF mdecl == NIL
        Builtin.useModule(mname, ctx)
        callExt.undefined = 3
      ELSE
        string fname = methodName.slice(1)  # drop the "F"
        list<Declaration.C> argTypeList = getDeclListFromArguments(
                                           call.getArgumentList(), ctx, FALSE)
        # Insert the object type, passed as the first argument.
        Declaration.C arg = NEW("this")
        arg.type = objType
        argTypeList.insert(arg)

        IF varargsType != NIL
          Declaration.C vararg = NEW("vararg")
          vararg.type = varargsType
          argTypeList.add(vararg)
        }

        list<Declaration> decls = Declaration.findAll(
                                      mdecl.<ModuleType>.getDeclDict(), fname)
        FOR fdecl IN decls
          IF fdecl != NIL && fdecl ISA MethodType
            MethodType method = fdecl
            IF method.templateList != NIL
                           && method.getArgList().Size() == argTypeList.Size()
              methodDecl = findMethodTemplate(method, argTypeList, retType,
                                                           call.getPos(), ctx)
              BREAK
            }
          }
        }
      }
      IF methodDecl == NIL || methodDecl.pName == NIL
        callExt.undefined = 2
        IF ctx.doError()
          ctx.error("INTERNAL: Undefined library method: "
                            .. moduleName .. "." .. methodName, call.getPos())
        }
        RETURN
      }
    }

    # Generate the function name and the object.
    ctx.out.write(methodDecl.pName)
    ctx.out.write("(")
    ctx.gen.genArg(objExpr, ctx, objType)
    callExt.undefined += ZuiExpressionExt.get(objExpr).undefined
    ctx.addUsedItem(methodDecl)

    # Generate the arguments.
    FOR i IN 0 UNTIL argTypes.Size()
      ctx.out.write(", ")
      ctx.gen.genArg(call.getArgument(i), ctx, argTypes[i])
    }
    IF varargsType != NIL
      MethodType methodType = methodDecl.type
      # The Annotator needs to know the called method
      callExt.method = methodType
      ctx.out.write(", ")
      int varargIdx = argTypes.Size()
      callExt.firstVararg = varargIdx + 1
      Zui.Expression arg = call.getArgument(varargIdx)
      int skipThis = methodType.arguments[0].name == "this" ? 1 : 0
      IF arg.getType() == Zui.ExprType.eASSIGN
               && arg.getLeft().getStringValue()
                            == methodType.arguments[varargIdx + skipThis].name
        # Pass on argument as varargs.
        VAR right = arg.getRight()
        ctx.gen.genArg(right, ctx, methodType.varargsTuple)
        callExt.undefined += ZuiExpressionExt.get(right).undefined
      ELSE
        callExt.undefined += ctx.gen.writeVarargs(
              call, varargsType, methodType.varargsTuple,
              call.getArgumentList(), varargIdx, ctx)
      }
    }
    ctx.out.write(")")
  }

  # Given templated |interface| return the type of that interface with
  # |itemType|.  Currently only works with one template type.
  # Returns NIL if it can't be found (yet).
  FUNC interfaceTemplate(Declaration interface, Type itemType, SContext ctx
                        ) Type
    ClassType ct = interface.type.getClassType(ctx)
    list<Declaration> types = NEW()
    Declaration d = NEW(ct.templateNames[0])
    d.type = itemType
    types.add(d)

    Type classType
    bool found
    FOR template IN ct.templateList
      IF Declaration.typeListMatch(template.decls, types, ctx)
        # Only use it when it has been processed.
        IF template.stmt != NIL
          classType = ZuiStatementExt.get(template.stmt).typeObj
        }
        found = TRUE
        BREAK
      }
    }
    IF !found
      # Not seen this combination of types before.  Add it to the interface,
      # the next time it's encountered it will create the classType.
      Template template = NEW(types)
      ct.templateList.add(template)
      template.name = "" .. ct.templateList.Size()

      # Make sure the class gets another pass so that it can be
      # generated with the new template.
      ct.scope.setNeedPass(ctx)
    }

    RETURN classType
  }

  PROC generateSliceArgs(Zui.MethodCall call, bool dotnil, SContext ctx)
    Declaration.C decl = NEW("")
    decl.type = Type.anInt
    IF call.sizeArgument() > 1
      generateArgumentsCheck(call, "slice", ctx, [decl, decl], NIL, NIL)
    ELSE
      generateArgumentsCheck(call, "slice", ctx, [decl], NIL, NIL)
      ctx.out.write(", -1")
    }
    IF dotnil
      ctx.out.write(", 1")
    ELSE
      ctx.out.write(", 0")
    }
  }

  # Check the number of arguments for a string or byteString method.
  FUNC checkStringArgCount(Zui.MethodCall call, SContext ctx) status
    # Maps the method name to a list with min and max argument count.
    STATIC dict<string, list<int>> %stringArgCount = [
        "add": [1, 1],
        "asBytes": [0, 0],  # TODO: remove
        "asByteString": [0, 0],
        "asString": [0, 0],
        "asVarBytes": [0, 0],
        "asVarString": [0, 0],
        "binToInt": [0, 1],
        "Compare": [1, 1],
        "endsWith": [1, 1],
        "Equal": [1, 1],
        "find": [1, 2],
        "findLast": [1, 2],
        "get": [1, 1],
        "getByte": [1, 1],
        "getChar": [1, 1],
        "getCharSize": [1, 1],
        "hash": [0, 0],
        "hexToInt": [0, 1],
        "latin1ToString": [0, 0],
        "padLeft": [2, 2],
        "padRight": [2, 2],
        "quotedBinToInt": [0, 1],
        "quotedHexToInt": [0, 1],
        "quotedToInt": [0, 1],
        # "quotedRadixToInt": [0, 2], # TODO: accept radix argument
        "replace": [2, 2],
        "replaceAll": [2, 2],
        "reverse": [0, 0],
        "size": [0, 0],
        "Size": [0, 0],
        "slice": [1, 2],
        "split": [0, 1],
        "splitAnyOf": [1, 1],
        "startsWith": [1, 1],
        "toBytes": [0, 0],  # TODO: remove
        "toByteString": [0, 0],
        "toInt": [0, 1],
        "toFloat": [0, 1],  # optional argument: length
        # "radixToInt": [0, 2],  TODO: accept radix argument
        "toLower": [0, 0],
        "toLowerAscii": [0, 0],
        "ToString": [0, 1],
        "toUpper": [0, 0],
        "toUpperAscii": [0, 0],
        "toVarbytes": [0, 0],  # TODO: remove
        "toVarByteString": [0, 0],
        "toVarstring": [0, 0],  # TODO: remove
        "toVarString": [0, 0],
        "trim": [0, 0],
      ]

    RETURN checkArgCountTable(call, %stringArgCount, ctx)
  }

  FUNC checkArgCountTable(Zui.MethodCall call, dict<string, list<int>> table,
                                                          SContext ctx) status
    Zui.Expression nameExpr = call.getName()
    string name = nameExpr.getRight().getId().getName()
    list<int> minmax = table.get(name, NIL)
    IF minmax != NIL
      RETURN checkArgCount(call, minmax[0], minmax[1], ctx)
    }
    RETURN OK
  }

  # Check the number of arguments for a method.
  FUNC checkArgCount(Zui.MethodCall call, int min, int max, SContext ctx
                    ) status
    int n = call.sizeArgument()
    IF n >= min && n <= max
      RETURN OK
    }

    Zui.Expression nameExpr = call.getName()
    Zui.Id id
    IF nameExpr.getType() == Zui.ExprType.eID
      id = nameExpr.getId()
    ELSE
      id = nameExpr.getRight().getId()
    }
    string msg = id.getName() .. "() "
    IF n < min
      msg ..= "requires at least " .. min
      IF min == 1
        msg ..= " argument"
      ELSE
        msg ..= " arguments"
      }
      IF n > 0
        msg ..= ", found only " .. n
      }
    ELSEIF n > max
      IF max == 0
        msg ..= "does not accept arguments"
      ELSEIF max == 1
        msg ..= "takes only 1 argument, found " .. n
      ELSE
        msg ..= "takes up to " .. max .. " arguments, found " .. n
      }
    }
    ctx.error(msg, call.getPos())
    RETURN FAIL
  }

  FUNC generateStringMethod(Type type, Zui.MethodCall call, SContext ctx
                           ) Type
    Zui.Expression nameExpr = call.getName()
    string methodName = nameExpr.getRight().getId().getName()
    Zui.Expression objExpr = nameExpr.getLeft()
    VAR objExprExt = ZuiExpressionExt.get(objExpr)

    list<Zui.Expression> args = call.getArgumentList()
    bool dotnil = nameExpr.hasDotnil() && nameExpr.getDotnil()
    Type ret

    IF checkStringArgCount(call, ctx) == FAIL
      RETURN Type.anUnknown
    }

    VAR callExt = ZuiMethodCallExt.get(call)
    IF methodName == "size" || methodName == "Size"
      ctx.gen.stringSize(objExpr, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
      # TODO: remove asBytes and toBytes
    ELSEIF methodName == "ToString" && args.Size() == 1
      # string.ToString(format)
      ctx.gen.stringFormat(objExpr, args[0], ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aString
    ELSEIF methodName == "ToString"
        || methodName == "asBytes" || methodName == "asByteString"
        || methodName == "toBytes" || methodName == "toByteString"
      # no-op
      genExpr(objExpr, ctx, type)
      callExt.undefined += objExprExt.undefined
      IF methodName == "ToString"
        ret = Type.aString
      ELSE
        ret = Type.aByteString
      }
    ELSEIF methodName == "Type"
      ctx.gen.callType(type, call.getPos(), ctx)
      ret = Type.aType
    ELSEIF methodName == "Compare"
      ctx.gen.stringCompare(objExpr, dotnil, args, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "Equal"
      ctx.gen.stringEqual(objExpr, dotnil, args,  ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aBool
      # TODO: remove to Varstring
    ELSEIF methodName == "toVarString" || methodName == "toVarstring"
      ctx.gen.string2varString(objExpr, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.aVarString
    ELSEIF methodName == "toArray"
      ctx.gen.stringToArray(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      ret = ContainerType.NEW(Type.Enum.array, Type.aNat32, "toArray")
    ELSEIF methodName == "toInt"
      ctx.gen.stringToInt(call.getPos(), objExpr, dotnil, args, ctx, 10)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "binToInt"
      ctx.gen.stringToInt(call.getPos(), objExpr, dotnil, args, ctx, 2)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "toFloat"
      ctx.gen.stringToFloat(call.getPos(), objExpr, dotnil, args, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aFloat
    ELSEIF methodName == "format"
      ret = Type.aString
      genLibCall(call, "MSTRINGModule", "Fformat",
                               objExpr, Type.aString, [], Type.aDyn, ret, ctx)
    ELSEIF methodName == "hash"
      ctx.gen.byteStringHash(objExpr, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.aNat
    ELSEIF methodName == "hexToInt"
      ctx.gen.stringToInt(call.getPos(), objExpr, dotnil, args, ctx, 16)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "quotedToInt"
      ctx.gen.stringQuotedToInt(call.getPos(), objExpr, dotnil, args, ctx, 10)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "quotedBinToInt"
      ctx.gen.stringQuotedToInt(call.getPos(), objExpr, dotnil, args, ctx, 2)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "quotedHexToInt"
      ctx.gen.stringQuotedToInt(call.getPos(), objExpr, dotnil, args, ctx, 16)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "toLower"
      ctx.gen.stringToLower(objExpr, dotnil, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.aString
    ELSEIF methodName == "toUpper"
      ctx.gen.stringToUpper(objExpr, dotnil, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.aString
    ELSEIF methodName == "toLowerAscii"
      ctx.gen.stringToLowerAscii(objExpr, dotnil, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.aString
    ELSEIF methodName == "toUpperAscii"
      ctx.gen.stringToUpperAscii(objExpr, dotnil, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.aString
    ELSEIF methodName == "find"
      Type argType = genExpr(args[0], ctx.copyNoOut())
      IF argType.isIntType()
        # find(int c)
        ctx.gen.stringFindChar(objExpr, dotnil, args, ctx)
      ELSE
        # find(string s)
        # find(string s, int start)
        ctx.gen.stringFind(objExpr, dotnil, args, ctx)
      }
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "findLast"
      Type argType = genExpr(args[0], ctx.copyNoOut())
      IF argType.isIntType()
        # findLast(int c)
        ctx.gen.stringFindLastChar(objExpr, dotnil, args, ctx)
      ELSE
        # findLast(string s)
        IF args.Size() > 1
          ctx.error("Sorry, start index not yet supported for string", objExpr)
        }
        ctx.gen.stringFindLast(objExpr, dotnil, args, ctx)
      }
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "startsWith"
      ctx.gen.stringStartsWith(objExpr, dotnil, args, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aBool
    ELSEIF methodName == "endsWith"
      ctx.gen.stringEndsWith(objExpr, dotnil, args, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aBool
    ELSEIF methodName == "slice"
      ctx.gen.stringSlice(objExpr, dotnil, call, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aString
    ELSEIF methodName == "split"
      ret = ContainerType.NEW(Type.Enum.list, Type.aString, "list")
      IF call.sizeArgument() == 0
        genLibCall(call, "MSTRINGModule", "Fsplit",
                                          objExpr, Type.aString, [], ret, ctx)
      ELSE
        ctx.gen.stringSplit(objExpr, dotnil, args, ctx)
        callExt.undefined += objExprExt.undefined
      }
    ELSEIF methodName == "splitAnyOf"
      list<Type> argTypes = [Type.aString]
      ret = ContainerType.NEW(Type.Enum.list, Type.aString, "list")
      genLibCall(call, "MSTRINGModule", "FsplitAnyOf",
                                    objExpr, Type.aString, argTypes, ret, ctx)
    ELSEIF methodName == "escape"
      ret = Type.aString
      genLibCall(call, "MSTRINGModule", "Fescape",
                                          objExpr, Type.aString, [], ret, ctx)
    ELSEIF methodName == "replace"
      list<Type> argTypes = [Type.anInt, Type.anInt]
      ret = Type.aString
      genLibCall(call, "MSTRINGModule", "Freplace",
                                    objExpr, Type.aString, argTypes, ret, ctx)
    ELSEIF methodName == "replaceAll"
      list<Type> argTypes = [Type.anInt, Type.anInt]
      ret = Type.aString
      genLibCall(call, "MSTRINGModule", "FreplaceAll",
                                    objExpr, Type.aString, argTypes, ret, ctx)
    ELSEIF methodName == "trim"
      ret = Type.aString
      genLibCall(call, "MSTRINGModule", "Ftrim",
                                          objExpr, Type.aString, [], ret, ctx)
    ELSEIF methodName == "padLeft"
      list<Type> argTypes = [Type.anInt, Type.anInt]
      ret = Type.aString
      genLibCall(call, "MSTRINGModule", "FpadLeft",
                                    objExpr, Type.aString, argTypes, ret, ctx)
    ELSEIF methodName == "padRight"
      list<Type> argTypes = [Type.anInt, Type.anInt]
      ret = Type.aString
      genLibCall(call, "MSTRINGModule", "FpadRight",
                                    objExpr, Type.aString, argTypes, ret, ctx)
    ELSEIF methodName == "reverse"
      ret = Type.aString
      genLibCall(call, "MSTRINGModule", "Freverse",
                                          objExpr, Type.aString, [], ret, ctx)
    ELSE
      callExt.undefined++
      unsupportedMethod(methodName, "string", objExpr, ctx)
    }
    IF ret == NIL
      RETURN Type.anUnknown
    }
    RETURN ret
  }

  FUNC generateVarStringMethod(Type type, Zui.MethodCall call, SContext ctx
                              ) Type
    Zui.Expression nameExpr = call.getName()
    string methodName = nameExpr.getRight().getId().getName()
    Zui.Expression objExpr = nameExpr.getLeft()
    VAR objExprExt = ZuiExpressionExt.get(objExpr)

    list<Zui.Expression> args = call.getArgumentList()
    bool dotnil = nameExpr.hasDotnil() && nameExpr.getDotnil()
    Type ret

    IF checkStringArgCount(call, ctx) == FAIL
      RETURN Type.anUnknown
    }

    VAR callExt = ZuiMethodCallExt.get(call)
    IF methodName == "size" || methodName == "Size"
      ctx.gen.varStringSize(objExpr, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "ToString"
      ctx.gen.varString2string(objExpr, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.aString
      # TODO: remove toVarstring
    ELSEIF methodName == "toVarString" || methodName == "toVarstring"
      # no-op
      genExpr(objExpr, ctx, Type.aVarString)
      callExt.undefined += objExprExt.undefined
      ret = Type.aVarString
      # TODO: remove asVarBytes
    ELSEIF methodName == "asVarbytes" || methodName == "asVarByteString"
      genExpr(objExpr, ctx, Type.aVarString)
      callExt.undefined += objExprExt.undefined
      ret = Type.aVarByteString
    ELSEIF methodName == "toInt"
      # TODO: accept radix argument
      ctx.gen.varStringToInt(call.getPos(), objExpr, dotnil, args, ctx, 10)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "binToInt"
      ctx.gen.varStringToInt(call.getPos(), objExpr, dotnil, args, ctx, 2)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "hash"
      ctx.gen.varByteStringHash(objExpr, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "hexToInt"
      ctx.gen.varStringToInt(call.getPos(), objExpr, dotnil, args, ctx, 16)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "quotedToInt"
      callExt.undefined += objExprExt.undefined
      ctx.gen.varStringQuotedToInt(call.getPos(), objExpr, dotnil,
                                                                args, ctx, 10)
      ret = Type.anInt
    ELSEIF methodName == "quotedBinToInt"
      callExt.undefined += objExprExt.undefined
      ctx.gen.varStringQuotedToInt(call.getPos(), objExpr, dotnil,
                                                                 args, ctx, 2)
      ret = Type.anInt
    ELSEIF methodName == "quotedHexToInt"
      callExt.undefined += objExprExt.undefined
      ctx.gen.varStringQuotedToInt(call.getPos(), objExpr, dotnil,
                                                                args, ctx, 16)
      ret = Type.anInt
    ELSEIF methodName == "toLower"
      ctx.gen.varStringToLower(objExpr, dotnil, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.aVarString
    ELSEIF methodName == "toUpper"
      ctx.gen.varStringToUpper(objExpr, dotnil, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.aVarString
    ELSEIF methodName == "toLowerAscii"
      ctx.gen.varStringToLowerAscii(objExpr, dotnil, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.aVarString
    ELSEIF methodName == "toUpperAscii"
      ctx.gen.varStringToUpperAscii(objExpr, dotnil, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.aVarString
    ELSEIF methodName == "find"
      Type argType = genExpr(args[0], ctx.copyNoOut())
      IF argType.isIntType()
        # find(int c)
        ctx.gen.varStringFindChar(objExpr, dotnil, args, ctx)
      ELSE
        # find(string s)
        IF args.Size() > 1
          ctx.error("Sorry, start index not yet supported for string", objExpr)
        }
        ctx.gen.varStringFind(objExpr, dotnil, args, ctx)
      }
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "findLast"
      Type argType = genExpr(args[0], ctx.copyNoOut())
      IF argType.isIntType()
        # findLast(int c)
        ctx.gen.varStringFindLastChar(objExpr, dotnil, args, ctx)
      ELSE
        # findLast(string s)
        IF args.Size() > 1
          ctx.error("Sorry, start index not yet supported for string", objExpr)
        }
        ctx.gen.varStringFindLast(objExpr, dotnil, args, ctx)
      }
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "startsWith"
      ctx.gen.varStringStartsWith(objExpr, dotnil, args, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aBool
    ELSEIF methodName == "endsWith"
      ctx.gen.varStringEndsWith(objExpr, dotnil, args, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aBool
    ELSEIF methodName == "slice"
      ctx.gen.varStringSlice(objExpr, dotnil, call, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aVarString
    ELSEIF methodName == "add"
      # Note: no dotnil support.
      ctx.gen.varStringAdd(objExpr, args, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aVarString
    ELSEIF methodName == "split"
      ret = ContainerType.NEW(Type.Enum.list, Type.aString, "list")
      IF call.sizeArgument() == 0
        genLibCall(call, "MVARSTRINGModule", "Fsplit",
                                       objExpr, Type.aVarString, [], ret, ctx)
      ELSE
        ctx.gen.varStringSplit(objExpr, dotnil, args, ctx)
        callExt.undefined += objExprExt.undefined
      }
    ELSEIF methodName == "splitAnyOf"
      list<Type> argTypes = [Type.aString]
      ret = ContainerType.NEW(Type.Enum.list, Type.aString, "list")
      genLibCall(call, "MVARSTRINGModule", "FsplitAnyOf",
                                 objExpr, Type.aVarString, argTypes, ret, ctx)
    ELSE
      callExt.undefined++
      unsupportedMethod(methodName, "varString", objExpr, ctx)
    }
    IF ret == NIL
      RETURN Type.anUnknown
    }
    RETURN ret
  }

  FUNC generateByteStringMethod(Type type, Zui.MethodCall call, SContext ctx
                         ) Type
    Zui.Expression nameExpr = call.getName()
    string methodName = nameExpr.getRight().getId().getName()
    Zui.Expression objExpr = nameExpr.getLeft()
    VAR objExprExt = ZuiExpressionExt.get(objExpr)

    list<Zui.Expression> args = call.getArgumentList()
    bool dotnil = nameExpr.hasDotnil() && nameExpr.getDotnil()
    Type ret

    IF checkStringArgCount(call, ctx) == FAIL
      RETURN Type.anUnknown
    }

    VAR callExt = ZuiMethodCallExt.get(call)
    IF methodName == "size" || methodName == "Size"
      ctx.gen.byteStringSize(objExpr, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "Type"
      ctx.gen.callType(type, call.getPos(), ctx)
      ret = Type.aType
    ELSEIF methodName == "Compare"
      ctx.gen.byteStringCompare(objExpr, dotnil, args, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "Equal"
      ctx.gen.byteStringEqual(objExpr, dotnil, args,  ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aBool
    ELSEIF methodName == "latin1ToString" || methodName == "ToString"
      ret = Type.aString
      IF methodName == "ToString" && args.Size() == 1
        genLibCall(call, "MBYTESTRINGModule", "FToString__1",
                          objExpr, Type.aByteString, [Type.aString], ret, ctx)
      ELSE
        genLibCall(call, "MBYTESTRINGModule", "Flatin1ToString",
                                      objExpr, Type.aByteString, [], ret, ctx)
      }
    ELSEIF methodName == "asString"
      ctx.gen.byteString2string(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aString
      # TODO: remove toVarstring
    ELSEIF methodName == "toVarString" || methodName == "toVarstring"
      ctx.gen.byteString2varString(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aVarString
      # TODO: remove toVarbytes
    ELSEIF methodName == "toVarbytes" || methodName == "toVarByteString"
      ctx.gen.string2varString(objExpr, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.aVarByteString
    ELSEIF methodName == "get" || methodName == "getByte"
      ctx.gen.byteStringGetByte(objExpr, dotnil, args, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "getChar"
      ctx.gen.byteStringGetChar(objExpr, dotnil, args, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "hash"
      ctx.gen.byteStringHash(objExpr, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.aNat
    ELSEIF methodName == "getCharSize"
      ctx.gen.byteStringGetCharSize(objExpr, dotnil, args, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "find"
      Type argType = genExpr(args[0], ctx.copyNoOut())
      IF argType.isIntType()
        # find(int c)
        ctx.gen.byteStringFindByte(objExpr, dotnil, args, ctx)
      ELSE
        # find(byteString s)
        IF args.Size() > 1
          ctx.error("Sorry, start index not yet supported for string", objExpr)
        }
        ctx.gen.byteStringFind(objExpr, dotnil, args, ctx)
      }
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "findLast"
      Type argType = genExpr(args[0], ctx.copyNoOut())
      IF argType.isIntType()
        # findLast(int c)
        ctx.gen.byteStringFindLastByte(objExpr, dotnil, args, ctx)
      ELSE
        # findLast(byteString s)
        IF args.Size() > 1
          ctx.error("Sorry, start index not yet supported for string", objExpr)
        }
        ctx.gen.byteStringFindLast(objExpr, dotnil, args, ctx)
      }
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "startsWith"
      ctx.gen.byteStringStartsWith(objExpr, dotnil, args, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aBool
    ELSEIF methodName == "endsWith"
      ctx.gen.byteStringEndsWith(objExpr, dotnil, args, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aBool
    ELSEIF methodName == "slice"
      ctx.gen.byteStringSlice(objExpr, dotnil, call, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aByteString
    ELSEIF methodName == "split"
      ret = ContainerType.NEW(Type.Enum.list, Type.aByteString, "list")
      IF call.sizeArgument() == 0
        genLibCall(call, "MBYTESTRINGModule", "Fsplit",
                                      objExpr, Type.aByteString, [], ret, ctx)
      ELSE
        ctx.gen.byteStringSplit(objExpr, dotnil, args, ctx)
        callExt.undefined += objExprExt.undefined
      }
    ELSE
      callExt.undefined++
      unsupportedMethod(methodName, "byteString", objExpr, ctx)
    }
    IF ret == NIL
      RETURN Type.anUnknown
    }
    RETURN ret
  }

  FUNC generateVarByteStringMethod(Type type, Zui.MethodCall call, SContext ctx
                            ) Type
    Zui.Expression nameExpr = call.getName()
    string methodName = nameExpr.getRight().getId().getName()
    Zui.Expression objExpr = nameExpr.getLeft()
    VAR objExprExt = ZuiExpressionExt.get(objExpr)

    list<Zui.Expression> args = call.getArgumentList()
    bool dotnil = nameExpr.hasDotnil() && nameExpr.getDotnil()
    Type ret

    IF checkStringArgCount(call, ctx) == FAIL
      RETURN Type.anUnknown
    }

    VAR callExt = ZuiMethodCallExt.get(call)
    IF methodName == "size" || methodName == "Size"
      ctx.gen.varByteStringSize(objExpr, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "ToString"
      ctx.gen.varByteString2string(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aString
      # TODO: remove toVarstring and asVarstring
    ELSEIF methodName == "toVarstring" || methodName == "asVarstring"
        || methodName == "toVarString" || methodName == "asVarString"
      ctx.gen.varByteString2varString(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aVarString
      # TODO: remove toBytes
    ELSEIF methodName == "toByteString" || methodName == "toBytes"
      ctx.gen.varString2string(objExpr, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.aByteString
      # TODO: remove toVarbytes
    ELSEIF methodName == "toVarbytes" || methodName == "toVarByteString"
      # no-op
      genExpr(objExpr, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.aVarByteString
    ELSEIF methodName == "find"
      Type argType = genExpr(args[0], ctx.copyNoOut())
      IF argType.isIntType()
        # find(int c)
        ctx.gen.varByteStringFindByte(objExpr, dotnil, args, ctx)
      ELSE
        # find(string s)
        IF args.Size() > 1
          ctx.error("Sorry, start index not yet supported for string", objExpr)
        }
        ctx.gen.varByteStringFind(objExpr, dotnil, args, ctx)
      }
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "findLast"
      Type argType = genExpr(args[0], ctx.copyNoOut())
      IF argType.isIntType()
        # findLast(int c)
        ctx.gen.varByteStringFindLastByte(objExpr, dotnil, args, ctx)
      ELSE
        # findLast(string s)
        IF args.Size() > 1
          ctx.error("Sorry, start index not yet supported for string", objExpr)
        }
        ctx.gen.varByteStringFindLast(objExpr, dotnil, args, ctx)
      }
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "hash"
      ctx.gen.varByteStringHash(objExpr, ctx, type)
      callExt.undefined += objExprExt.undefined
      ret = Type.anInt
    ELSEIF methodName == "startsWith"
      ctx.gen.varByteStringStartsWith(objExpr, dotnil, args, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aBool
    ELSEIF methodName == "endsWith"
      ctx.gen.varByteStringEndsWith(objExpr, dotnil, args, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aBool
    ELSEIF methodName == "slice"
      ctx.gen.varByteStringSlice(objExpr, dotnil, call, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aVarByteString
    ELSEIF methodName == "add"
      # Note: dotnil not supported
      ctx.gen.varByteStringAdd(objExpr, args, ctx)
      callExt.undefined += objExprExt.undefined
      ret = Type.aVarByteString
    ELSEIF methodName == "split"
      ret = ContainerType.NEW(Type.Enum.list, Type.aByteString, "list")
      IF call.sizeArgument() == 0
        genLibCall(call, "MVARBYTESTRINGModule", "Fsplit",
                                   objExpr, Type.aVarByteString, [], ret, ctx)
      ELSE
        ctx.gen.varByteStringSplit(objExpr, dotnil, args, ctx)
        callExt.undefined += objExprExt.undefined
      }
    ELSE
      callExt.undefined++
      unsupportedMethod(methodName, "varByteString", objExpr, ctx)
    }
    IF ret == NIL
      RETURN Type.anUnknown
    }
    RETURN ret
  }

  FUNC generateIntMethod(Type type, Zui.MethodCall call, SContext ctx
                        ) Type
    Zui.Expression nameExpr = call.getName()
    string methodName = nameExpr.getRight().getId().getName()
    Zui.Expression objExpr = nameExpr.getLeft()
    VAR objExprExt = ZuiExpressionExt.get(objExpr)

    STATIC dict<string, list<int>> %intArgCount = [
        "abs": [0, 0],
        "asBytes": [0, 0],  # TODO: remove
        "asByteString": [0, 0],
        "asString": [0, 0],
        "isAlpha": [0, 0],
        "isAlphaAscii": [0, 0],
        "isDigit": [0, 0],
        "isHexDigit": [0, 0],
        "isLower": [0, 0],
        "isLowerAscii": [0, 0],
        "isUpper": [0, 0],
        "isUpperAscii": [0, 0],
        "isWhite": [0, 0],
        "isWhiteAscii": [0, 0],
        "size": [0, 0],
        "Size": [0, 0],
        "toHex": [0, 1],
        "toHexUpper": [0, 1],
        "toLowerAscii": [0, 0],
        "toQuotedString": [0, 0],
        "toUpperAscii": [0, 0],
      ]

    IF checkArgCountTable(call, %intArgCount, ctx) == FAIL
      RETURN NIL
    }

    list<Zui.Expression> args = call.getArgumentList()
    Type retType

    VAR callExt = ZuiMethodCallExt.get(call)
    # TODO: remove asBytes
    IF methodName == "asBytes" || methodName == "asByteString"
      ctx.gen.intAsByteString(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aByteString
    ELSEIF methodName == "asString"
      ctx.gen.intAsString(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aString
    ELSEIF methodName == "ToString"
      ctx.gen.intToString(objExpr,
          call.sizeArgument() == 1 ? call.getArgument(0) : NIL,
          Type.anInt, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aString
    ELSEIF methodName == "toQuotedString"
      retType = Type.aString
      genLibCall(call, "MINTModule", "FtoQuotedString",
                                        objExpr, Type.anInt, [], retType, ctx)
    ELSEIF methodName == "toHex" || methodName == "toHexUpper"
      retType = Type.aString
      IF call.sizeArgument() == 0
        genLibCall(call, "MINTModule",
                            methodName == "toHex" ?  "FtoHex" : "FtoHexUpper",
                                        objExpr, Type.anInt, [], retType, ctx)
      ELSE
        list<Type> argTypes = [Type.anInt]
        genLibCall(call, "MINTModule",
                      methodName == "toHex" ?  "FtoHex__1" : "FtoHexUpper__1",
                                  objExpr, Type.anInt, argTypes, retType, ctx)
      }
    ELSEIF methodName == "size" || methodName == "Size"
      ctx.gen.intSize(type, ctx)
      retType = Type.anInt
    ELSEIF methodName == "Type"
      ctx.gen.callType(type, call.getPos(), ctx)
      retType = Type.aType
    ELSEIF methodName == "Compare"
      ctx.gen.writeCompare(objExpr, args, Type.anInt, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.anInt
    ELSEIF methodName == "Equal"
      ctx.gen.writeEqual(objExpr, args, Type.anInt, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSEIF methodName == "isWhite"
      retType = Type.aBool
      genLibCall(call, "MINTModule", "FisWhite", objExpr, Type.anInt,
                                                             [], retType, ctx)
    ELSEIF methodName == "isDigit"
      ctx.gen.isDigit(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSEIF methodName == "isHexDigit"
      ctx.gen.isHexDigit(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSEIF methodName == "isAlpha"
      ctx.gen.isAlpha(objExpr, ctx)  # TODO
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSEIF methodName == "isLower"
      ctx.gen.isLower(objExpr, ctx)  # TODO
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSEIF methodName == "isUpper"
      ctx.gen.isUpper(objExpr, ctx)  # TODO
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSEIF methodName == "isWhiteAscii"
      retType = Type.aBool
      genLibCall(call, "MINTModule", "FisWhiteAscii",
                                        objExpr, Type.anInt, [], retType, ctx)
    ELSEIF methodName == "isAlphaAscii"
      ctx.gen.isAlpha(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSEIF methodName == "isLowerAscii"
      ctx.gen.isLower(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSEIF methodName == "isUpperAscii"
      ctx.gen.isUpper(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSEIF methodName == "toLowerAscii"
      ctx.gen.intToLowerAscii(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.anInt
    ELSEIF methodName == "toUpperAscii"
      ctx.gen.intToUpperAscii(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.anInt
    ELSEIF methodName == "abs"
      ctx.gen.intAbs(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aNat
    ELSEIF %floatArgs.has(methodName)
      # Do things like 999.sin(), use the int as a float.
      retType = genFloatFunc(call, methodName, objExpr, ctx)
    ELSE
      callExt.undefined++
      unsupportedMethod(methodName, "int", objExpr, ctx)
    }
    RETURN retType
  }

  FUNC generateNatMethod(Type type, Zui.MethodCall call, SContext ctx
                        ) Type
    Zui.Expression nameExpr = call.getName()
    string methodName = nameExpr.getRight().getId().getName()
    Zui.Expression objExpr = nameExpr.getLeft()
    VAR objExprExt = ZuiExpressionExt.get(objExpr)

    Type retType

    VAR callExt = ZuiMethodCallExt.get(call)
    IF methodName == "ToString"
      ctx.gen.natToString(objExpr,
          call.sizeArgument() == 1 ? call.getArgument(0) : NIL,
          Type.aNat, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aString
    ELSEIF methodName == "Type"
      ctx.gen.callType(type, call.getPos(), ctx)
      retType = Type.aType
    ELSEIF methodName == "Compare"
      ctx.gen.writeCompare(objExpr, call.getArgumentList(), Type.aNat, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.anInt
    ELSEIF methodName == "Equal"
      ctx.gen.writeEqual(objExpr, call.getArgumentList(), Type.aNat, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSEIF methodName == "toQuotedString"
      checkArgCount(call, 0, 0, ctx)
      retType = Type.aString
      genLibCall(call, "MNATModule", "FtoQuotedString",
                                        objExpr, Type.aNat, [], retType, ctx)
    ELSEIF methodName == "toHex" || methodName == "toHexUpper"
      checkArgCount(call, 0, 1, ctx)
      retType = Type.aString
      IF call.sizeArgument() == 0
        genLibCall(call, "MNATModule",
                            methodName == "toHex" ?  "FtoHex" : "FtoHexUpper",
                                        objExpr, Type.aNat, [], retType, ctx)
      ELSE
        list<Type> argTypes = [Type.anInt]
        genLibCall(call, "MNATModule",
                      methodName == "toHex" ?  "FtoHex__1" : "FtoHexUpper__1",
                                  objExpr, Type.aNat, argTypes, retType, ctx)
      }
    ELSE
      # Otherwise use the int method.
      retType = generateIntMethod(type, call, ctx)
    }
    RETURN retType
  }

  FUNC generateBoolMethod(Type type, Zui.MethodCall call, SContext ctx
                         ) Type
    Zui.Expression nameExpr = call.getName()
    string methodName = nameExpr.getRight().getId().getName()
    Zui.Expression objExpr = nameExpr.getLeft()
    VAR objExprExt = ZuiExpressionExt.get(objExpr)

    Type retType
    VAR callExt = ZuiMethodCallExt.get(call)
    IF methodName == "ToString"
      ctx.gen.boolToString(objExpr, call.getArgumentList(), ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aString
    ELSEIF methodName == "Size"
      ctx.gen.boolSize(ctx)
      retType = Type.anInt
    ELSEIF methodName == "Type"
      ctx.gen.callType(type, call.getPos(), ctx)
      retType = Type.aType
    ELSEIF methodName == "Compare"
      ctx.gen.writeCompare(objExpr, call.getArgumentList(), Type.aBool, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.anInt
    ELSEIF methodName == "Equal"
      ctx.gen.writeEqual(objExpr, call.getArgumentList(), Type.aBool, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSE
      callExt.undefined++
      unsupportedMethod(methodName, "bool", objExpr, ctx)
    }
    RETURN retType
  }

  FUNC generateStatusMethod(Type type, Zui.MethodCall call, SContext ctx
                           ) Type
    Zui.Expression nameExpr = call.getName()
    string methodName = nameExpr.getRight().getId().getName()
    Zui.Expression objExpr = nameExpr.getLeft()
    VAR objExprExt = ZuiExpressionExt.get(objExpr)

    Type retType
    VAR callExt = ZuiMethodCallExt.get(call)
    IF methodName == "ToString"
      ctx.gen.statusToString(objExpr, call.getArgumentList(), ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aString
    ELSEIF methodName == "Size"
      ctx.gen.statusSize(ctx)
      retType = Type.anInt
    ELSEIF methodName == "Type"
      ctx.gen.callType(type, call.getPos(), ctx)
      retType = Type.aType
    ELSEIF methodName == "Compare"
      ctx.gen.writeCompare(objExpr, call.getArgumentList(), Type.aStatus, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.anInt
    ELSEIF methodName == "Equal"
      ctx.gen.writeEqual(objExpr, call.getArgumentList(), Type.aStatus, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSE
      callExt.undefined++
      unsupportedMethod(methodName, "status", objExpr, ctx)
    }
    RETURN retType
  }

  FUNC generateEnumMethod(Type type, Zui.MethodCall call, SContext ctx
                         ) Type
    Zui.Expression nameExpr = call.getName()
    string methodName = nameExpr.getRight().getId().getName()
    Zui.Expression objExpr = nameExpr.getLeft()
    VAR objExprExt = ZuiExpressionExt.get(objExpr)

    Type retType
    EnumType enumType = type
    VAR callExt = ZuiMethodCallExt.get(call)
    IF methodName == "Type"
      ctx.gen.callEnumType(type, call.getPos(), ctx)
      retType = Type.aType
    ELSEIF methodName == "FromString" && enumType != NIL
      string close = ctx.gen.enumFromString(enumType, ctx)
      ctx.usingEnumName(enumType)
      ctx.gen.genArg(call.getArgument(0), ctx, Type.aString)
      callExt.undefined += objExprExt.undefined
      ctx.out.write(close)
      retType = enumType.getValueType(ctx)
    ELSE
      callExt.undefined++
      unsupportedMethod(methodName, "enum", objExpr, ctx)
    }
    RETURN retType
  }

  FUNC generateBitsMethod(Type type, Zui.MethodCall call, SContext ctx
                         ) Type
    Zui.Expression nameExpr = call.getName()
    string methodName = nameExpr.getRight().getId().getName()
    Zui.Expression objExpr = nameExpr.getLeft()

    Type retType
    VAR callExt = ZuiMethodCallExt.get(call)
    IF methodName == "Type"
      ctx.gen.callBitsType(type, call.getPos(), ctx)
      retType = Type.aType
    ELSE
      callExt.undefined++
      unsupportedMethod(methodName, "bits", objExpr, ctx)
    }
    RETURN retType
  }

  FUNC generateValueMethod(Type type, Zui.MethodCall call, SContext ctx
                          ) Type
    Zui.Expression nameExpr = call.getName()
    string methodName = nameExpr.getRight().getId().getName()
    Zui.Expression objExpr = nameExpr.getLeft()
    VAR objExprExt = ZuiExpressionExt.get(objExpr)

    Type retType
    Type enumType = type
    bool isBits
    IF type.getTtype() != Type.Enum.enumValue
      enumType = type.bitsMember
      isBits = TRUE
    }

    VAR callExt = ZuiMethodCallExt.get(call)
    # Handle enumValue.ToString()
    IF methodName == "ToString" && enumType != NIL
      string close = genEnumNameCall(enumType, nameExpr, ctx)
      # TODO: move to genC and genJS.
      IF isBits
        ctx.out.write("(((")
      }
      genExpr(objExpr, ctx, enumType)
      callExt.undefined += objExprExt.undefined
      IF isBits
        ValueType t = type.bitsMember
        ctx.out.write(") & " .. (t.mask << t.shift) .. ")")
        IF t.shift > 0
          ctx.out.write(" >> " .. t.shift)
        }
        ctx.out.write(")")
      }
      ctx.out.write(close)
      retType = Type.aString
    ELSEIF methodName == "value" && !isBits
      genExpr(objExpr, ctx, enumType)
      retType = Type.anInt
    ELSEIF methodName == "ToString" && isBits
      # TODO: List the members of the BITS instead of the int value.
      ctx.gen.intToString(objExpr, NIL, Type.aBits, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aString
    ELSE
      callExt.undefined++
      unsupportedMethod(methodName, "enum value", objExpr, ctx)
    }
    RETURN retType
  }

  FUNC generateDynMethod(Type type, Zui.MethodCall call, SContext ctx
                        ) Type
    Zui.Expression nameExpr = call.getName()
    string methodName = nameExpr.getRight().getId().getName()
    Zui.Expression objExpr = nameExpr.getLeft()
    VAR objExprExt = ZuiExpressionExt.get(objExpr)

    Type retType
    VAR callExt = ZuiMethodCallExt.get(call)
    IF methodName == "Type"
      ctx.gen.callDynType(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aType
    ELSEIF methodName == "ToString"
      IF call.sizeArgument() == 1
        genLibCall(call, "MDYNModule", "FToString__1",
                        objExpr, Type.aDyn, [Type.aString], Type.aString, ctx)
      ELSE
        ctx.gen.callDynToString(objExpr, ctx)
      }
      callExt.undefined += objExprExt.undefined
      retType = Type.aString
    ELSEIF methodName == "Size"
      ctx.gen.callDynSize(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.anInt
    ELSEIF methodName == "Compare"
      ctx.gen.writeCompare(objExpr, call.getArgumentList(), Type.aDyn, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.anInt
    ELSEIF methodName == "Equal"
      ctx.gen.writeEqual(objExpr, call.getArgumentList(), Type.aDyn, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSE
      callExt.undefined++
      unsupportedMethod(methodName, "dyn", objExpr, ctx)
    }
    RETURN retType
  }

  FUNC generateTypeMethod(Type type, Zui.MethodCall call, SContext ctx
                         ) Type
    Zui.Expression nameExpr = call.getName()
    string methodName = nameExpr.getRight().getId().getName()
    Zui.Expression objExpr = nameExpr.getLeft()
    VAR objExprExt = ZuiExpressionExt.get(objExpr)

    Type retType
    VAR callExt = ZuiMethodCallExt.get(call)
    IF methodName == "ToString"
      ctx.gen.callTypeToString(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aString
    ELSEIF methodName == "Size"
      ctx.gen.callTypeSize(type, ctx)
      retType = Type.anInt
    ELSEIF methodName == "Type"
      ctx.gen.callType(type, call.getPos(), ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aType
    ELSEIF methodName == "Compare"
      ctx.gen.writeCompare(objExpr, call.getArgumentList(), Type.aType, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.anInt
    ELSEIF methodName == "Equal"
      ctx.gen.writeEqual(objExpr, call.getArgumentList(), Type.aType, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSEIF methodName == "name"
      ctx.gen.callTypeName(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aString
    ELSE
      callExt.undefined++
      unsupportedMethod(methodName, "type", objExpr, ctx)
    }
    RETURN retType
  }

  FUNC generateTupleMethod(Type type, Type origType, Zui.MethodCall call,
                                                                  SContext ctx
                          ) Type
    Zui.Expression nameExpr = call.getName()
    string methodName = nameExpr.getRight().getId().getName()
    Zui.Expression objExpr = nameExpr.getLeft()

    Type retType
    VAR callExt = ZuiMethodCallExt.get(call)
    IF methodName == "Type"
      ctx.gen.callTupleType(type, call.getPos(), ctx)
      retType = Type.aType
    ELSEIF methodName == "ToString"
      ctx.gen.callTupleToString(call, origType, objExpr, ctx)
      callExt.undefined += ZuiExpressionExt.get(objExpr).undefined
      retType = Type.aString
    ELSE
      # TODO: Size()
      # TODO: Compare()
      # TODO: Equal()
      callExt.undefined++
      unsupportedMethod(methodName, "tuple", objExpr, ctx)
    }
    RETURN retType
  }

  FUNC generateArrayMethod(Type type, Zui.MethodCall call, SContext ctx,
                                                                 Type destType
                          ) Type
    VAR callExt = ZuiMethodCallExt.get(call)
    callExt.undefined = 0
    Type retType
    ContainerType.C containerType = type

    # Methods implemented in lib/ARRAYModule.zu are common to all languages.
    IF ArrayStuff.commonMethodCall(containerType, call, ctx, destType,
                                                             &retType) == FAIL
      retType = ctx.gen.arrayMethodCall(containerType, call, ctx, destType)
    }
    RETURN retType
  }

  FUNC generateListMethod(Type type, Zui.MethodCall call, SContext ctx,
                                                                 Type destType
                          ) Type
    VAR callExt = ZuiMethodCallExt.get(call)
    callExt.undefined = 0
    Type retType
    ContainerType.C containerType = type

    # Methods implemented in lib/LISTModule.zu are common to all languages.
    IF ListStuff.commonMethodCall(containerType, call, ctx, destType,
                                                             &retType) == FAIL
      retType = ctx.gen.listMethodCall(containerType, call, ctx, destType)
    }
    RETURN retType
  }

  FUNC generateDictMethod(Type type, Zui.MethodCall call, SContext ctx,
                                                                 Type destType
                          ) Type
    VAR callExt = ZuiMethodCallExt.get(call)
    callExt.undefined = 0
    Type retType
    ContainerType.C containerType = type

    # Methods implemented in lib/DICTModule.zu are common to all languages.
    IF DictStuff.commonMethodCall(containerType, call, ctx, destType,
                                                             &retType) == FAIL
      retType = ctx.gen.dictMethodCall(containerType, call, ctx, destType)
    }
    RETURN retType
  }

  # Float method names with the number of arguments.
  dict<string, int> %floatArgs = [
        "floor": 0,
        "ceil": 0,
        "round": 0,
        "trunc": 0,
        "abs": 0,
        "exp": 0,
        "log": 0,
        "log10": 0,
        "sin": 0,
        "sinh": 0,
        "cos": 0,
        "cosh": 0,
        "tan": 0,
        "tanh": 0,
        "asin": 0,
        "acos": 0,
        "atan": 0,
        "sqrt": 0,
        "pow": 1,
        "atan2": 1,
      ]

  FUNC genFloatFunc(Zui.MethodCall call, string methodName,
                                          Zui.Expression objExpr, SContext ctx
                   ) Type
    int argCount = %floatArgs[methodName]
    checkArgCount(call, argCount, argCount, ctx)
    ctx.gen.floatMethod(methodName, objExpr,
                    call.sizeArgument() == 1 ? call.getArgument(0) : NIL, ctx)
    VAR callExt = ZuiMethodCallExt.get(call)
    callExt.undefined += ZuiExpressionExt.get(objExpr).undefined
    RETURN Type.aFloat
  }

  FUNC generateFloatMethod(Type type, Zui.MethodCall call, SContext ctx
                          ) Type
    Zui.Expression nameExpr = call.getName()
    string methodName = nameExpr.getRight().getId().getName()
    Zui.Expression objExpr = nameExpr.getLeft()
    VAR objExprExt = ZuiExpressionExt.get(objExpr)

    list<Zui.Expression> args = call.getArgumentList()
    Type retType

    VAR callExt = ZuiMethodCallExt.get(call)
    IF methodName == "size" || methodName == "Size"
      checkArgCount(call, 0, 0, ctx)
      ctx.gen.floatSize(objExpr, type, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.anInt
    ELSEIF methodName == "ToString"
      ctx.gen.floatToString(objExpr,
          call.sizeArgument() == 1 ? call.getArgument(0) : NIL,
          Type.aFloat, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aString
    ELSEIF methodName == "Type"
      ctx.gen.callType(type, call.getPos(), ctx)
      retType = Type.aType
    ELSEIF methodName == "Compare"
      ctx.gen.writeCompare(objExpr, args, Type.aFloat, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.anInt
    ELSEIF methodName == "Equal"
      ctx.gen.writeEqual(objExpr, args, Type.aFloat, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSEIF methodName == "isNan"
      checkArgCount(call, 0, 0, ctx)
      ctx.gen.isNan(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSEIF methodName == "isInfinite"
      checkArgCount(call, 0, 0, ctx)
      ctx.gen.isInfinite(objExpr, ctx)
      callExt.undefined += objExprExt.undefined
      retType = Type.aBool
    ELSEIF %floatArgs.has(methodName)
      retType = genFloatFunc(call, methodName, objExpr, ctx)
    ELSE
      callExt.undefined++
      unsupportedMethod(methodName, type.typeName(), objExpr, ctx)
    }
    RETURN retType
  }

  # Write header for ToString() call on enum |enumSym|.
  # Returns a what is to be put after the argument.
  FUNC genEnumNameCall(Type enumType, Zui.Expression expr, SContext ctx
                      ) string
    IF enumType ISNOTA EnumValueType
      IF ctx.doError()
        ctx.error("INTERNAL: not an Enum value type", expr)
      }
      RETURN ""
    }
    EnumValueType.C enumValueType = enumType.<EnumValueType.C>
    IF enumValueType.enumType == NIL
      IF ctx.doError()
        ctx.error("INTERNAL: enumType is NIL", expr)
      }
      RETURN ""
    }

    ctx.usingEnumName(enumValueType.enumType)

    RETURN ctx.gen.enumName(enumValueType, ctx)
  }

  # object.method(args)
  # Return the function return type.
  FUNC generateObjectCall(Type origObject, Zui.MethodCall call,
                        CallbackInfo cbInfo, SContext ctx, Type destType) Type
    Type object = origObject
    Zui.Expression nameExpr = call.getName()                   # object.method
    Zui.Expression objExpr = nameExpr.getLeft()                # object
    string methodName = nameExpr.getRight().getId().getName()  # method
    Type retType

    VAR callExt = ZuiMethodCallExt.get(call)
    IF object.getClassType(ctx) == NIL
      callExt.undefined = 7
      IF ctx.doError()
        ctx.error("undefined class", nameExpr)
      }
    ELSE
      ClassType class = object.getClassType(ctx)

      # Get the type of the arguments, as far as they are known.
      list<Declaration.C> arglist = getDeclListFromArguments(
                                           call.getArgumentList(), ctx, FALSE)
      IF arglist == NIL
        ctx.error("INTERNAL: arglist is NIL", nameExpr)
        RETURN NIL
      }

      # Built-in methods.
      IF methodName == "Type"
        IF cbInfo != NIL
          ctx.error("Not yet supported for DEFER (object.Type)", nameExpr)
        }
        ctx.gen.callObjectType(call, class, object, objExpr, ctx)
        RETURN Type.aType
      }

      # Check if any of the arguments is an interface type.
      bool i_object_arg
      FOR d IN arglist
        IF d != NIL && d.type.getTtype() == Type.Enum.iobject
          i_object_arg = TRUE
        }
      }

      # Find a method that matches.
      int udef
      Declaration mdecl = findMethodArglist(class, methodName, TRUE,
                                      arglist, call.getArgumentList(),
                                      ctx,
                                      methodName == "ToString",
                                      searchParent,
                                      ctx.doError() && !i_object_arg,
                                      call.getPos(),
                                      " in class " .. class.name,
                                      &udef)
      callExt.undefined += udef
      Type mtype = mdecl?.type
      IF mtype == NIL && i_object_arg
        # This is possible if there is no method with the interface type and
        # there is a method for all possible classes.
        # Avoid checking for NIL everywhere
        # If there is a class without a matching method then
        # generateVirtualFunc() will produce an error.
        mtype = MethodType.NEW(Type.Enum.proc, methodName)
        mtype.<MethodType.C>.arguments = arglist
        mdecl = mtype
        mdecl.type = mtype
        mdecl.zuiDecl = NEW()
        mdecl.jsMName = methodName
        mdecl.jsFName = methodName
        # TODO: The interface type may be wrong if we don't generate a
        # virtual function.
        # IF ctx.doError()
        #  ctx.error("Wrong type of interface", nameExpr)
        # }
      }

      IF mdecl != NIL
              && mdecl.zuiDecl != NIL
              && mdecl.zuiDecl.hasType()
              && mdecl.zuiDecl.getType().getType() == Zui.TypeEnum.eALIAS
        # The method is an ALIAS, need to adjust the THIS part.
        # E.g.: ALIAS $member.list.size $size
        # Used as:  foo.bar.Size()
        # Works like: foo.bar.member.list.Size()
        # old objExpr is foo.bar
        # alias.getFrom() is member.list.size
        # new objExpr is member.list.foo.bar
        # Thus put "member.list" above the objExpr.
        # TODO: when does this not work correctly?
        # TODO: Copy the expression
        Zui.AliasType alias = mdecl.zuiDecl.getType().getAlias()
        CHECK.true(mdecl.zuiDecl.getDollar())
        CHECK.true(alias.getFrom().getType() == Zui.ExprType.eMEMBER)
        Zui.Expression left = alias.getFrom().getLeft()

        IF left.getType() == Zui.ExprType.eMEMBER
          # Need to concatenate foo.bar after member.list
          ctx.internalError("alias Member not supported here yet",
                                                                left.getPos())
        ELSE
          CHECK.true(left.getType() == Zui.ExprType.eID)
          Zui.Expression newTopExpr = NEW()
                              .setType(Zui.ExprType.eMEMBER)
                              .setPos(left.getPos())
          newTopExpr.setLeft(objExpr)
          newTopExpr.newRight()
                    .setType(Zui.ExprType.eID)
                        .setPos(left.getPos())
                    .newId()
                        .setName(left.getId().getName())

          objExpr = newTopExpr  # NOTE: not quite right!

          # Now the type of "object" has changed.
          object = genExpr(objExpr, ctx.copyNoOut())
        }
      }

      # If the method is templated, get an instance with the argument types.
      IF mtype != NIL && mtype ISA MethodType
                                     && mtype.<MethodType>.templateList != NIL
        # When using a template method, find it or add it.
        mdecl = findMethodTemplate(mtype, arglist, destType,
                                                           call.getPos(), ctx)
        mtype = mdecl?.type
      }


      IF mtype == NIL
        IF methodName == "ToString"
          # Call the default ToString method.
          ctx.gen.callObjectToString(call, class, object, objExpr, ctx)
          ctx.addUsedItem(Declaration.itemToString)
          retType = Type.aString
          IF cbInfo != NIL
            ctx.error("Not yet supported for DEFER (object.ToString)", objExpr)
          }
        ELSE
          # Error given by findMethodArglist().
          callExt.undefined += 5
        }
      ELSE
        IF mtype.getTtype() == Type.Enum.builtinMethod
          ctx.error("lib method NEW() not supported", call.getPos())
        ELSE
          string pName
          IF objExpr.getType() == Zui.ExprType.ePARENT
              || (objExpr.getType() == Zui.ExprType.eMEMBER
                  && objExpr.getRight().getId().getName() == "PARENT")
            # Need to use the method that was generated for the current class,
            # so that the type of "THIS" is correct.
            int depth = parentDepth(objExpr) + ctx.scope.classType.parentLevel
            pName = parentMethodName(ctx.scope.classType, depth, mtype, ctx)
            markParentMethodUsed(ctx.scope.classType, pName, ctx)
          ELSE
            pName = mdecl.pName
            ctx.addUsedItem(mdecl)
          }

          # Now that we have the method, if any template types are used by the
          # arguments, correct the argument types.

          IF mtype.getTtype() == Type.Enum.procRef
                                      || mtype.getTtype() == Type.Enum.funcRef
            IF ctx.doError() && call.sizeArgument() != mtype.getArgList().Size()
              ctx.error("Expected " .. mtype.getArgList().Size()
                  .. " arguments, found " .. call.sizeArgument(), call.getPos())
            }
            retType = ctx.gen.methodRefCall(
                           call, mtype, object, objExpr, pName, destType, ctx)
            IF cbInfo != NIL
              ctx.error("Not yet supported for DEFER (methodRef)", nameExpr)
            }
          ELSEIF mtype.isMethodType()
            IF mtype.<MethodType>.hasUseArguments()
              # Method has USE arguments, use its callback.
              # TODO: handle iobject arguments
              IF i_object_arg || object.getTtype() == Type.Enum.iobject
                IF ctx.doError()
                  ctx.error("Sorry, cannot call method if it's not clear what class the object belongs to", call.getPos())
                }
              ELSE
                # The callback is stored in the object, used instead of the
                # normally called method.  objectCall() must use something
                # like functionRefCall().
                mdecl = mtype.<MethodType>.getCallbackDecl(ctx)
                ctx.addUsedItem(mdecl)
              }
            }
            IF cbInfo == NIL
              retType = ctx.gen.objectCall(call, i_object_arg, arglist,
                                 mdecl, object, objExpr, pName, destType, ctx)
            ELSE
              MethodType method = mdecl.type
              cbInfo.methodType = method
              cbInfo.arguments = method.getArgList()
              retType = method.returnType
            }
          ELSE
            IF ctx.doError()
              ctx.error("() after " .. mtype.typeName() .. " not expected",
                                                                     nameExpr)
            }
          }
        }
      }
    }
    RETURN retType
  }

  # Find method |name| in members of |parent| (class or module).
  # When needed, match arguments from |args| and use return type |destType|.
  # Use |pos| for the position of the error message and append |msg|.
  # Also use |pos| for symUse.
  # When |doError| is FALSE don't give any error message.
  # When |options.searchParent| is TRUE also search parents of |parent|.
  FUNC findMethod(Type parent,
                  string name,
                  bool objectMethod,
                  Zui.MethodCall call,
                  SContext ctx,
                  bool noneOK,
                  MethodType.FindFuncOptions options,
                  bool doError,
                  string msg,
                  int &undef
                 ) Declaration
    # get the type of the arguments, as far as they are known.
    list<Zui.Expression> args = call.getArgumentList()
    list<Declaration.C> arglist = getDeclListFromArguments(args, ctx, FALSE)
    Zui.Position pos = call.getPos()

    Declaration mdecl = findMethodArglist(parent, name, objectMethod,
                                     arglist, args,
                                     ctx, noneOK, options,
                                     doError, pos, msg, undef)
    Type mtype = mdecl?.type
    IF mtype != NIL && mtype.<MethodType.C>.templateList != NIL
      # When using a template method, find it or add it.
      mdecl = findMethodTemplate(mtype, arglist, NIL, pos, ctx)
    }
    RETURN mdecl
  }

  # Find a class or module method.
  # |arglist| is the types of the arguments.
  # |args| is the arguments themselves, to be used for error messages.
  # When |i_object_arg| is TRUE do not give an error when there is a function
  # but arguments don't match.
  FUNC findMethodArglist(Type parent,
                         string name,
                         bool objectMethod,
                         list<Declaration.C> arglist,
                         list<Zui.Expression> args,
                         SContext ctx,
                         bool noneOK,
                         MethodType.FindFuncOptions options,
                         bool doError,
                         Zui.Position pos,
                         string msg,
                         int &undef
                        ) Declaration
    IF parent == NIL
      RETURN NIL
    }
    Scope scope = ctx.scope

    # Find any member with the right name and visibility.
    SymUse symUse = options.allowInvisible ? NIL : NEW(pos, ctx)
    Declaration decl
    IF objectMethod
      decl = parent.findObjectMember(name, symUse, options, FALSE)
    ELSE
      decl = parent.findMember(name, symUse)
    }

    IF decl == NIL
      IF doError
        # Try to find any method with the right name, any visibility.
        IF objectMethod
          decl = parent.findObjectMember(name, NIL, options, FALSE)
        ELSE
          decl = parent.findMember(name, NIL)
        }
        IF decl == NIL
          # There is no method with this name.
          IF !noneOK
            ctx.error("Unknown method " .. name .. "() " .. msg, pos)
          }
          RETURN NIL
        }

        # There is a member but it's not visible.
        symUse.doError = TRUE
        IF (objectMethod
            ? parent.findObjectMember(name, symUse, options, FALSE) == NIL
            : parent.findMember(name, symUse) == NIL)
          ctx.error("Method not visible: " .. name .. "() " .. msg, pos)
        }
      }
      RETURN NIL
    }

    Type type = decl.type
    IF type.getTtype() != Type.Enum.procRef
                                       && type.getTtype() != Type.Enum.funcRef
      decl = MethodType.findMatchingMethod(name, parent, NIL,
                                       objectMethod, arglist, args,
                                       options, undef, doError, pos, msg, ctx)
    }

    RETURN decl
  }

  BITS GetSymArg
    bool $useType
    bool $reportError
    bool $unknownIsUndef  # when symbol type is unknown increment |undefined|
    bool $dropLast        # drop the last item (used for return type)
  }

  # Given a list of function argument expressions, return a list of
  # declarations with the types of those arguments.
  # |args| is a list of arguments with type specs.
  FUNC getDeclListFromArguments(list<Zui.Expression> args,
                                SContext ctx,
                                bool reportError
                               ) list<Declaration.C>
    IF args == NIL || args.Size() == 0
      RETURN []
    }

    list<Declaration.C> ret = NEW()
    FOR expr IN args
      string name = ""
      IF expr.getType() == Zui.ExprType.eASSIGN
        # name = expr
        name = expr.getLeft().getStringValue()
        expr = expr.getRight()
      }
      Type type = genExpr(expr, ctx.copyNoOut())
      IF ctx.doError() && reportError
                      && (type == NIL || type.getTtype() == Type.Enum.unknown)
        # produce the error message
        type = genExpr(expr, ctx)
      }

      IF type == NIL
        type = Type.anUnknown
        IF reportError
          ctx.error("Unknown argument type", expr)
        }
      ELSE
        # Don't want NoAllocType here, use what it wraps.
        type = type.getEffType()
      }

      Declaration.C decl = NEW(name)
      decl.type = type
      decl.zuiDecl = NEW()
      ret.add(decl)
      IF type ISNOT Type.anUnknown
        decl.addDependsOn(type)
      }
    }
    RETURN ret
  }

  # Given a list of types, return a list of declarations with the types of
  # those arguments.
  # Return the number of undefined symbols in |undef|.
  FUNC getDeclListFromTypes(list<Zui.Type> types,
                            SContext ctx,
                            GetSymArg gsarg,
                            int &undef
                            ) list<Declaration.C>
    IF types == NIL || types.Size() == 0
      undef = 0
      RETURN []
    }

    list<Declaration.C> ret = NEW()
    FOR t IN types
      IF t.getIsReturn()
        BREAK
      }
      Zui.Expression expr = t.getName()
      VAR exprExt = ZuiExpressionExt.get(expr)
      Type type = generateObjDeclType(expr, ctx.copyNoOut())
      IF ctx.doError() && gsarg.reportError
                      && (type == NIL || type.getTtype() == Type.Enum.unknown
                                                     || exprExt.undefined > 0)
        # get the error message
        type = generateObjDeclType(expr, ctx)
      }

      IF type == NIL
        type = Type.anUnknown
        undef += 10
        IF gsarg.reportError
          ctx.error("Unknown argument type", expr)
        }
      ELSE
        IF type.getTtype() == Type.Enum.unknown
          undef += 2
        }
      }
      undef += ZuiExpressionExt.get(expr).undefined

      Declaration.C decl = NEW("")
      decl.type = type
      ret.add(decl)
      IF type ISNOT Type.anUnknown
        decl.addDependsOn(type)
      }
    }

    RETURN ret
  }

  # Generate NEW() for |destType|.
  FUNC generateEmptyNewCall(Zui.Position pos, Type destType, SContext ctx) int
    Zui.MethodCall call = NEW()
    call.setPos(pos)
    int undef
    generateNewCall(&undef, call, NIL, ctx, FALSE, destType)
    RETURN undef
  }

  FUNC generateNewCall(Zui.Statement stmt, SContext ctx) int
    # NEW(arg)
    int undef
    IF !ctx.scope.flags.insideNew
      ctx.error("NEW() can only be used as a statement inside NEW()", stmt)
    ELSEIF ctx.scope.classType != NIL
      ctx.gen.beforeCallStatement(stmt.getPos(), ctx)

      ctx.out.writeIndent(ctx.scope.depth)
      generateNewCall(&undef, stmt.getMethodCall(), NIL, ctx, TRUE,
                                              ctx.scope.classType.getObject())
      ctx.gen.statementLineEnd(ctx.out)
    }
    RETURN undef
  }

  # |typeName| is what comes before the NEW().  Can be NIL.
  # Thus for Z.Pos.NEW() |typeName| is Z.Pos.
  FUNC generateNewCall(int &undef,
                       Zui.MethodCall call,
                       Zui.Expression typeName,
                       SContext ctx,
                       bool useThisIn,
                       Declaration dest
                      ) Type
    Zui.Position pos = call.getPos()
    bool useThis = useThisIn
    undef = 0

    Type destType = dest?.type
    Type newType = destType
    bool noAlloc = destType != NIL && destType.isNoAlloc()
                                   && !destType.<NoAllocType>.needAlloc()
    string noAllocName = noAlloc ? dest.pName : NIL

    IF typeName != NIL && typeName.getType() == Zui.ExprType.eTYPESPEC
      # ClassName<Type>.NEW()
      newType = generateDeclType(typeName, ctx.copyNoOut(), markUsed,
                                                  NEW(typeName.getPos(), ctx))
      undef += ZuiExpressionExt.get(typeName).undefined
    }
    Type effType = newType?.getEffType()
    Type.Enum newTtype = newType?.getTtype()
    IF newType != NIL && newTtype == Type.Enum.string
      IF typeName != NIL
        ctx.error("Type.NEW() for string not supported", call.getPos())
      ELSE
        # handle NEW(array [, startIdx[, endIdx]])
        IF noAllocName != NIL
          ctx.error("Cannot use a not allocated string", call.getPos())
        }
        ctx.gen.writeNewString(call, undef, ctx)
        RETURN Type.aString
      }
    ELSEIF newType != NIL && newTtype == Type.Enum.array
      IF typeName != NIL && typeName.getType() != Zui.ExprType.eTYPESPEC
        ctx.error("Type.NEW() for array not supported", call.getPos())
      ELSE
        ctx.gen.writeArrayAlloc(effType, noAllocName, call, undef, ctx)
        RETURN newType
      }
    ELSEIF newType != NIL && newTtype == Type.Enum.list
      IF typeName != NIL && typeName.getType() != Zui.ExprType.eLIST
                               && typeName.getType() != Zui.ExprType.eTYPESPEC
        ctx.error("Type.NEW() for list not supported", call.getPos())
      ELSE
        ctx.gen.writeListAlloc(effType, noAllocName, call, undef, ctx)
        RETURN newType
      }
    ELSEIF newType != NIL && newTtype == Type.Enum.dict
      IF typeName != NIL && typeName.getType() != Zui.ExprType.eDICT
                               && typeName.getType() != Zui.ExprType.eTYPESPEC
        ctx.error("Type.NEW() for dict not supported", pos)
      ELSEIF effType.<ContainerType>.keyType == NIL
        ++undef
        IF ctx.doError()
          ctx.error("Key type unknown", pos)
        }
      ELSEIF call.sizeArgument() > 1
        IF ctx.doError()
          ctx.error("No arguments expected", pos)
        }
      ELSE
        ctx.gen.writeDictAlloc(effType, noAllocName, call, ctx)
        RETURN newType
      }
    ELSEIF newType != NIL && newTtype == Type.Enum.callback
      IF typeName != NIL && typeName.getType() != Zui.ExprType.eTYPESPEC
        ctx.error("Type.NEW() for callback not supported", call.getPos())
      ELSE
        ctx.gen.writeCallbackAlloc(effType, noAllocName, NIL, call, undef, ctx)
        RETURN newType
      }
    ELSEIF newType != NIL && newTtype == Type.Enum.tuple
      IF typeName != NIL && typeName.getType() != Zui.ExprType.eTYPESPEC
        ctx.error("Type.NEW() for tuple not supported", call.getPos())
      ELSE
        ctx.gen.writeTupleAlloc(effType, noAllocName, call, undef, ctx)
        RETURN newType
      }
    ELSEIF newType != NIL && (newTtype == Type.Enum.varByteString
                                 || newTtype == Type.Enum.varString)
      IF typeName != NIL
        ctx.error("Type.NEW() for " .. newTtype.ToString()
                                                     .. " not supported", pos)
      ELSE
        ctx.gen.newVarByteString(noAllocName, ctx)
        RETURN newType
      }
    ELSEIF typeName == NIL
            && (destType == NIL
                || !(destType.getTtype() == Type.Enum.class
                    || destType.getTtype() == Type.Enum.object
                    || (destType.getTtype() == Type.Enum.iobject
                           && destType.getEffType().<ClassRefType.C>.isAuto)))
      ++undef
      IF ctx.doError()
        IF destType != NIL && destType.getTtype() == Type.Enum.iobject
          ctx.error("Cannot use NEW() for an interface object", pos)
        ELSE
          ctx.error("Do not know what class name to use for NEW()", pos)
        }
      }
    ELSE
      Type class
      string name = "NEW"
      IF typeName == NIL
        # NEW()  without preceding items: use destination class
        class = destType
        IF class.getClassType(ctx) != NIL
          class = class.getClassType(ctx)
        }
      ELSEIF typeName.getType() == Zui.ExprType.ePARENT
         || (typeName.getType() == Zui.ExprType.eMEMBER
             && typeName.getRight().getId().getName() == "PARENT")
        # PARENT.NEW()
        useThis = TRUE
        class = ctx.scope.classType
        Type topClass = class
        IF class == NIL
          ctx.error("using PARENT while not in a class", pos)
        }
        Zui.Expression left = typeName
        int level = 1 + class.<ClassType.C>.parentLevel
        WHILE left.getType() == Zui.ExprType.eMEMBER
          IF left.getRight().getId().getName() != "PARENT"
            ctx.error("Expected .PARENT", left)
            BREAK
          }
          IF topClass == NIL || topClass.<ClassType.C>.parent == NIL
            ctx.error("not this many parents", left)
            BREAK
          }
          topClass = topClass.<ClassType.C>.parent

          left = left.getLeft()
          IF left.getType() == Zui.ExprType.eTHIS
            # THIS.PARENT.NEW() is equal to PARENT.NEW().
            BREAK
          }
          IF left.getType() != Zui.ExprType.ePARENT
                                     && left.getType() != Zui.ExprType.eMEMBER
            ctx.error("Expected THIS or PARENT", left)
            BREAK
          }
          ++level
        }

        # The method may actually be defined in a class higher up, effectively
        # using PARENT.PARENT.NEW().  The only way to find out is to check
        # that the method is found in the current class.  If not, go up an
        # extra level, until reaching the top of the class hierarchy.
        WHILE TRUE
          name = "NEW__p" .. level
          Declaration pd = findMethod(class, name, TRUE, call,
                                               ctx, TRUE, 0, FALSE, "", undef)
          IF pd != NIL
            BREAK
          }
          topClass = topClass.<ClassType.C>.parent
          IF topClass == NIL
            BREAK
          }
          ++level
        }
      ELSE
        SymUse symUse = NEW(typeName.getPos(), ctx)
        class = generateDeclType(typeName, ctx.copyNoOut(), markUsed, symUse)
        undef += ZuiExpressionExt.get(typeName).undefined
        IF class == NIL || class.getTtype() != Type.Enum.class
          ++undef
          IF ctx.doError()
            IF class == NIL
              symUse.doError = TRUE
              IF generateDeclType(typeName, ctx, markUsed, symUse) == NIL
                ctx.error("class not found: " .. ZuiFile.expr2String(typeName),
                                                                          pos)
              }
            ELSE
              ctx.error("not a class: " .. ZuiFile.expr2String(typeName), pos)
            }
          }
        ELSEIF class.getClassType(ctx) != NIL
          class = class.getClassType(ctx)
        }
      }

      IF class == NIL || class.getTtype() != Type.Enum.class
                                                     || class.isAbstract()
        ++undef
        IF ctx.doError()
          IF class != NIL
            ctx.error("class not usable for NEW(): " .. class.name, pos)
          ELSE
            ctx.error("class not usable for NEW()", pos)
          }
        }
      ELSE
        ClassType classType = class
        Declaration finishDecl = getFinishMethod(classType.scope, ctx)

        Declaration mdecl = findMethod(classType, name, TRUE, call,
                            ctx, TRUE, searchParent, ctx.doError(), "", undef)
        MethodType mtype = mdecl?.type
        IF mtype == NIL
          # No matching NEW() method found.
          IF name != "NEW" || call.hasArgument()
            ++undef
            IF ctx.doError()
              IF name != "NEW"
                ctx.error("no matching NEW method found in parent", pos)
              ELSE
                # Default NEW() doesn't have arguments.
                ctx.error("no matching NEW method found", pos)
              }
            }
          }
          # Find a real $Init() method, not one added empty.
          Declaration initDecl = findUsefulInit(classType.scope)
          ctx.addUsedItem(initDecl)
          IF noAlloc
            ctx.gen.writeNoAllocClear(classType.pName, initDecl, finishDecl,
                                                                    dest, ctx)
            destType.<NoAllocType>.setIobjectType(classType, ctx)
          ELSEIF initDecl != NIL
            ctx.gen.writeObjectInit(initDecl, classType, dest, ctx)
          ELSE
            # Default NEW() sets everything to NIL/zero/FALSE
            ctx.gen.writeAlloc(classType.pName, finishDecl, ctx.out, ctx)
          }
        ELSEIF mtype.produce != NIL
          ctx.error("lib method NEW() not supported", pos)
        ELSE
          # Matching NEW() method found, call it.
          ctx.out.write(mdecl.pName .. "(")

          # Write "THIS, " or "NULL, ", depending on whether we are already
          # in a NEW() method.
          Declaration initDecl
          IF noAlloc
            initDecl = findUsefulInit(classType.scope)
            destType.<NoAllocType>.setIobjectType(classType, ctx)
          }
          ctx.gen.writeNewArg(useThis, noAlloc ? classType.pName : NIL,
                                      dest, initDecl, finishDecl,
                                      call.hasArgument(), ctx)
          VAR callExt = ZuiMethodCallExt.get(call)
          callExt.undefined = 0
          generateArguments(call, "NEW", mtype, ctx)
          undef += callExt.undefined
          ctx.out.write(")")
        }

        IF mdecl != NIL && (undef == 0 || usedWhenUndefined)
          ctx.addUsedItem(mdecl)
        }
        IF undef == 0 || usedWhenUndefined
          ctx.addUsedItem(classType)
        }

        # The result is an object of the class.
        RETURN classType.getObject()
      }
    }
    RETURN NIL
  }

  # Several ways of generating code for a member:
  # parent         PARENT.something
  # Enum value:    enum.name                  ->  "99"
  #                module.submodule.enum.name ->  "99"
  # Bits value:    flags.member               ->  "((Vflags & M) >> N)"
  # Module member: module.name                ->  "Vmodule_name"
  #                module.submodule.name      ->  "Vmodule_submodule_name"
  # Class member:  whatever.name              ->  whatever "->name"
  FUNC generateMember(Zui.Expression expr, SContext ctx, ExprArg exprArg,
                                                                 Type defRet
                    ) Type
    Zui.Expression left = expr.getLeft()
    string name = expr.getRight().getId().getName()
    Scope scope = ctx.scope
    Type ret = defRet

    IF name == "PARENT"
      IF expr.hasDotnil() && expr.getDotnil()
        ctx.error("Cannot use, ?. here.", expr)
      }
      Type type = getParentMember(expr, ctx, defRet)
      IF type == NIL
        ret = NIL
      ELSE
        ret = type.getValueType(ctx)
      }
    ELSEIF left.getType() == Zui.ExprType.eID && left.getId().getName() == "T"
      # "T.something".
      IF expr.hasDotnil() && expr.getDotnil()
        ctx.error("Cannot use, ?. here.", expr)
      }
      IF exprArg.destType() != NIL
                            && exprArg.destType().getTtype() == Type.Enum.type
        # Using T.int, T.bool, etc. in a switch.
        ctx.gen.writeTtype(name, expr.getRight().getPos(), ctx)
        ret = Type.aType
        ZuiExpressionExt.get(expr).undefined = 0
      ELSE
        Declaration decl = TModule.getDecl(name, ctx)
        IF decl == NIL && ctx.doError()
          ctx.error("T." .. name .. " unknown", expr)
        }
        ret = decl?.type
      }
    ELSE
      # Call genExpr() to find out what is on the left side.
      Type leftType = genExpr(left, ctx.copyNoOut())
      IF leftType != NIL && (leftType.getTtype() == Type.Enum.enum
                          || leftType.getTtype() == Type.Enum.enumValue)
        # Enum value
        IF expr.hasDotnil() && expr.getDotnil()
          ctx.error("Cannot use ?. here.", expr)
        }
        ret = genEnumMember(expr, leftType, exprArg.destType(), ctx, defRet)
      ELSEIF leftType != NIL && leftType.getTtype() == Type.Enum.bitsValue
        # BITS value
        IF expr.hasDotnil() && expr.getDotnil()
          ctx.error("Sorry, ?. not implemented yet for bits.", expr)
        }
        ret = genBitsMember(expr, leftType, exprArg.destType(), ctx, defRet)
      ELSEIF leftType != NIL && (leftType.getTtype() == Type.Enum.builtinModule
                              || leftType.getTtype() == Type.Enum.module)
        ret = genModuleMember(expr, leftType, exprArg, ctx, defRet)
      ELSEIF leftType != NIL && leftType.getTtype() == Type.Enum.tuple
        ret = genTupleMember(expr, leftType.<TupleType>, exprArg, ctx)
      ELSE
        # Assume a class member.  Cannot always be detected, thus also use
        # when leftType is NIL.
        ret = genClassMember(expr, exprArg, ctx, defRet)
      }
    }
    RETURN ret
  }

  # .. operator
  FUNC generateConcat(Zui.Expression expr, Type.Enum destEnum, SContext ctx
                    ) Type
    Type.Enum resType = resultType(expr, ctx)
    IF resType == Type.Enum.stringval
      ctx.gen.byteStringValue(expr, ctx)
      IF destEnum == Type.Enum.byteString || destEnum == Type.Enum.varByteString
        RETURN Type.aByteString
      }
      RETURN Type.aString
    }

    IF destEnum == Type.Enum.varByteString || resType == Type.Enum.varByteString
      ctx.gen.concatVarStringOp(expr, ctx, Type.aVarByteString)
      RETURN Type.aVarByteString
    }
    IF destEnum == Type.Enum.varString || resType == Type.Enum.varString
      ctx.gen.concatVarStringOp(expr, ctx, Type.aVarString)
      RETURN Type.aVarString
    }

    Type destType = (destEnum == Type.Enum.byteString
                                           || resType == Type.Enum.byteString)
                    ? Type.aByteString : Type.aString

    # Normal string/byteString concatenation: when left/right is also
    # concatenation make a list.
    IF ctx.out.writing && (expr.getLeft().getType() == Zui.ExprType.eCONCAT
                         || expr.getRight().getType() == Zui.ExprType.eCONCAT)
      list<Zui.Expression> concats = NEW()
      getContatExpressions(expr, concats)
      ctx.gen.concatStringOp(concats, ctx, destType)
    ELSE
      ctx.gen.concatStringOp(expr, ctx, destType)
    }
    RETURN destType
  }

  PROC getContatExpressions(Zui.Expression expr, list<Zui.Expression> concats)
    IF expr.getType() == Zui.ExprType.eCONCAT
      getContatExpressions(expr.getLeft(), concats)
      getContatExpressions(expr.getRight(), concats)
    ELSE
      concats.add(expr)
    }
  }

  # Generate a type from a list.
  # Either a built-in list type or an object that has a NEW() method that
  # takes a list.
  FUNC generateList(Zui.Expression expr, bool lvalue, Declaration dest,
                                                          SContext ctx) Type
    IF lvalue
      ctx.error("Unexpected list", expr)
    }

    Type destType = dest?.type?.getEffType()
    bool noAlloc = destType != NIL && dest.type.isNoAlloc()
    string noAllocName = noAlloc ? dest.pName : NIL
    VAR exprExt = ZuiExpressionExt.get(expr)

    Type destItemType
    exprExt.undefined = 0
    IF destType != NIL
      IF destType.getTtype() == Type.Enum.object
                                   || destType.getTtype() == Type.Enum.iobject
        # Allow initializing any object from a list if there is a NEW()
        # method that takes a list.
        destItemType = ctx.gen.listInitStart(expr, noAlloc ? dest : NIL,
                                                                ctx, destType)
        noAllocName = NIL  # do not use for newListInit()

        # This will call a method, the expr is not at toplevel.
        exprExt.toplevelVar = NIL
      ELSEIF destType ISA ContainerType
                               && destType.<ContainerType.C>.itemType != NIL
        destItemType = destType.<ContainerType.C>.itemType
      ELSEIF expr.sizeListItem() > 0
        destItemType = ZuiExpressionExt.get(expr.getListItem(0)).resultType
      ELSE
        destItemType = Type.anUnknown
      }
    }

    # Tuple created from a list initializer.
    IF destType?.getTtype() == Type.Enum.tuple
      TupleType effType = destType.getEffType()
      IF effType.types.Size() != expr.sizeListItem()
        ctx.error("Wrong number of items", expr)
      ELSE
        ctx.gen.newTupleInit(expr, noAllocName, effType, ctx)
      }
      RETURN destType
    }

    Type itemType
    Type.Enum ttype
    IF destType != NIL && destType.getTtype() == Type.Enum.array
      itemType = ctx.gen.newArrayInit(expr, noAllocName, destItemType, ctx)
      ttype = Type.Enum.array
    ELSE
      itemType = ctx.gen.newListInit(expr, noAllocName, destItemType, ctx)
      ttype = Type.Enum.list
    }

    IF destType != NIL && (destType.getTtype() == Type.Enum.object
                                  || destType.getTtype() == Type.Enum.iobject)
      ctx.gen.listInitTail(ctx)
      IF destType.getTtype() == Type.Enum.iobject
        # Return the object type, so that a conversion object2iobject is done
        # when needed.
        RETURN destType.getClassType(ctx).getObject()
      }
      RETURN destType
    }

    IF itemType != NIL
      IF itemType.getTtype() == Type.Enum.class
        itemType = itemType.getValueType(ctx)
      }
    }
    ContainerType ret = NEW(ttype, itemType, "list")
    RETURN ret
  }

  # Generate a type from a dict: [key: value, key: value]
  # Either a built-in dict type or an object that has a NEW() method that
  # takes a dict.
  FUNC generateDict(Zui.Expression expr, bool lvalue, Declaration dest,
                                                          SContext ctx) Type
    Type destType = dest?.type
    bool noAlloc = destType != NIL && dest.type.isNoAlloc()
    string noAllocName = noAlloc ? dest.pName : NIL
    VAR exprExt = ZuiExpressionExt.get(expr)

    ContainerType.C type
    exprExt.undefined = 0
    IF destType != NIL && destType.getTtype() == Type.Enum.object
      # Allow initializing any object from a dict if there is a NEW()
      # method that takes a dict.
      type = ctx.gen.dictInitStart(expr, noAlloc ? dest : NIL, ctx, destType)
      noAllocName = NIL  # don't use for newDictInit()

      # This will call a method, the expr is not at toplevel.
      exprExt.toplevelVar = NIL
    ELSE
      type = ContainerType.NEW(Type.Enum.dict, "dict")
    }

    ctx.gen.newDictInit(expr, noAllocName, ctx, type, destType)

    IF destType != NIL && destType.getTtype() == Type.Enum.object
      ctx.gen.listInitTail(ctx)
      RETURN destType
    }
    RETURN type
  }

  # Call |decl|.  call.undefined will be set.
  FUNC generateFunctionCall(Declaration decl, Zui.MethodCall call,
                              CallbackInfo cbInfo, SContext ctx, Type destType
                           ) Type

    MethodType.C method = decl.type
    VAR args = method.getArgList()
    Type ret = method.returnType
    VAR callExt = ZuiMethodCallExt.get(call)
    IF destType != NIL && destType.getTtype() != Type.Enum.unknown && ret == NIL
      IF ctx.doError()
        ctx.error("PROC does not have a return value", call.getPos())
      }
    }

    # When the method has USE arguments we need to invoke the callback that
    # was created where the method was defined.
    IF method.hasUseArguments()
      # If the method is defined outside of the current method, the reference
      # needs to be passed into the current method.
      Declaration callbackDecl = checkAutoUse(decl, ctx)
      ret = ctx.gen.functionRefCall(call, callbackDecl, "cb", destType, ctx)
      ctx.addUsedItem(callbackDecl)
      IF cbInfo != NIL
        ctx.error("Not supported for DEFER (USE)", call.getName())
      }
    ELSE
      callExt.undefined = 0
      IF cbInfo != NIL
        cbInfo.methodType = method
        cbInfo.arguments = method.getArgList()
      ELSE
        # Special case: ZUT.registerAction() marks a method as used, does not
        # produce code.
        IF method.name == "registerAction"
              && call.getName().getType() == Zui.ExprType.eMEMBER
              && call.getName().getLeft().getType() == Zui.ExprType.eID
              && call.getName().getLeft().getId().getName() == "ZUT"
          registerAction(call, ctx)
        ELSE
          bool moreArgs = call.sizeArgument() > 0
                                             && args != NIL && args.Size() > 0
          ctx.gen.writeMethodCall(method, moreArgs, ctx)
          generateArgumentsCheck(call, method.name, ctx, args, method, destType)
          ctx.out.write(")")
        }
      }
    }

    # Only mark the function as used when there are no undefined symbols.
    # Might pick another method if the function argument types change.
    IF callExt.undefined == 0 || usedWhenUndefined
      ctx.addUsedItem(method)
    }

    RETURN ret
  }

  # ZUT.registerAction(class, method): mark an action method as used in the
  # current context.
  PROC registerAction(Zui.MethodCall call, SContext ctx)
    VAR args = call.getArgumentList()
    IF args.Size() != 2 || args[0].getType() != Zui.ExprType.eSTRING
                        || args[1].getType() != Zui.ExprType.eSTRING
      ctx.error("Invalid arguments, expected two strings", call.getPos())
    ELSE
      string className = args[0].getStringValue()
      string methodName = args[1].getStringValue()
      LOG.info("  Registering \(className).\(methodName)")
      Declaration classDecl = ctx.scope.getDecl(className, FALSE, NIL)
      IF classDecl == NIL
        ctx.error("Class not found: \(className)", call.getPos())
      ELSEIF classDecl.type.getTtype() != Type.Enum.class
        ctx.error("\(className) is not a class", call.getPos())
      ELSE
        ClassType class = classDecl.type.getClassType(ctx)
        list<Declaration> methodDecls =
                                class.scope.objectMembers.get(methodName, NIL)
        IF methodDecls == NIL
          ctx.error("method \(methodName) not found in \(className)",
                                                                call.getPos())
        ELSEIF methodDecls.Size() > 1
          ctx.error("More than one \(methodName) in \(className)",
                                                                call.getPos())
        ELSE
          Declaration decl = methodDecls[0]
          IF decl.type.getTtype() != Type.Enum.func
            ctx.error("\(methodName) in \(className) is not a function",
                                                                call.getPos())
          ELSE
            MethodType method = decl.type.getEffType()
            IF method.arguments.Size() != 1
              ctx.error("\(methodName) in \(className) must have one argument",
                                                                call.getPos())
            ELSE
              # TODO: check argument type to be ZUT.Event.
              ctx.addUsedItem(method)
              IF ctx.out.writing
                ctx.topScope.registerAction(method)
              }
            }
          }
        }
      }
    }
  }

  # When calling a method with USE arguments, check that its callback is
  # accessible in the current method.  If not, pass it in with an auto-USE
  # argument.
  # Return the callback to use.
  FUNC checkAutoUse(Declaration decl, SContext ctx) Declaration
    MethodType.C calledMethod = decl.type
    Declaration callbackDecl = calledMethod.getCallbackDecl(ctx)

    Scope scope = ctx.scope
    WHILE scope != NIL
      IF scope IS decl.scopeBase
        BREAK
      }
      IF scope ISA MethodScope
        # Have to pass the callback as an auto-USE argument to the current
        # method.
        MethodType.C method = scope.outerDecl.type
        int idx = -1
        IF method.autoArguments == NIL
          method.autoArguments = NEW()
        ELSE
          FOR i IN 0 UNTIL method.autoArguments.Size()
            IF method.autoArguments[i].pName == callbackDecl.pName
              idx = i
              BREAK
            }
          }
        }
        IF idx == -1
          method.autoArguments.add(callbackDecl)
          # Need to make a pass over the method.
          method.scope.setNeedPass(ctx)
        ELSE
          # Overwrite, just in case something changed.
          method.autoArguments[idx] = callbackDecl
        }
        IF callbackDecl.autoZuiDecl != NIL
          # generateMethodUseArgs() will add the argument, which is to be used
          # for the actual function call.
          RETURN ZuiDeclarationExt.get(callbackDecl.autoZuiDecl).decl
        }
        IF ctx.out.writing
          ctx.internalError("Missing arg for auto-USE", decl.zuiPos)
        }

        # In earlier pass: don't have the argument yet.
        RETURN callbackDecl
      }
      scope = scope.outer
    }

    RETURN callbackDecl
  }

  PROC generateArgumentsCheck(Zui.MethodCall call, string funcName,
                                       SContext ctx,
                                       MethodType methodType,
                                       Type destType)
    generateArgumentsCheck(call, funcName, ctx, methodType.getArgList(),
                                                         methodType, destType)
  }

  # Generate all arguments for a function call.
  # Give an error if there are not enough items to make the arguments.
  PROC generateArgumentsCheck(Zui.MethodCall call, string funcName,
                                       SContext ctx, list<Declaration.C> args,
                                       MethodType methodType,
                                       Type destType)
    int n = generateArguments(call, funcName, args, methodType, ctx)
    IF args != NIL && n < args.Size()
      IF ctx.doError()
        ctx.error("Expected " .. args.Size() .. " arguments for "
                 .. funcName .. "()" .. ", found only " .. n, call.getPos())
      }
    }
  }

  FUNC generateArguments(Zui.MethodCall call, string funcName,
                                      MethodType methodType, SContext ctx) int
      RETURN generateArguments(call, funcName, methodType.getArgList(),
                                                              methodType, ctx)
  }

  # Generate arguments for a function call.
  # |methodArgs| is the list of expected arguments (can be NIL).
  # When |methodType.varargs| is TRUE the last argument is "type ... name".
  # Return the number of arguments generated.
  FUNC generateArguments(Zui.MethodCall call, string funcName,
                              list<Declaration.C> methodArgs,
                                      MethodType methodType, SContext ctx) int
    Declaration.C nextDecl
    string comma = ""
    Zui.Expression arg
    VAR callArgs = call.getArgumentList()
    int optionalArgCount = methodType?.optionalArgCount
    bool varargs = methodType?.varargs
    VAR callExt = ZuiMethodCallExt.get(call)

    # Reorder arguments passed by name
    FOR idx IN 0 UNTIL callArgs.Size()
      IF callArgs[idx].getType() == Zui.ExprType.eASSIGN
        # Found first named argument.  Rearrange the arguments in the call to
        # match the called method.
        list<Zui.Expression> newCallArgs
        IF idx > 0
          newCallArgs = callArgs.slice(0, idx - 1)
        ELSE
          newCallArgs = NEW()
        }
        int firstNamed = idx
        int argIdx
        FOR USE argIdx IN firstNamed UNTIL methodArgs.Size()
          IF varargs && argIdx >= methodArgs.Size() - 1
            BREAK
          }

          bool found
          string usedName = methodArgs[argIdx].name
          FOR i IN firstNamed UNTIL callArgs.Size()
            IF usedName == callArgs[i].getLeft().getStringValue()
              newCallArgs.add(callArgs[i].getRight())
              found = TRUE
              BREAK
            }
          }
          IF !found
            IF argIdx >= methodArgs.Size() - optionalArgCount
              # use the default value for a missing optional argument
              newCallArgs.add(methodArgs[argIdx].zuiDecl.getInit())
            ELSE
              ctx.error("\(usedName) not found in call of \(funcName)",
                                                              call.getPos())
            }
          }
        }

        # Named argument for varargs: add the following arguments with the
        # name.
        WHILE argIdx < callArgs.Size()
          newCallArgs.add(callArgs[argIdx])
          ++argIdx
        }

        callArgs = newCallArgs
        BREAK
      }
    }

    int index
    FOR USE index IN 0 UNTIL methodArgs.Size()
      nextDecl = methodArgs[index]
      IF varargs && index == methodArgs.Size() - 1
        BREAK
      }
      IF index < callArgs.Size()
        arg = callArgs[index]
      ELSEIF index >= methodArgs.Size() - optionalArgCount
        # use the default value for a missing optional argument
        arg = nextDecl.zuiDecl.getInit()
      ELSE
        BREAK
      }

      ctx.out.write(comma)
      ctx.gen.writeArgExpr(arg, ctx, nextDecl?.type)
      callExt.undefined += ZuiExpressionExt.get(arg).undefined

      ++index
      comma = ", "
    }

    IF varargs
      callExt.method = methodType  # The Annotator needs to know the method type
      callExt.firstVararg = index + 1
      ctx.out.write(comma)
      arg = callArgs[index]
      IF arg != NIL && arg.getType() == Zui.ExprType.eASSIGN
                   && arg.getLeft().getStringValue() == methodArgs[index].name
        # Pass on argument as varargs.
        Zui.Expression right = arg.getRight()
        ctx.gen.writeArgExpr(right, ctx, methodType.varargsTuple)
        callExt.undefined += ZuiExpressionExt.get(right).undefined
      ELSE
        # Generate varargs as: newArray().add(arg1).add(arg2)
        callExt.undefined += ctx.gen.writeVarargs(
                                call, nextDecl?.type, methodType.varargsTuple,
                                callArgs, index, ctx)
      }
      index = methodArgs.Size()
    }

    IF ctx.doError() && methodArgs != NIL && index != methodArgs.Size()
      ++callExt.undefined
      IF methodArgs == NIL || index >= methodArgs.Size()
        ctx.error("too many arguments for " .. funcName
                                   .. ", expected " .. methodArgs.Size(), arg)
      ELSE
        nextDecl = methodArgs[index]
        ctx.error("missing " .. nextDecl.type.typeName() .. " argument "
                          .. (nextDecl.name == NIL ? index : nextDecl.name),
                                                              call.getPos())
      }
    }

    RETURN index
  }

  # Generate a library module method call.
  # Return the type of the result.
  FUNC generateBuiltinMethodCall(Declaration.C decl, Zui.MethodCall call,
                                             CallbackInfo cbInfo, SContext ctx
                                ) Type
    IF cbInfo != NIL
      ctx.error("Not yet supported for DEFER (builtin)", call.getName())
    }
    Type ret
    VAR callExt = ZuiMethodCallExt.get(call)
    IF decl.type.getTtype() == Type.Enum.builtinMethod
      callExt.undefined = 0
      decl.type.<MethodType.C>.produce(decl, call, ctx)
      ret = decl.type.<MethodType.C>.returnType
      ctx.addUsedItem(decl)
    ELSE
      ret = Type.anUnknown
      callExt.undefined = 10
      IF ctx.doError()
        ctx.error("unexpected module function type: "
                            .. decl.type.getTtype().ToString(), call.getPos())
      }
    }

    RETURN ret
  }

  # Like generateVarname(), but special handling for PARENT.
  PROC generateVarnameParent(Zui.Expression expr, SContext ctx, Type destType)
    IF ZuiFile.isParentExpr(expr)
      ZuiExpressionExt.get(expr).undefined = 0
      ctx.out.write(ctx.scope.thisName)
      RETURN
    }
    generateVarname(expr, ctx, destType)
  }

  #
  # Generate "var", or "class.member", "module.member", etc.
  # |destType| is a hint for the resulting type.
  # TODO: "module.object.member"
  # Return the symbol_T of the item.  NIL if not known.
  #
  FUNC generateVarname(Zui.Expression expr, SContext ctx, Type destType
                     ) Declaration
    IF expr.getType() == Zui.ExprType.eSTRING
      ctx.gen.stringValue(expr.getStringValue(), ctx)
      ZuiExpressionExt.get(expr).undefined = 0
      RETURN Type.aString
    }
    RETURN generateLVarname(expr, FALSE, ctx, destType)
  }

  # Generate a variable name for assigning to.
  FUNC generateLVarname(Zui.Expression expr, bool lvalue,
                                                 SContext ctx, Type destType
                       ) Declaration
    ZuiExpressionExt.get(expr).undefined = 0
    RETURN generateVarnamePart(expr, lvalue, ctx, destType)
  }

  # Recursively produce a variable or object member name.
  # |destType| is a hint for the resulting type.
  # When |lvalue| is true need to have something to assign to.
  # Does not reset expr.undefined.
  # Return the symbol_T of the item.  NIL if not known.
  FUNC generateVarnamePart(Zui.Expression expr, bool lvalue,
                                                 SContext ctx, Type destType
                         ) Declaration
    Declaration decl

    SWITCH expr.getType()
      CASE Zui.ExprType.eID
        decl = generateVarnameId(expr, lvalue, ctx, destType)
        IF decl != NIL && decl.type != NIL
                                  && decl.type.getTtype() != Type.Enum.unknown
                                                 && ctx.out ISNOT Output.noOut
          checkPercentMatch(expr.getId(), decl.type, expr, ctx)
        }

      CASE Zui.ExprType.eTHIS
        IF !ctx.scope.isClassScope()
          ctx.error("THIS not in class context", expr)
        ELSE
          ctx.out.write(ctx.scope.thisName)
          decl = ctx.scope.classType.getObject()
        }

      CASE Zui.ExprType.ePARENT
        ctx.error("invalid use of PARENT", expr)

      CASE Zui.ExprType.eCALL
        IF lvalue
          ctx.error("cannot call a method here", expr)
        ELSE
          decl = generateCall(expr.getMethodCall(), NIL, ctx, destType)
          ZuiExpressionExt.get(expr).undefined =
                          ZuiMethodCallExt.get(expr.getMethodCall()).undefined
        }

      CASE Zui.ExprType.eNEWCALL
        IF lvalue
          ctx.error("cannot call NEW here", expr)
        ELSE
          int undef
          decl = generateNewCall(&undef,
                              expr.getMethodCall(), NIL, ctx, FALSE, destType)
          ZuiExpressionExt.get(expr).undefined = undef
        }

      CASE Zui.ExprType.eMEMBER
        decl = generateVarnameMember(expr, ctx, destType)

      CASE Zui.ExprType.eSUBSCRIPT
        decl = generateVarnameSubscript(expr, lvalue, ctx, destType)

      CASE Zui.ExprType.eTYPECAST
        decl = generateVarnameTypecast(expr, lvalue, ctx, destType)

      CASE Zui.ExprType.eLIST
        decl = generateList(expr, lvalue, destType, ctx)

      DEFAULT
        ctx.error("ExprType " .. expr.getType().ToString()
                                                     .. " not expected", expr)
    }

    RETURN decl
  }

  # Generate an ID part of an expression.
  # Return the declaration of the variable.
  FUNC generateVarnameId(Zui.Expression expr, bool lvalue,
                                  SContext ctx, Type destType) Declaration
    Type type
    VAR exprExt = ZuiExpressionExt.get(expr)
    SymUse symUse = NEW(expr.getPos(), ctx)
    Declaration decl = ctx.scope.getDecl(expr.getId(), symUse)
    type = decl?.type
    IF type == NIL
      exprExt.undefined++
      IF ctx.doError()
        symUse.doError = TRUE
        IF ctx.scope.getDecl(expr.getId(), symUse) == NIL
          ctx.error("symbol " .. expr.getId().getName() .. " not found",
                                                                     expr)
        }
      }
    ELSE
      IF type.getTtype() == Type.Enum.byRef
        IF destType != NIL && destType.getTtype() == Type.Enum.byRef
          # Write the symbol itself, for "&arg == NIL".
          IF decl.pName == NIL
            THROW "Internal error: pName is NIL"
          }
          ctx.out.write(decl.pName)
        ELSE
          # Write the symbol defererenced.
          ctx.gen.writeSymName(decl, decl.type, !lvalue, ctx)

          # Return a declaration with the referenced type, instead of the
          # reference type itself.
          # The copy depends on the original object and vise versa, if
          # one is used the other must also be marked as used.
          Declaration newDecl = decl.copy()
          newDecl.addDependsOn(decl)
          decl.addDependsOn(newDecl)
          decl = newDecl

          decl.type = type.<ReferenceType.C>.getReferencedType()
          IF decl.type == NIL
            exprExt.undefined++
            IF ctx.doError()
              ctx.error("symbol " .. expr.getId().getName()
                                                 .. " type unknown", expr)
            }
          }
        }
      ELSE
        ctx.gen.writeSymName(decl, decl.type, !lvalue, ctx)
      }
      IF exprExt.undefined == 0 || usedWhenUndefined
        ctx.addUsedItem(decl)
      }

      IF decl.type.isAllocType(ctx)
        # For an allocated variable return the type of the member.
        RETURN decl.type.getClassType(ctx).allocDecl
      }
    }

    RETURN decl
  }

  # Generate a Member part of an expression.
  FUNC generateVarnameMember(Zui.Expression expr, SContext ctx, Type destType
                           ) Declaration
    CHECK.true(expr.getRight().getType() == Zui.ExprType.eID)
    string name = expr.getRight().getId().getName()
    VAR exprExt = ZuiExpressionExt.get(expr)

    Zui.Expression left = expr.getLeft()
    VAR leftExt = ZuiExpressionExt.get(left)
    leftExt.undefined = 0
    Declaration ret
    Declaration leftDecl = generateVarnamePart(left, FALSE,
                                                    ctx.copyNoOut(), destType)
    Type leftType = leftDecl?.type
    exprExt.undefined += leftExt.undefined

    IF leftDecl == NIL || leftType == NIL
      IF ctx.doError()
        generateVarnamePart(left, FALSE, ctx, destType)
        ctx.error("Error before ." .. name, expr)
      }
    ELSEIF leftType.getTtype() == Type.Enum.iobject
      # Left expression is an interface object.
      SymUse symUse = NEW(expr.getPos(), ctx)
      ClassType spClass = leftType.getClassType(ctx)
      Declaration decl
      IF spClass != NIL
        decl = spClass.findObjectMember(name, symUse, searchParent, FALSE)
      }
      IF decl == NIL
        exprExt.undefined++
        IF ctx.doError()
          IF spClass == NIL
            ctx.error("class not found", left)
          ELSE
            symUse.doError = TRUE
            IF spClass.findObjectMember(name, symUse,
                                                   searchParent, FALSE) == NIL
              ctx.error("member \"" .. name .. "\" not found", expr)
            }
          }
        }
      ELSE
        # some.member  TODO: should also work when destType is NIL.
        ctx.gen.iobjectMember(decl, leftType, expr,
                              expr.hasDotnil() && expr.getDotnil(),
                       ctx, destType == NIL ? Type.anUnknown : destType, TRUE)
        IF exprExt.undefined == 0 || usedWhenUndefined
          ctx.addUsedItem(leftDecl)
          ctx.addUsedItem(decl)
        }
        ret = decl
      }
    ELSEIF leftType.getTtype() == Type.Enum.module
        || leftType.getTtype() == Type.Enum.builtinModule
        || leftType.getTtype() == Type.Enum.class
      # Left expression is a class or a module.
      SymUse symUse = NEW(expr.getPos(), ctx)
      Declaration decl = leftType.findMember(name, symUse)
      IF decl == NIL
        exprExt.undefined += 2
        IF ctx.doError()
          symUse.doError = TRUE
          IF leftType.findMember(name, symUse) == NIL
            ctx.error("member " .. name .. " not found", expr)
          }
        }
      ELSEIF leftType.getTtype() == Type.Enum.class && !decl.inShared()
        # shared members must start with a class name
        exprExt.undefined++
        IF ctx.doError()
          ctx.error("member " .. name .. " not in SHARED section of class",
                                                                         expr)
        }
      ELSE
        ctx.gen.writeVarName(decl, ctx)
        ret = decl
        IF exprExt.undefined == 0 || usedWhenUndefined
          ctx.addUsedItem(decl)
        }
      }
    ELSE
      IF leftType.getTtype() == Type.Enum.object
        # It is possible that a child is found for a class later, then the
        # type changes from object to iobject and we need to come back here to
        # take care of that.
        ClassType ct = leftType.getClassType(ctx)
        IF ct != NIL
          ct.scope.addScopeDependency(ctx.scope)
        }
      }

      # Left expr is not a class or interface.
      # Produce the left part and write the text in varnameOut.
      leftExt.undefined = 0
      Output varnameOut = NEW()
      varnameOut.writing = ctx.out.writing
      leftDecl = generateVarnamePart(left, FALSE,
                                               ctx.copy(varnameOut), destType)
      leftType = leftDecl.type
      Type effLeftType = leftType.getEffType()
      exprExt.undefined += leftExt.undefined
      IF leftType.getTtype() == Type.Enum.object
        # Left expression is an object.
        SymUse symUse = NEW(expr.getPos(), ctx)
        Declaration decl = leftType.findObjectMember(name, symUse,
                                                          searchParent, FALSE)
        IF decl == NIL
          exprExt.undefined++
          IF ctx.doError()
            symUse.doError = TRUE
            IF leftType.findObjectMember(name, symUse,
                                                   searchParent, FALSE) == NIL
              ctx.error("member \"" .. name .. "\" not found", expr)
            }
          }
        ELSE
          ctx.gen.member(varnameOut, left.getPos(),
                                  leftType, decl.type, FALSE, decl.pName, ctx)
          ret = decl
          IF exprExt.undefined == 0 || usedWhenUndefined
            ctx.addUsedItem(decl)
          }
        }
      ELSEIF leftType.getTtype() == Type.Enum.bitsValue
        # Left expression is a bits value.
        SymUse symUse = NEW(expr.getPos(), ctx)
        BitsType bitsType
        IF effLeftType ISA BitsType
          bitsType = effLeftType
        ELSE
          bitsType = effLeftType.<BitsValueType.C>.bitsType
        }
        Declaration decl = bitsType.findMember(name, symUse)
        IF decl == NIL
          exprExt.undefined++
          IF ctx.doError()
            symUse.doError = TRUE
            IF bitsType.findMember(name, symUse) == NIL
              ctx.error("member " .. name .. " not found", expr)
            }
          }
        ELSE
          ctx.out.append(varnameOut)
          # We need to generate a value with the type of "decl", but
          # remember that it needs to be shifted to fit in "ret".  This is
          # done for an assignment.
          ret = Declaration.NEW(effLeftType.name)
          ret.type = effLeftType
          ret.bitsMember = decl.type
        }
      ELSEIF leftType.getTtype() == Type.Enum.tuple
        TupleType tupleType = effLeftType
        Type t = genTupleItem(tupleType, left, name, ctx)
        IF t == NIL
          ctx.error("member " .. name .. " not found", expr)
        ELSE
          ret = Declaration.NEW(name)
          ret.type = t
        }
      ELSE
        exprExt.undefined++
        IF leftType.getTtype() != Type.Enum.unknown && ctx.doError()
          ctx.error("Unexpected type " .. leftType.typeName()
                                                .. "  before ." .. name, expr)
        }
      }
    }

    RETURN ret
  }

  # Lookup item |name| in |type|.  Return the item Type if found, NIL
  # otherwise.
  FUNC genTupleItem(TupleType type, Zui.Expression left, string name,
                                                            SContext ctx) Type
    FOR i IN 0 UNTIL type.types.Size()
      IF type.types[i].name == name
        RETURN ctx.gen.tupleItem(type, left, i, ctx)
      }
    }
    RETURN NIL
  }

  FUNC generateVarnameSubscript(Zui.Expression expr, bool lvalue,
                                                 SContext ctx, Type destType
                              ) Declaration
    VAR exprExt = ZuiExpressionExt.get(expr)
    Zui.Expression left = expr.getLeft()
    VAR leftExt = ZuiExpressionExt.get(left)

    # For array assignment a[n] = x  C code is similar.
    # List assignment d[k] = v becomes *ZListGetIntP(l, k)
    # Dict assignment d[k] = v becomes *ZDictGetIntP(d, (Tz)k)
    # For list access d[i].m becomes ZListGetPtr(d, i)->m
    # For dict access d[k].m becomes ZDictGetPtr(d, (Tz)k)->m
    # For tuple access d[0] becomes (d)->m0
    leftExt.undefined = 0
    Declaration ret
    Declaration leftDecl = generateVarnamePart(left, FALSE,
                                                    ctx.copyNoOut(), destType)
    exprExt.undefined = leftExt.undefined
    Type leftType = leftDecl?.type
    ret = ctx.gen.varnameSubscript(leftType, expr, lvalue, ctx, destType)

    IF leftDecl != NIL
      IF leftType ISA ContainerType
        # result type is the value type
        ContainerType cont = leftType.<ContainerType.C>
        IF cont.itemType == NIL
          exprExt.undefined++
        ELSE
          ret = cont.itemType
        }
      ELSEIF leftType.getTtype() == Type.Enum.byteString
                                    || leftType.getTtype() == Type.Enum.string
        # "byteString[n]" results in an int
        ret = Type.anInt
      }
    }
    RETURN ret
  }

  # Handle a type cast where a varname is expected.
  # Can't be the last part of the expression, returns a type and not a
  # variable or member declaration.
  FUNC generateVarnameTypecast(Zui.Expression expr, bool lvalue,
                                                 SContext ctx, Type destType
                              ) Declaration
    IF lvalue
      ctx.error("Unexpected type cast", expr)
    }

    Type ret

    # Get the type to cast to.
    Zui.Expression typeExpr = expr.getTypecast().getName()
    SymUse symUse = NEW(typeExpr.getPos(), ctx)
    Type declType = generateDeclType(typeExpr, ctx.copyNoOut(),
                                             isDecl + dotI + markUsed, symUse)
    Zui.Expression left = expr.getLeft()
    IF declType == NIL
      IF ctx.doError()
        symUse.doError = TRUE
        generateDeclType(typeExpr, ctx, isDecl + dotI + markUsed, symUse)
      }
    ELSE
      # Generate the expression before the cast, using the cast type as the
      # destination type.
      ret = genExpr(left, ctx, declType.getValueType(ctx))
    }
    ZuiExpressionExt.get(expr).undefined =
                                      ZuiExpressionExt.get(typeExpr).undefined
                                        + ZuiExpressionExt.get(left).undefined
    RETURN ret
  }

  # Generate the expression from |expr|.
  # Give an error when the result type differs from |dest.type|, or wrap it in
  # a conversion function if possible.
  # When |dest| is NIL don't check the result type.
  # Sets expr.undefined.
  # Return a symbol that defines the type of the result.
  # Return NIL when there is an error.
  FUNC genExpr(Zui.Expression expr, SContext ctx) Type
    RETURN genExprConv(expr, ctx, NEW(FALSE))
  }
  FUNC genExpr(Zui.Expression expr, SContext ctx, Declaration dest) Type
    RETURN genExprConv(expr, ctx, NEW(dest, FALSE))
  }

  FUNC genExprDoConv(Zui.Expression expr, SContext ctx) Type
    RETURN genExprConv(expr, ctx, NEW(TRUE))
  }
  FUNC genExprDoConv(Zui.Expression expr, SContext ctx, Declaration dest) Type
    RETURN genExprConv(expr, ctx, NEW(dest, TRUE))
  }

  # Like genExpr(), but special handling for PARENT.
  # Useful when evaluating the object for a method:
  # PARENT.parentMethod() -> parentMethodCopy(THIS).
  FUNC genExprParent(Zui.Expression expr, SContext ctx, Declaration dest) Type
    IF ZuiFile.isParentExpr(expr)
      ZuiExpressionExt.get(expr).undefined = 0
      ctx.out.write(ctx.scope.thisName)
      RETURN dest?.type
    }
    RETURN genExpr(expr, ctx, dest)
  }


  FUNC genTopExprDoConv(Zui.Expression expr, SContext ctx) Type
    ExprArg ea = NEW(TRUE)
    ea.top = TRUE
    RETURN genExprConv(expr, ctx, ea)
  }

  FUNC genTopExprDoConv(Zui.Expression expr, SContext ctx,
                                                       Declaration dest) Type
    IF ctx.doError() && expr.getType() == Zui.ExprType.eNAT
      bool tooBig
      SWITCH dest.type.getTtype()
        CASE Type.Enum.int8
          tooBig = expr.getNumber() >= 128
        CASE Type.Enum.byte
          tooBig = expr.getNumber() >= 256
        CASE Type.Enum.int16
          tooBig = expr.getNumber() >= 256 * 128
        CASE Type.Enum.nat16
          tooBig = expr.getNumber() >= 256 * 256
        CASE Type.Enum.int32
          tooBig = expr.getNumber() >= 256 * 256 *  256 * 128
        CASE Type.Enum.nat32
          tooBig = expr.getNumber() >= 256 * 256 * 256 * 256
      }
      IF tooBig
        ctx.error("Value too big for " .. dest.type.typeName(), expr)
      }
    }
    IF ctx.doError() && expr.getType() == Zui.ExprType.eINT
      bool tooBig
      SWITCH dest.type.getTtype()
        CASE Type.Enum.byte
        CASE Type.Enum.nat16
        CASE Type.Enum.nat32
          ctx.error("Negative value for " .. dest.type.typeName(), expr)
        CASE Type.Enum.int8
          tooBig = expr.getNumber() < -128
        CASE Type.Enum.int16
          tooBig = expr.getNumber() < -256 * 128
        CASE Type.Enum.int32
          tooBig = expr.getNumber() < -256 * 256 *  256 * 128
      }
      IF tooBig
        ctx.error("Value too negative for " .. dest.type.typeName(), expr)
      }
    }

    ExprArg ea = NEW(dest, TRUE)
    ea.top = TRUE
    RETURN genExprConv(expr, ctx, ea)
  }

  FUNC genExprConv(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    int errorCount = LOG.errorCount
    Type ret = ctx.gen.expr(expr, ctx, exprArg)
    Type destType = exprArg.destType()
    VAR exprExt = ZuiExpressionExt.get(expr)

    # Report a type error if we are writing and the expression itself
    # didn't generate an error.
    IF destType != NIL
      IF ret == NIL
        IF ctx.doError() && LOG.errorCount == errorCount
          ctx.error("Expected " .. destType.typeName()
                                                  .. " but got nothing", expr)
        }
        ++exprExt.undefined
      ELSE
        IF !Type.matchingTypes(ret, destType, ctx)
          IF ctx.doError() && LOG.errorCount == errorCount
            typeError(destType, ret, expr.getPos(), ctx)
          }
          ++exprExt.undefined
        }
      }
    }
    exprExt.resultType = ret

    RETURN ret
  }

  # Generate the expression from |expr|.
  # Like genExpr(), but may produce a different type than asked for.
  # Sets expr.undefined.
  FUNC genExprChecked(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    Output out = ctx.out
    Scope scope = ctx.scope
    Type destType = exprArg.destType()
    Type.Enum destEnum = (destType == NIL)
                                     ? Type.Enum.unknown : destType.getTtype()
    Type ret
    VAR exprExt = ZuiExpressionExt.get(expr)

    IF destType != NIL && destEnum == Type.Enum.bitsValue
      # The destination is a BITS type.  Try that first, if it fails try
      # something else.
      ret = genBitsExpr(expr, ctx, exprArg)
      IF ret != NIL
        RETURN ret
      }
    }

    # Get here when there is no special handling for BITS type.
    IF destEnum == Type.Enum.class
      destEnum = Type.Enum.object
    }

    # Set default return type.  Used when the expression type is unknown.
    # E.g. for NIL.
    IF destType == NIL
      ret = Type.anUnknown
    ELSEIF destType ISA ClassType
      ret = destType.getValueType(ctx)
    ELSE
      ret = destType
    }

    SWITCH expr.getType()
      CASE Zui.ExprType.eTRUE
        ret = generateVal(expr, "\"TRUE\"", "1", Type.aBool, destEnum, ctx)

      CASE Zui.ExprType.eFALSE
        ret = generateVal(expr, "\"FALSE\"", "0", Type.aBool, destEnum, ctx)

      CASE Zui.ExprType.eOK
        ret = generateVal(expr, "\"OK\"", "1", Type.aStatus, destEnum, ctx)

      CASE Zui.ExprType.eFAIL
        ret = generateVal(expr, "\"FAIL\"", "0", Type.aStatus, destEnum, ctx)

      CASE Zui.ExprType.eNIL
        ret = generateNil(expr, exprArg.dest, ctx)

      CASE Zui.ExprType.eINF
        exprExt.undefined = 0
        ctx.gen.inf(ctx)
        ret = Type.aFloat

      CASE Zui.ExprType.eNINF
        exprExt.undefined = 0
        ctx.gen.ninf(ctx)
        ret = Type.aFloat

      CASE Zui.ExprType.eNAN
        exprExt.undefined = 0
        ctx.gen.nan(ctx)
        ret = Type.aFloat

      CASE Zui.ExprType.eTHIS
        ret = generateThis(expr, destType, ctx)

      CASE Zui.ExprType.ePARENT
        ret = generateParent(expr, ctx)

      CASE Zui.ExprType.eCCODE
        ret = generateCCode(expr, ctx)

      CASE Zui.ExprType.eNAT
      CASE Zui.ExprType.eINT
        ctx.gen.generateInt(expr, ctx)
        IF destEnum == Type.Enum.int
          ret = Type.anInt
        ELSEIF destEnum == Type.Enum.nat
          ret = Type.aNat
        ELSEIF expr.getType() == Zui.ExprType.eNAT
          ret = Type.aNatval
        ELSE
          ret = Type.anIntval
        }

      CASE Zui.ExprType.eFLOAT
        ctx.gen.generateFloat(expr, ctx)
        IF destEnum == Type.Enum.float
          ret = Type.aFloat
        ELSE
          ret = Type.aFloatval
        }

      CASE Zui.ExprType.eSTRING
        ret = generateString(expr, destEnum, exprArg.dest, ctx)

      CASE Zui.ExprType.eNOT
        generateUnaryOp("!", Type.aBool, expr, ctx)
        ret = Type.aBool

      CASE Zui.ExprType.eMINUS
        ret = genExpr(expr.getRight(), ctx.copyNoOut())
        ctx.out.write("-(")
        ret = genExpr(expr.getRight(), ctx, ret.isFloatType()
                                                   ? Type.aFloat : Type.anInt)
        ctx.out.write(")")
        exprExt.undefined = ZuiExpressionExt.get(expr.getRight()).undefined

      CASE Zui.ExprType.eTILDE
        generateUnaryOp("~", Type.anInt, expr, ctx)
        ret = Type.anInt

      CASE Zui.ExprType.eREF
        ret = generateRef(expr, destType, ctx)

      CASE Zui.ExprType.eCALL
        ret = generateCall(expr.getMethodCall(), NIL, ctx, exprArg.dest)
        exprExt.undefined = ZuiMethodCallExt.get(expr.getMethodCall()).undefined

      CASE Zui.ExprType.eNEWCALL
        int undef
        ret = generateNewCall(&undef,
                          expr.getMethodCall(), NIL, ctx, FALSE, exprArg.dest)
        exprExt.undefined = undef

      CASE Zui.ExprType.eID
        ret = generateId(expr, ctx, exprArg)

      CASE Zui.ExprType.eMEMBER
        ret = generateMember(expr, ctx, exprArg, ret)

      CASE Zui.ExprType.eSUBSCRIPT
        ret = ctx.gen.subscript(expr, ctx, destType)

      CASE Zui.ExprType.eBIT_AND
      CASE Zui.ExprType.eBIT_OR
      CASE Zui.ExprType.eBIT_XOR
      CASE Zui.ExprType.eMULTIPLY
      CASE Zui.ExprType.eDIVIDE
      CASE Zui.ExprType.eREMAINDER
      CASE Zui.ExprType.eSHIFT_RIGHT
      CASE Zui.ExprType.eSHIFT_LEFT
      CASE Zui.ExprType.eSUBTRACT
        ret = ctx.gen.numberOp(expr, ctx)

      CASE Zui.ExprType.eADD
        ret = ctx.gen.plusOp(expr, ctx, destEnum)

      CASE Zui.ExprType.eCONCAT
        ret = generateConcat(expr, destEnum, ctx)

      CASE Zui.ExprType.ePRE_INC
      CASE Zui.ExprType.ePRE_DEC
      CASE Zui.ExprType.ePOST_INC
      CASE Zui.ExprType.ePOST_DEC
        ctx.gen.incrdecrOp(expr, ctx)
        ret = Type.anInt

      CASE Zui.ExprType.eEQUAL
      CASE Zui.ExprType.eNOTEQUAL
      CASE Zui.ExprType.eIS
      CASE Zui.ExprType.eISNOT
      CASE Zui.ExprType.eMATCH
      CASE Zui.ExprType.eNOMATCH
        ctx.gen.booleanOp(expr, FALSE, ctx)
        ret = Type.aBool

      CASE Zui.ExprType.eGREATER
      CASE Zui.ExprType.eGREATER_EQUAL
      CASE Zui.ExprType.eLESS
      CASE Zui.ExprType.eLESS_EQUAL
        ctx.gen.booleanOp(expr, TRUE, ctx)
        ret = Type.aBool

      CASE Zui.ExprType.eISA
      CASE Zui.ExprType.eISNOTA
        ctx.gen.isaOp(expr, ctx)
        ret = Type.aBool

      CASE Zui.ExprType.eAND
      CASE Zui.ExprType.eOR
        ctx.gen.andorOp(expr, ctx)
        ret = Type.aBool

      CASE Zui.ExprType.ePARENS
        ret = ctx.gen.parens(expr, ctx, exprArg)

      CASE Zui.ExprType.eTERNARY
        ret = ctx.gen.altOp(expr, ctx, exprArg)

      CASE Zui.ExprType.eIFNIL
        ret = ctx.gen.ifnilOp(expr, ctx, exprArg)

      CASE Zui.ExprType.eLIST
        ret = generateList(expr, FALSE, exprArg.dest, ctx)

      CASE Zui.ExprType.eDICT
        ret = generateDict(expr, FALSE, exprArg.dest, ctx)

      CASE Zui.ExprType.eINIT
        ctx.gen.objectInit(expr, exprArg.dest, ctx)
        ret = destType

      CASE Zui.ExprType.eLAMBDA
        MethodRefType methodDecl = generateLambdaExpr(expr, ctx, destType)
        ret = methodDecl.type
        generateMethodUse(&exprExt.undefined,
                                      methodDecl.getMethod(), methodDecl, ctx)

      CASE Zui.ExprType.eMETHOD
        ret = genExprMethod(expr, ctx, destType)

      CASE Zui.ExprType.eTYPESPEC
        ret = generateTypespec(expr, ctx)

      CASE Zui.ExprType.eTYPECAST
        ret = generateTypecast(expr, ctx)

      CASE Zui.ExprType.eBITSASSIGN
        # We only get here if genBitsExpr() wasn't used above.
        IF ctx.doError()
         ctx.error("Target bits type unknown", expr)
        }
        ret = NIL

      CASE Zui.ExprType.unknown
        ctx.error("Missing argument", expr)
        ret = NIL

      DEFAULT
        ctx.error("INTERNAL: Unknown expression type: "
                                           .. expr.getType().ToString(), expr)
        THROW "here"
    }

    exprExt.resultType = ret
    RETURN ret
  }

  #= Return an estimation for the result type for expression |expr|.
  #- |scope| is used for ID symbols.
  FUNC resultType(Zui.Expression expr, SContext ctx) Type.Enum
    SWITCH expr.getType()
      CASE Zui.ExprType.eSTRING
        RETURN Type.Enum.stringval
      CASE Zui.ExprType.eNIL
        RETURN Type.Enum.nilval
      CASE Zui.ExprType.eNAT
      CASE Zui.ExprType.eINT
        RETURN Type.Enum.int
      CASE Zui.ExprType.eTRUE
      CASE Zui.ExprType.eFALSE
        RETURN Type.Enum.bool
      CASE Zui.ExprType.eOK
      CASE Zui.ExprType.eFAIL
        RETURN Type.Enum.status
      CASE Zui.ExprType.eID
        RETURN ctx.scope.getSymbolTypeEnum(
                              expr.getId().getName(), NEW(expr.getPos(), ctx))
      CASE Zui.ExprType.eCONCAT
        Type.Enum left = resultType(expr.getLeft(), ctx)
        Type.Enum right = resultType(expr.getRight(), ctx)
        IF left == Type.Enum.stringval && right == Type.Enum.stringval
          # concatenating string constants at compile time
          RETURN Type.Enum.stringval
        }
        IF left == Type.Enum.nilval
          # use a NIL like an unknown type here.
          left = Type.Enum.unknown
        }
        IF right == Type.Enum.nilval
          right = Type.Enum.unknown
        }
        IF (left == Type.Enum.unknown || left == Type.Enum.stringval)
           && (right == Type.Enum.unknown || right == Type.Enum.stringval)
          RETURN Type.Enum.string
        }
        IF (left == Type.Enum.stringval || left == Type.Enum.string
                                                 || left == Type.Enum.unknown)
            && (right == Type.Enum.stringval || right == Type.Enum.string
                                                || right == Type.Enum.unknown)
          RETURN Type.Enum.string
        }
        IF (left == Type.Enum.stringval || left == Type.Enum.string
                  || left == Type.Enum.varString || left == Type.Enum.unknown)
            && (right == Type.Enum.stringval || right == Type.Enum.string
                || right == Type.Enum.varString || right == Type.Enum.unknown)
          RETURN Type.Enum.varString
        }
        IF (left == Type.Enum.stringval || left == Type.Enum.byteString
                                                 || left == Type.Enum.unknown)
            && (right == Type.Enum.stringval || right == Type.Enum.byteString
                                                || right == Type.Enum.unknown)
          RETURN Type.Enum.byteString
        }
        IF (left == Type.Enum.stringval || left == Type.Enum.byteString
              || left == Type.Enum.varByteString || left == Type.Enum.unknown)
            && (right == Type.Enum.stringval || right == Type.Enum.byteString
            || right == Type.Enum.varByteString || right == Type.Enum.unknown)
          RETURN Type.Enum.varByteString
        }
        RETURN Type.Enum.string

      CASE Zui.ExprType.eMULTIPLY
      CASE Zui.ExprType.eDIVIDE
      CASE Zui.ExprType.eSUBTRACT
      CASE Zui.ExprType.eADD
        Type.Enum left = resultType(expr.getLeft(), ctx)
        Type.Enum right = resultType(expr.getRight(), ctx)
        IF left == Type.Enum.float || right == Type.Enum.float
          RETURN Type.Enum.float
        }
        RETURN Type.Enum.int

      CASE Zui.ExprType.eREMAINDER
        RETURN Type.Enum.int

      CASE Zui.ExprType.eEQUAL
      CASE Zui.ExprType.eNOTEQUAL
      CASE Zui.ExprType.eMATCH
      CASE Zui.ExprType.eNOMATCH
      CASE Zui.ExprType.eGREATER
      CASE Zui.ExprType.eGREATER_EQUAL
      CASE Zui.ExprType.eLESS
      CASE Zui.ExprType.eLESS_EQUAL
      CASE Zui.ExprType.eAND
      CASE Zui.ExprType.eOR
      CASE Zui.ExprType.eIS
      CASE Zui.ExprType.eISNOT
      CASE Zui.ExprType.eISA
      CASE Zui.ExprType.eISNOTA
        RETURN Type.Enum.bool
    }
    RETURN Type.Enum.unknown
  }

  # Return TRUE when |expr| evaluates to a constant.
  # FALSE when it invokes a function.
  FUNC isConstantExpression(Zui.Expression expr, Type type, SContext ctx) bool
    bool isContextFree = TRUE
    SWITCH type.getTtype()
      CASE Type.Enum.int
      CASE Type.Enum.int8
      CASE Type.Enum.int16
      CASE Type.Enum.int32
      CASE Type.Enum.byte
      CASE Type.Enum.nat
      CASE Type.Enum.nat16
      CASE Type.Enum.nat32
        ExprEval.evalInt(expr, ctx, FALSE, &isContextFree)
      CASE Type.Enum.float
      CASE Type.Enum.float32
      CASE Type.Enum.float80
      CASE Type.Enum.float128
        ExprEval.evalFloat(expr, ctx, FALSE, &isContextFree)
      CASE Type.Enum.string
        ExprEval.evalString(expr, ctx, FALSE, &isContextFree)
      CASE Type.Enum.bool
        ExprEval.evalBool(expr, ctx, FALSE, &isContextFree)
      CASE Type.Enum.status
        ExprEval.evalStatus(expr, ctx, FALSE, &isContextFree)
      DEFAULT
        isContextFree = FALSE
    }
    RETURN isContextFree
  }

  # Return TRUE when |expr| may have side effects.
  # FALSE when it invokes a function.
  FUNC mayHaveSideEffects(Zui.Expression expr, SContext ctx) bool
    SWITCH expr.getType()
      CASE Zui.ExprType.eNAT
      CASE Zui.ExprType.eINT
      CASE Zui.ExprType.eFLOAT
      CASE Zui.ExprType.eSTRING
      CASE Zui.ExprType.eTRUE
      CASE Zui.ExprType.eFALSE
      CASE Zui.ExprType.eFAIL
      CASE Zui.ExprType.eOK
        # constants are OK
        RETURN FALSE

      CASE Zui.ExprType.eNEWCALL
        # TODO: check arguments
        RETURN FALSE

      CASE Zui.ExprType.eCALL
        # TODO: check arguments
        # TODO: return FALSE for a primitive method.
        RETURN TRUE

      CASE Zui.ExprType.eMEMBER
        # TODO?
        RETURN FALSE

      CASE Zui.ExprType.eLIST
      CASE Zui.ExprType.eDICT
        # TODO: check all items
        RETURN FALSE

      CASE Zui.ExprType.ePARENS
      CASE Zui.ExprType.eNOT
        # one sub-expression
        RETURN mayHaveSideEffects(expr.getRight(), ctx)

      CASE Zui.ExprType.eADD
      CASE Zui.ExprType.eSUBTRACT
      CASE Zui.ExprType.eMULTIPLY
      CASE Zui.ExprType.eDIVIDE
      CASE Zui.ExprType.eEQUAL
      CASE Zui.ExprType.eNOTEQUAL
      CASE Zui.ExprType.eOR
      CASE Zui.ExprType.eAND
      CASE Zui.ExprType.eBIT_AND
      CASE Zui.ExprType.eBIT_OR
      CASE Zui.ExprType.eBIT_XOR
        # two sub-expressions
        RETURN mayHaveSideEffects(expr.getLeft(), ctx)
            || mayHaveSideEffects(expr.getRight(), ctx)
    }
    RETURN TRUE
  }

  FUNC generateVal(Zui.Expression expr, string stringVal, string intVal,
                             Type intType, Type.Enum destEnum, SContext ctx
                 ) Type
    ZuiExpressionExt.get(expr).undefined = 0
    ctx.out.write(intVal)
    RETURN intType
  }

  FUNC generateNil(Zui.Expression expr, Declaration dest, SContext ctx) Type
    VAR exprExt = ZuiExpressionExt.get(expr)
    exprExt.undefined = 0
    Type destType = dest?.type
    IF destType == NIL || (destType.isValueType()
                                  && destType.getTtype() != Type.Enum.unknown)
      exprExt.undefined = 1
      IF ctx.doError()
        typeError(destType, Type.aNil, expr.getPos(), ctx)
      }
      RETURN Type.anUnknown
    }
    ctx.gen.nil(dest, ctx)

    # Return the type of what was requested, unless it's unknown then
    # return type NIL.
    IF destType.getTtype() == Type.Enum.unknown
      RETURN Type.aNil
    }
    RETURN destType
  }

  FUNC generateThis(Zui.Expression expr, Type destType, SContext ctx) Type
    VAR exprExt = ZuiExpressionExt.get(expr)
    exprExt.undefined = 0
    IF destType != NIL
        && destType.getTtype() != Type.Enum.class
        && destType.getTtype() != Type.Enum.object
        && destType.getTtype() != Type.Enum.iobject
        && destType.getTtype() != Type.Enum.nilval
        && destType.getTtype() != Type.Enum.unknown
      exprExt.undefined = 1
      IF ctx.doError()
        typeError(destType, Type.anObject, expr.getPos(), ctx)
      }
    ELSEIF !ctx.scope.isClassScope()
      exprExt.undefined = 2
      ctx.error("THIS cannot be used here", expr)
    ELSE
      ctx.out.write(ctx.scope.thisName)
      RETURN ctx.scope.classType.getObject()
    }
    RETURN Type.anUnknown
  }

  FUNC generateParent(Zui.Expression expr, SContext ctx) Type
    VAR exprExt = ZuiExpressionExt.get(expr)
    exprExt.undefined = 0
    Type ret = getParentClass(expr, ctx)
    IF ret == NIL
      exprExt.undefined = 1
    ELSE
      ret = ret.<ClassType>.getObject()  # turn class into "THIS" object
    }
    RETURN ret
  }

  # Generate C(code)
  FUNC generateCCode(Zui.Expression expr, SContext ctx) Type
    ZuiExpressionExt.get(expr).undefined = 0
    ctx.out.write(expr.getStringValue())
    RETURN Type.anAny
  }

  PROC generateUnaryOp(string op, Type type,
                                            Zui.Expression expr, SContext ctx)
    ctx.out.write(op .. "(")
    genExpr(expr.getRight(), ctx, type)
    ctx.out.write(")")
    ZuiExpressionExt.setUndefined(expr)
  }

  # Generate a reference: "&var".
  # When used as an argument, before finding the matching function, destType
  # is Type.Enum.unknown.
  FUNC generateRef(Zui.Expression expr, Type destType, SContext ctx) Type
    Zui.Expression refExpr = expr.getRight()
    VAR exprExt = ZuiExpressionExt.get(expr)
    exprExt.undefined = 0
    IF destType == NIL || (destType.getTtype() != Type.Enum.byRef
                                   && destType.getTtype() != Type.Enum.unknown
                                   && destType.getTtype() != Type.Enum.nilval)
      exprExt.undefined = 5
      IF ctx.doError()
        ctx.error("Unexpected &, desired type: "
                                             .. Type.typeName(destType), expr)
      }
      RETURN Type.anUnknown
    }
    IF destType.getTtype() == Type.Enum.byRef
                                   || destType.getTtype() == Type.Enum.unknown
      # Using &var argument for method that accepts a reference, or getting
      # the arguments to find a matching method.
      ctx.out.write("&(")
      Declaration refDecl = generateVarname(refExpr, ctx,
                           destType.getTtype() == Type.Enum.unknown ? destType
                              : destType.<ReferenceType.C>.getReferencedType())
      Type refType = refDecl?.type
      ctx.out.write(")")
      exprExt.undefined += ZuiExpressionExt.get(refExpr).undefined
      ReferenceType.C ref = NEW(Type.Enum.byRef, refType, "ref")
      IF refDecl != NIL
        # Put the type in the ReferenceType, the name in Declaration.
        ref.name = refDecl.name
      }
      RETURN ref
    }
    # Should be something like &arg == NIL.
    Declaration decl = generateVarname(refExpr, ctx, Type.aByRef)
    Type ret = decl?.type
    IF ret != NIL && ret ISNOTA ReferenceType && ctx.doError()
      ctx.error("Expected a reference type, got " .. ret.typeName(), expr)
    }
    RETURN ret
  }

  # Generate an expression for which the destination type is BITS
  FUNC genBitsExpr(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    Output out = ctx.out
    Type destType = exprArg.destType()
    Type retType = destType
    SymUse symUse = NEW(expr.getPos(), ctx)
    BitsType bitsType
    IF destType ISA BitsValueType
      bitsType = destType.<BitsValueType.C>.bitsType
    ELSE
      bitsType = destType.<BitsType.C>
    }
    VAR exprExt = ZuiExpressionExt.get(expr)

    SWITCH expr.getType()
      CASE Zui.ExprType.eID
        # "field" may be a BITS field name
        Declaration decl = bitsType.findMember(expr.getId().getName(), symUse)
        IF decl == NIL
          BREAK
        }
        Type memberType = decl.type
        exprExt.undefined = 0
        IF memberType.getTtype() != Type.Enum.bool
          exprExt.undefined = 1
          IF ctx.doError()
            typeError(Type.aBool, decl.type, expr.getPos(), ctx)
          }
        ELSE
          int val = 1 << memberType.<ValueType.C>.shift
          IF destType ISA BitsType
            retType.<BitsType.C>.value = val
          ELSE
            retType.<BitsValueType.C>.value = val
          }
          out.write("" .. val)
        }
        RETURN retType

      CASE Zui.ExprType.eNAT
      CASE Zui.ExprType.eINT
        # "0" can always be used
        IF expr.getNumber() == 0
          IF destType ISA BitsType
            retType.<BitsType.C>.value = 0
          ELSE
            retType.<BitsValueType.C>.value = 0
          }
          out.write("0")
          exprExt.undefined = 0
          RETURN retType
        }

      CASE Zui.ExprType.eADD
        # "field + field"
        Zui.Expression left = expr.getLeft()
        Zui.Expression right = expr.getRight()
        out.write("(")
        genExpr(left, ctx, destType)
        out.write(" + ")
        genExpr(right, ctx, destType)
        out.write(")")
        ZuiExpressionExt.setUndefined(expr)
        RETURN retType

      CASE Zui.ExprType.eBITSASSIGN
        # "field=value"
        Zui.Expression left = expr.getLeft()
        IF left.getType() != Zui.ExprType.eID
          ctx.error("Only ID supported here", left)
          RETURN Type.anUnknown
        }
        IF bitsType == NIL
          IF ctx.doError()
            typeError(Type.aBits, destType, expr.getPos(), ctx)
          }
          RETURN Type.anUnknown
        }

        string leftName = left.getId().getName()
        Declaration memberDecl = bitsType.findMember(leftName, symUse)
        IF memberDecl == NIL
          IF ctx.doError()
            ctx.error("member not found: " .. leftName, left)
          }
          RETURN Type.anUnknown
        }

        Zui.Expression right = expr.getRight()
        ValueType memberType = memberDecl.type
        exprExt.undefined = 0
        IF (memberType.getTtype() == Type.Enum.nat
                                    || memberType.getTtype() == Type.Enum.int)
            && right.getType() != Zui.ExprType.eNAT
            && right.getType() != Zui.ExprType.eINT
          ctx.error("Expected a number", right)
          RETURN retType
        }
        IF memberType.getTtype() == Type.Enum.int
          # "intfield=-123"
          int nr = right.getNumber()
          IF nr > memberType.mask >> 1 || nr < -memberType.mask >> 1
            exprExt.undefined = 1
            ctx.error("int value out of range: " .. nr, right)
          }
          int val = nr << memberType.shift
          IF destType ISA BitsType
            retType.<BitsType.C>.value = val
          ELSE
            retType.<BitsValueType.C>.value = val
          }
          out.write("" .. val)
          RETURN retType
        }
        IF memberType.getTtype() == Type.Enum.nat
          # "natfield=123"
          int nr = right.getNumber()
          IF nr & ~memberType.mask != 0
            exprExt.undefined = 1
            ctx.error("nat value out of range: " .. nr, right)
          }
          int val = nr << memberType.shift
          IF destType ISA BitsType
            retType.<BitsType.C>.value = val
          ELSE
            retType.<BitsValueType.C>.value = val
          }
          out.write("" .. val)
          RETURN retType
        }
        IF memberType.getTtype() != Type.Enum.enumValue
          exprExt.undefined = 2
          IF ctx.doError()
            typeError(Type.anEnumValue, memberDecl.type, expr.getPos(), ctx)
          }
          RETURN Type.anUnknown
        }
        IF right.getType() != Zui.ExprType.eID
          ctx.error("Expected an enum value", right)
          RETURN retType
        }
        string name = right.getId().getName()

        # "enumfield=name"
        EnumType etype = memberType.<EnumValueType.C>.enumType
        Declaration decl = etype.findMember(name, symUse)
        IF decl == NIL
          exprExt.undefined = 1
          IF ctx.doError()
            symUse.doError = TRUE
            IF etype.findMember(name, symUse) == NIL
              ctx.error("Unknown enum value: " .. name, right)
            }
          }
          RETURN Type.anUnknown
        }

        int val = decl.type.<EnumValueType.C>.value << memberType.shift
        IF destType ISA BitsType
          retType.<BitsType.C>.value = val
        ELSE
          retType.<BitsValueType.C>.value = val
        }
        out.write("" .. val)
        RETURN retType
    }
    RETURN NIL
  }

  # "id" or "$id" used in an expression.
  FUNC generateId(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    Type ret
    Type destType = exprArg.destType()
    Type.Enum dest_type = destType == NIL
                                     ? Type.Enum.unknown : destType.getTtype()

    Zui.Id id = expr.getId()
    Pos pos = ctx.pos(expr.getPos())
    bool closure
    VAR exprExt = ZuiExpressionExt.get(expr)

    SymUse symUse = NEW(expr.getPos(), ctx)
    symUse.reading = TRUE
    Declaration decl = ctx.scope.getDecl(id, symUse)
    Type symType
    IF decl == NIL || decl.type == NIL
      exprExt.undefined = 5
    ELSE
      IF ctx.scope.inTry()
        # May need to add "volatile" to the declaration.
        decl.isUsedInTry = TRUE
      }
      symType = decl.type
      Type unrefType = symType
      IF symType.getTtype() == Type.Enum.unknown
        exprExt.undefined = 1
      ELSE
        exprExt.undefined = 0
        checkPercentMatch(id, symType, expr, ctx)
      }
      IF symType.getTtype() == Type.Enum.byRef
        Type refType = symType.<ReferenceType.C>.getReferencedType()
        IF refType == NIL
          exprExt.undefined++
        ELSE
          # Use the type from the reference but the name from the declaration
          # When generating arguments destination type is unknown, keep what
          # we have.
          IF dest_type == Type.Enum.byRef || dest_type == Type.Enum.unknown
            # have a reference and want a reference, produce referred var
            symType = refType
          ELSE
            # have a reference and want value, produce de-reference
            unrefType = refType
          }
        }
      ELSEIF symType.getTtype() == Type.Enum.dict
          || symType.getTtype() == Type.Enum.list
        IF symType.getEffType().<ContainerType.C>.itemType == NIL
          # A dict and list may not have their type fully defined yet.
          # TODO: should use sym.undef
          exprExt.undefined++
        }
      }

      ret = unrefType

      # If the id is a method, the return type is a reference to the method.
      IF (dest_type == Type.Enum.procRef
                                    && unrefType.getTtype() == Type.Enum.proc)
            || (dest_type == Type.Enum.funcRef
                                    && unrefType.getTtype() == Type.Enum.func)
        MethodRefType ref = NEW(dest_type == Type.Enum.procRef
                                      ? Type.Enum.procRef : Type.Enum.funcRef,
                                      id.getName())
        ref.method = ret
        ret = ref
      }

      closure = symType ISA MethodType && symType.<MethodType>.hasUseArguments()

      IF symType.getTtype() != Type.Enum.unknown
        IF !closure
          # typeObj has the actual type of the symbol used.
          exprExt.leftExprType = symType
        }
      ELSE
        # symbol found but type unknown
        exprExt.undefined++
        IF ctx.doError()
          pos.error("Symbol type unknown")
        }
      }
    }

    IF ctx.doError() && decl == NIL
      IF id.getName() == "T"
        pos.error("Cannot use T like this")
      ELSE
        symUse.doError = TRUE
        decl = ctx.scope.getDecl(id, symUse)
        IF decl == NIL
          pos.error("unknown symbol: " .. id.getName())
        }
        decl = NIL

        # If toggling "dollar" works give a hint.
        Zui.Id idCopy = id.copy(FALSE)
        idCopy.setDollar(!idCopy.getDollar())
        IF ctx.scope.getDecl(idCopy, symUse) != NIL
          IF idCopy.getDollar()
            pos.error("Did you mean: $" .. id.getName())
          ELSE
            pos.error("Did you mean: " .. id.getName())
          }
        }
      }
    }
    IF decl != NIL && symType != NIL
      IF closure
        # Need to allocate a closure.
        generateClosureRef(&exprExt.undefined, FALSE, NIL, NIL, NIL,
                                              decl, symType.<MethodType>, ctx)
      ELSE
        # Can use the id directly.
        ctx.gen.writeSymName(decl, symType, exprArg.top, ctx)

        IF symType.isAllocType(ctx)
          # For an allocated variable return the type of the member.
          ret = symType.getClassType(ctx).allocDecl?.type
        }
      }
      ctx.addUsedItem(decl)
    }

    RETURN ret
  }

  FUNC generateString(Zui.Expression expr, Type.Enum destEnum,
                                          Declaration dest, SContext ctx) Type
    ZuiExpressionExt.get(expr).undefined = 0
    IF dest != NIL && dest.type?.isNoAlloc()
      ctx.gen.varByteStringSetString(expr, dest, ctx)
      RETURN dest.type
    }
    IF destEnum == Type.Enum.byteString || destEnum == Type.Enum.varByteString
      ctx.gen.byteStringValue(expr, ctx)
      RETURN Type.aByteString
    }
    IF destEnum == Type.Enum.string || destEnum == Type.Enum.varString
      ctx.gen.byteStringValue(expr, ctx)
      RETURN Type.aString
    }
    ctx.gen.stringValue(expr.getStringValue(), ctx)
    RETURN Type.aString
  }

  FUNC stringExprToString(Zui.Expression expr) string
    IF expr.getType() == Zui.ExprType.eSTRING
      RETURN expr.getStringValue()
    }
    CHECK.true(expr.getType() == Zui.ExprType.eCONCAT)
    IO.StringWriter w = NEW()
    writeStringExpr(expr, w)
    RETURN w.ToString()
  }

  PROC writeStringExpr(Zui.Expression expr, IO.StringWriter w)
    IF expr.getType() == Zui.ExprType.eSTRING
      w.write(expr.getStringValue())
    ELSE
      CHECK.true(expr.getType() == Zui.ExprType.eCONCAT)
      writeStringExpr(expr.getLeft(), w)
      writeStringExpr(expr.getRight(), w)
    }
  }

  FUNC stringByteSize(Zui.Expression expr) int
    IF expr.getType() == Zui.ExprType.eSTRING
      RETURN expr.getStringValue().asByteString().Size()
    }
    CHECK.true(expr.getType() == Zui.ExprType.eCONCAT)
    RETURN stringByteSize(expr.getLeft()) + stringByteSize(expr.getRight())
  }

  PROC generateBytesExpr(Zui.Expression expr, Output out)
    ZuiExpressionExt.get(expr).undefined = 0
    IF expr.getType() == Zui.ExprType.eSTRING
      IF out.writing
        WriteCommon.writeByteString(expr.getStringValue().toByteString(), out)
      }
      RETURN
    }
    CHECK.true(expr.getType() == Zui.ExprType.eCONCAT)
    generateBytesExpr(expr.getLeft(), out)
    generateBytesExpr(expr.getRight(), out)
  }

  # Represent a byte as octal digits, to be used in a C string.
  FUNC toOctal(int c) string
    CHECK.true(c >= 0)
    RETURN "\\" .. ("01234567"[c >> 6].asString())
                .. ("01234567"[(c >> 3) & 7].asString())
                .. ("01234567"[c & 7].asString())
  }

  # For an Expression of type Zui.ExprType.eMEMBER where getLeft() ends in an
  # enum type.
  # Enum value:    enum.foo                  ->  "99"
  #                module.submodule.enum.foo ->  "99"
  FUNC genEnumMember(Zui.Expression expr, Type exprTypeArg, Type destTypeArg,
                                                 SContext ctx, Type retInit
                   ) Type
    string name = expr.getRight().getId().getName()
    Type ret = retInit
    int value = -1
    Type exprType = exprTypeArg.getEffType()
    Type destType = destTypeArg?.getEffType()
    EnumType enumType = exprType ISA EnumType ? exprType
                                         : exprType.<EnumValueType.C>.enumType
    Declaration decl = enumType.findMember(name, NIL)
    VAR exprExt = ZuiExpressionExt.get(expr)

     IF decl == NIL
      exprExt.undefined = 2
      ctx.error("No such enum value: " .. name, expr)
    ELSE
      value = decl.type.<EnumValueType.C>.value
      Type.Enum dest_type = destType == NIL ? Type.Enum.unknown
                                                         : destType.getTtype()
      exprExt.undefined = 0
      IF dest_type != Type.Enum.unknown
        IF dest_type != Type.Enum.enumValue
          exprExt.undefined = 1
          IF ctx.doError()
            typeError(destType, Type.anEnumValue, expr.getPos(), ctx)
          }
        ELSE
          EnumType destEnumType = destType ISA EnumType ? destType
                                           : destType.<EnumValueType.C>.enumType
          IF destEnumType ISNOT enumType
            exprExt.undefined = 1
            IF ctx.doError()
              ctx.error("Expected ENUM " .. destEnumType.name
                                 .. " but found ENUM " .. enumType.name, expr)
            }
          }
        }
      }
      ret = EnumValueType.NEW(Type.Enum.enumValue, "enumValue")
      ret.<EnumValueType.C>.enumType = enumType
    }
    ctx.out.write(value .. "")
    RETURN ret
  }

  FUNC genBitsMember(Zui.Expression expr, Type exprType, Type destType,
                                                  SContext ctx, Type retInit
                   ) Type
    string name = expr.getRight().getId().getName()
    Type.Enum dest_type = destType == NIL ? Type.Enum.unknown
                                                         : destType.getTtype()
    Type ret = retInit
    BitsType bitsType
    Zui.Expression left = expr.getLeft()
    VAR exprExt = ZuiExpressionExt.get(expr)
    VAR leftExt = ZuiExpressionExt.get(left)

    IF exprType ISA BitsValueType
      bitsType = exprType.<BitsValueType.C>.bitsType
    ELSE
      bitsType = exprType.<BitsType.C>
    }
    Declaration decl = bitsType.findMember(name, NIL)
    IF decl == NIL
      exprExt.undefined = 1
      IF ctx.doError()
        ctx.error("No such member: " .. name, expr)
      }
    ELSE
      ValueType memberType = decl.type
      IF memberType.getTtype() == Type.Enum.bool
        IF dest_type != Type.Enum.unknown
                && dest_type != Type.Enum.string
                && dest_type != Type.Enum.bool
          exprExt.undefined++
          IF ctx.doError()
            typeError(destType, Type.aBool, expr.getPos(), ctx)
          }
        }
        ret = Type.aBool
        ctx.gen.bitsMemberBool(left, memberType, ctx)
        exprExt.undefined = leftExt.undefined
      ELSEIF memberType.getTtype() == Type.Enum.int
                                   || memberType.getTtype() == Type.Enum.nat
        IF dest_type != Type.Enum.unknown
                && dest_type != Type.Enum.string
                && dest_type != Type.Enum.int
          exprExt.undefined++
          IF ctx.doError()
            typeError(destType, Type.anInt, expr.getPos(), ctx)
          }
        }
        ret = Type.anInt  # TODO: should be memberType?
        ctx.gen.bitsMemberInt(left, memberType, ctx)
        exprExt.undefined = leftExt.undefined
      ELSEIF memberType.getTtype() == Type.Enum.enumValue
        IF dest_type != Type.Enum.unknown
              && dest_type != Type.Enum.string
          # TODO: check enum type
          IF dest_type != Type.Enum.enumValue
            exprExt.undefined++
            IF ctx.doError()
              typeError(destType, Type.aBool, expr.getPos(), ctx)
            }
          }
        }
        string close = ""
        IF dest_type == Type.Enum.string
          close = genEnumNameCall(memberType, expr, ctx)
        ELSE
          ret = EnumValueType.NEW(Type.Enum.enumValue, "enumValue")
          ret.<EnumValueType.C>.enumType = memberType.<EnumValueType.C>.enumType
        }
        ctx.out.write("(((")
        genExpr(left, ctx)
        exprExt.undefined = leftExt.undefined
        int shift = memberType.shift
        ctx.out.write(") & " .. (memberType.mask << shift) .. ")")
        IF shift > 0
          ctx.out.write(" >> " .. shift)
        }
        ctx.out.write(")")
        ctx.out.write(close)
      ELSE
        ctx.error("INTERNAL: Bits member not implemented yet: "
                                               .. memberType.typeName(), expr)
      }
    }
    RETURN ret
  }

  # Get the symbol for the class of the current scope, while "ctx" is the
  # scope of a subclass.  Only does something when coming here from
  # generateParentMethod().
  FUNC getScopeClass(Zui.Expression expr, SContext ctx) ClassType
    ClassType class = ctx.scope.classType
    FOR i IN 1 TO ctx.scope.classType.<ClassType.C>.parentLevel
      ClassType pc = ctx.scope.classType.<ClassType.C>.parent
      IF pc == NIL
        ctx.error("INTERNAL: parentLevel too high in getScopeClass()", expr)
        RETURN NIL
      }
      class = pc
    }
    RETURN class
  }

  # Get the class for PARENT in ctx.scope
  FUNC getParentClass(Zui.Expression expr, SContext ctx) Type
    IF !ctx.scope.isClassScope()
      ctx.error("PARENT not in class context", expr)
      RETURN NIL
    }
    ClassType class = getScopeClass(expr, ctx)
    ClassType pc = class.parent
    IF pc == NIL
      ctx.error("PARENT not in a child class", expr)
    }
    RETURN pc
  }

  # Member expression for PARENT
  # Can only be THIS.PARENT or PARENT.PARENT or PARENT.PARENT.PARENT etc.
  FUNC getParentMember(Zui.Expression expr, SContext ctx, Type retIn) Type
    Type ret = retIn
    Type class
    VAR exprExt = ZuiExpressionExt.get(expr)
    SWITCH expr.getLeft().getType()
      CASE Zui.ExprType.eTHIS
        # THIS.PARENT is the same as PARENT.
        exprExt.undefined = 0
        RETURN getParentClass(expr, ctx)

      CASE Zui.ExprType.eMEMBER
        # PARENT.PARENT.PARENT ...
        class = getParentMember(expr.getLeft(), ctx, retIn)

      CASE Zui.ExprType.ePARENT
        # PARENT.PARENT
        class = getParentClass(expr, ctx)

      DEFAULT
        ctx.error("PARENT cannot be used here", expr)
    }
    IF class == NIL
      exprExt.undefined = 3
    ELSE
      ClassType pc = class.<ClassType.C>.parent
      IF pc == NIL
        exprExt.undefined = 2
        IF ctx.out.writing
          ctx.error("Class " .. class.name
                                    .. " does not EXTEND another class", expr)
        }
      ELSE
        exprExt.undefined = 0
        ret = pc
      }
    }
    RETURN ret
  }

  # Member expression where the top item is a module
  # Module member: module.name                ->  "Vmodule_name"
  #                module.submodule.name      ->  "Vmodule_submodule_name"
  # Class member:  Class.name
  FUNC genModuleMember(Zui.Expression expr, Type moduleType,
                                     ExprArg exprArg, SContext ctx, Type retIn
                      ) Type
    string name = expr.getRight().getId().getName()
    VAR exprExt = ZuiExpressionExt.get(expr)
    IF moduleType == NIL
      exprExt.undefined = 3
    ELSE
      SymUse symUse = NEW(expr.getPos(), ctx)
      symUse.reading = TRUE
      ModuleType mt = moduleType.<ModuleType.C>
      Declaration decl = mt.findMember(name, symUse)
      IF decl == NIL
        IF mt.scope.declDict == NIL || mt.scope.declDict.Size() == 0
          exprExt.undefined = 2
          IF ctx.doError()
            ctx.error("Module without members", expr)
          }
        ELSE
          exprExt.undefined = 1
          IF ctx.doError()
            symUse.doError = TRUE
            IF mt.findMember(name, symUse) == NIL
              ctx.error("No such module member: " .. name, expr.getRight())
            }
          }
        }
      ELSE
        RETURN genModuleOrClassMember(expr, decl, exprArg, ctx, retIn)
      }
    }
    RETURN retIn
  }

  FUNC genModuleOrClassMember(Zui.Expression expr, Declaration decl,
                                   ExprArg exprArg, SContext ctx, Type retIn
                             ) Type
    Type memberType = decl.type
    Type destType = exprArg.destType()
    Type ret = retIn
    Type.Enum dest_type = (destType == NIL) ? Type.Enum.unknown
                                                         : destType.getTtype()
    IF dest_type == Type.Enum.class
      dest_type = Type.Enum.object
    }
    string close = ""
    VAR exprExt = ZuiExpressionExt.get(expr)
    exprExt.undefined = 0

    IF dest_type == Type.Enum.iobject
                                  && memberType.getTtype() == Type.Enum.object
      # Convert from object to interface object.
      ClassType symClass = memberType.getClassType(ctx)
      ClassType destClass = destType.getClassType(ctx)
      string tempName
      IF exprArg.dest != NIL && exprArg.dest.type.isNoAlloc()
        tempName = exprArg.dest.pName
      ELSEIF exprExt.tempDecl != NIL
        tempName = exprExt.tempDecl.pName
      }
      close = ctx.gen.object2iobject(symClass, destClass, tempName,
                                                  expr.getPos(), ctx.out, ctx)
      ret = ClassRefType.NEW(Type.Enum.iobject, destClass, "ret")

      # When a member of destClass is used then that member of symClass must
      # also be considered to be used.
      exprExt.undefined += Declaration.addMemberDependsOn(symClass,
                                                               destClass, ctx)
    ELSE
      IF (dest_type == Type.Enum.funcRef
                                   && memberType.getTtype() == Type.Enum.func)
        || (dest_type == Type.Enum.procRef
                                   && memberType.getTtype() == Type.Enum.proc)
        ret = MethodRefType.NEW(dest_type, memberType, "ret")
      ELSE
        ret = memberType
      }
    }

    # TODO: should we check the type here?
    # IF !Type.compatibleTypes(ret, destType, exprArg)
    #   exprExt.undefined = 1
    #   IF ctx.doError()
    #     typeError(destType, ret, expr.getPos(), ctx)
    #   }
    # }

    IF ctx.scope.inTry()
      # May need to add "volatile" to the declaration.
      decl.isUsedInTry = TRUE
    }

    IF memberType ISA MethodType && memberType.<MethodType>.hasUseArguments()
      # Need to allocate a closure.
      generateClosureRef(&exprExt.undefined, FALSE, NIL, NIL, NIL,
                                           decl, memberType.<MethodType>, ctx)
    ELSE
      ctx.gen.writeSymName(decl, memberType, exprArg.top, ctx)
    }
    ctx.out.write(close)
    IF exprExt.undefined == 0 || usedWhenUndefined
      ctx.addUsedItem(decl)
    }

    RETURN ret
  }

  # Member expression that is not a module, bits or enum.
  # Class member:  whatever.name   ->  whatever "->name"
  # Used in an expression for reading.
  FUNC genClassMember(Zui.Expression expr, ExprArg exprArg,
                                                    SContext ctx, Type retIn
                     ) Type
    Type ret = retIn
    Type leftType
    Type leftDestType
    Type parentType

    Zui.Expression left = expr.getLeft()
    VAR exprExt = ZuiExpressionExt.get(expr)

    # We don't want to generate anything yet, just get the type of what is
    # before the dot.
    leftType = genExpr(left, ctx.copyNoOut(), Type.aParent)
    exprExt.undefined = ZuiExpressionExt.get(left).undefined

    IF leftType == NIL
      ret = NIL
      IF ctx.doError()
        # Let genExpr() produce the error message
        leftType = genExpr(left, ctx, Type.aParent)
      }
    ELSEIF leftType ISA BitsType
      ret = NIL
      IF ctx.doError()
        ctx.error("Can't use a BITS member", expr)
      }
    ELSE
      parentType = leftType
      leftDestType = leftType
      IF leftType.getTtype() == Type.Enum.byRef
        Type refType = leftType.<ReferenceType.C>.getReferencedType()
        IF refType != NIL
          parentType = refType
          leftDestType = parentType
        ELSE
          exprExt.undefined++
        }
      }

      # When the left side is an object or iobject, use the class that it
      # refers to.
      Type.Enum ttype = leftType.getTtype()
      IF ttype == Type.Enum.iobject || ttype == Type.Enum.object
        parentType = leftType.getClassType(ctx)
        IF parentType == NIL
          ++exprExt.undefined
        }
      ELSE
        ttype = leftDestType.getTtype()
      }

      # We don't know if the "def" in "abc.def" is method of the object or
      # something in the SHARED section.  Try the SHARED section if type is
      # class.
      Declaration decl
      SymUse symUse = NEW(expr.getPos(), ctx)
      string name = expr.getRight().getId().getName()
      symUse.reading = TRUE
      IF parentType != NIL
        IF ttype == Type.Enum.class
          decl = parentType.findMember(name, symUse)
        }
        IF decl == NIL
          decl = parentType.findObjectMember(name, symUse, searchParent, FALSE)
          IF ttype == Type.Enum.class && decl != NIL
                                                  && !decl.type.isMethodType()
            # Class.method can be used as a method reference, but Class.member
            # can't be used.
            exprExt.undefined = 2
            IF ctx.doError()
              ctx.error("Can't use object member: " .. name, expr)
            }
            decl = NIL
          }
        }
      }

      IF decl == NIL
        exprExt.undefined = 10
        IF ctx.doError()
          IF parentType != NIL
            symUse.doError = TRUE
            Declaration d
            IF ttype == Type.Enum.class
              d = parentType.findMember(name, symUse)
            ELSE
              d = parentType.findObjectMember(name, symUse, searchParent, FALSE)
              IF d == NIL
                d = parentType.findObjectMember(name, symUse,
                                              searchParent + ignoreLocal, FALSE)
                IF d != NIL
                  ctx.error("member cannot be used, it is @local in parent class: "
                                           .. ZuiFile.expr2String(expr), expr)
                  ctx.error("defined here", d.zuiPos)
                }
              }
            }
            IF d == NIL
              ctx.error("unknown member: " .. name, expr)
            }
          }
        }
        ret = NIL
      ELSEIF ttype == Type.Enum.object || ttype == Type.Enum.iobject
        IF ttype == Type.Enum.object
          # It is possible that a child is found for a class later, then the
          # type changes from object to iobject and we need to come back here to
          # take care of that.
          ClassType ct = leftType.getClassType(ctx)
          IF ct != NIL
            ct.scope.addScopeDependency(ctx.scope)
          }
        }

        IF decl.type.isMethodType()
          # Using a method for a proc reference.
          Type destType = exprArg.destType()
          IF destType != NIL && !destType.isMethodOrRefType()
            ctx.error("Can't use a method here; missing ()?", expr)
          ELSEIF decl.type.<MethodType>.hasUseArguments()
            # Need to get the closure stored with the object.
            generateClosureRef(&exprExt.undefined, FALSE,
                               expr, leftDestType,
                                  leftType, decl, decl.type.<MethodType>, ctx)
          ELSEIF ttype == Type.Enum.iobject
            ctx.gen.iobjectFuncUse(decl, leftType, left, ctx)
          ELSE
            # This always works, also when the left is actually NIL.
            ctx.gen.namelessFuncUse(decl, ctx)
          }
          IF exprExt.undefined == 0 || usedWhenUndefined
            ctx.addUsedItem(decl)
            IF ttype == Type.Enum.iobject
                                  && !decl.type.<MethodType>.hasUseArguments()
              # Mark all methods that could be called as used.
              markMethodsUsed(decl, parentType.<ClassType>, name, symUse, ctx)
            }
          }
          ctx.addUsedItem(Declaration.funcRef)
        ELSEIF leftType.getTtype() == Type.Enum.iobject
          ctx.gen.iobjectMember(decl, leftType, expr,
                              expr.hasDotnil() && expr.getDotnil(),
                                                     ctx, leftDestType, FALSE)
          IF exprExt.undefined == 0 || usedWhenUndefined
            ctx.addUsedItem(decl)
          }
        ELSE
          Output varnameOut = NEW()
          varnameOut.writing = ctx.out.writing
          Type varType = genExpr(left, ctx.copy(varnameOut), leftDestType)
          ctx.gen.member(varnameOut, left.getPos(), varType, decl.type,
                        expr.hasDotnil() && expr.getDotnil(), decl.pName, ctx)
          IF exprExt.undefined == 0 || usedWhenUndefined
            ctx.addUsedItem(decl)
          }
          exprExt.undefined = ZuiExpressionExt.get(left).undefined
        }
        IF decl.type.getTtype() == Type.Enum.unknown
          exprExt.undefined++
        }
        ret = decl.type
      ELSEIF ttype == Type.Enum.class
        # handle like a Module member
        ret = genModuleOrClassMember(expr, decl, exprArg, ctx, ret)
      ELSE
        IF ctx.doError()
          ctx.error("wrong type: " .. ttype.ToString(), expr)
        }
        ret = NIL
      }
    }
    RETURN ret
  }

  # For an iobject method that is used as a reference, mark all possibly
  # called methods as used.
  PROC markMethodsUsed(Declaration decl, ClassType parentType, string name,
                                                  SymUse symUse, SContext ctx)
      markMethodInChildrenUsed(parentType, name, symUse, ctx)
      decl.hasDirectRef = TRUE
      ctx.gen.namelessFuncReference(decl, ctx)
  }

  # Recursively mark all |name| methods in the children of |parent| as used.
  PROC markMethodInChildrenUsed(ClassType parent, string name,
                                                  SymUse symUse, SContext ctx)
    FOR child IN parent.children
      Declaration decl = child.findObjectMember(
                                            name, symUse, searchParent, FALSE)
      IF decl != NIL
        IF decl.type.<MethodType>.producedMethod != NIL
          # This method won't be produced, use the one that is produced.
          decl = decl.type.<MethodType>.producedMethod
        }

        # Only do this when there are no USE arguments, otherwise the callback
        # will be used intead of the method.
        MethodType method = decl.type.<MethodType>
        IF method.callbackStmt == NIL
          decl.hasDirectRef = TRUE
          ctx.gen.namelessFuncReference(decl, ctx)
        }
      }
      markMethodInChildrenUsed(child, name, symUse, ctx)
    }
  }

  FUNC genTupleMember(Zui.Expression expr, TupleType type, ExprArg exprArg,
                                                            SContext ctx) Type
    Zui.Expression left = expr.getLeft()
    Zui.Expression right = expr.getRight()
    string name = right.getId().getName()
    Type r = genTupleItem(type, left, name, ctx)
    # Do not use the .undefined field of right, it's never set.
    ZuiExpressionExt.get(expr).undefined = ZuiExpressionExt.get(left).undefined
                                                          + (r == NIL ? 5 : 0)
    RETURN r
  }

  # Generate an argument that is a function, with return type
  # |valueType| and take one argument of |valueType|.  Used for map().
  # When |keyType| is not NIL it's used for dictMap().
  PROC genFuncArg(Zui.Expression arg,
                               Type keyType, Type valueType, SContext ctx)
    MethodType fType = NEW(Type.Enum.func, "func")
    fType.returnType = valueType
    IF keyType != NIL
      # key argument type must match key
      fType.addArgument("key", keyType, NIL)
    }
    # value argument type must match value
    fType.addArgument("val", valueType, NIL)

    Type frt = fType.getMethodRef()
    Type ftype = genExpr(arg, ctx, frt)
    MethodType methodType = ftype.getMethod()

    IF ctx.gen.writing
      Type retType = methodType.<MethodType.C>.returnType
      IF !Type.compatibleTypes(retType, valueType, ctx)
        ctx.error("Function return type does not match item type", arg)
        typeError(valueType, retType, arg.getPos(), ctx)
      }
      list<Declaration.C> argList = methodType.getArgList()
      IF keyType == NIL
        IF argList.Size() != 1
          ctx.error("Function must take one argument", arg)
        ELSEIF !Type.compatibleTypes(argList[0].type, valueType, ctx)
          ctx.error("Function argument type does not match item type", arg)
          typeError(valueType, argList[0].type, arg.getPos(), ctx)
        }
      ELSE
        IF argList.Size() != 2
          ctx.error("Function must take two arguments", arg)
        ELSEIF !Type.compatibleTypes(argList[0].type, keyType, ctx)
          ctx.error("First function argument type does not match key type", arg)
          typeError(keyType, argList[0].type, arg.getPos(), ctx)
        ELSEIF keyType != NIL && !Type.compatibleTypes(argList[1].type,
                                                             valueType, ctx)
          ctx.error("Second function argument type does not match item type",
                                                                          arg)
          typeError(valueType, argList[1].type, arg.getPos(), ctx)
        }
      }
    }
  }

  # Given an error about expected and actual type
  PROC typeError(Type expected, Type actual, Zui.Position pos, SContext ctx)
    IF expected != NIL && expected.getTtype() != Type.Enum.unknown
      IF actual.isMethodType()
        ctx.error("Type mismatch: expected " .. expected.typeName()
                                   .. " but found " .. actual.typeName(), pos)
        ctx.error("Missing ()?", pos)
      # If the actual type is unknown there most likely is an error
      # elsewhere, don't give an error here.
      ELSEIF actual ISNOT Type.anUnknown
        string expectedName = expected.typeName()
        string actualName = actual.typeName()
        IF expectedName == actualName
          expectedName = expected.typeToString()
          actualName = actual.typeToString()
        }
        ctx.error("Type mismatch: expected " .. expectedName
                                        .. " but found " .. actualName, pos)
      }
      # For debugging.
      # THROW "here it is"
    }
  }

  # Check that the name of |decl| starts with a lower case letter.
  # Used for a function, enum value, etc.
  PROC checkItemName(Zui.Declaration decl, string what, SContext ctx)
    string name = decl.getName()
    IF (name[0] < 'a' || name[0] > 'z') && name[0] != '_'
      ctx.error(what .. " name must start with lower case letter: "
                                                                .. name, decl)
    }
  }

  # Check that the name of |decl| starts with an upper case letter.
  # Used for Class, Enum, Bits, etc.
  PROC checkTypeName(Zui.Declaration decl, string what, SContext ctx)
    string name = decl.getName()
    IF name[0] < 'A' || name[0] > 'Z'
      ctx.error(what .. " name must start with an upper case letter", decl)
    }
    IF what == "interface"
      IF !name.startsWith("I_")
        ctx.error("interface name must start with I_", decl)
      }
    ELSEIF name.Size() > 0 && name[1] == '_'
                                && !(what == "class" && name.startsWith("E_"))
      # Class starting with E_ that is not an exception checked elsewhere.
      ctx.error(what
           .. " name cannot have an underscore as the second character", decl)
    }
  }

}
