#
# The Zimbu compiler written in Zimbu
#
# WriteC class and module: Methods are invoked from Generate for each
# statement and expression to generate C code.
#
# Copyright 2009-2012 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

# Names used for the generated C code:
# A.*                   method argument
# C.*                   class name
# F.*                   function name
# I[a-z]                special purpose
# Iaa, Iab, Iaaa, etc.  Unique IDs from getUid()
# J.*                   Initialize function
# M.*                   module name
# V.*                   local variable
# Z.*                   internal function
#
# Typedefs:
# Ti   64 bit int
# Ti16 16 bit int
# Ti32 32 bit int
# Tip  int that can hold a pointer
# Tz   int that can hold any int, nat, float or pointer
# Tu   64 bit unsigned
# Tc   unsigned char, used for string, byteString
# Tu16 nat16
# Tu32 nat32
# Tb   bool
# Ts   status
# Te   enum
# Tbs  small BITS 32 bit
# Tbb  big BITS 64 bit
# Tr   object ref
# To   object description
#
# Tf   float
# Tf32 float32
#
# Tx   dyn
# Tt   type
# Tto  type with object description
#
# Ty   varByteString, varString
# Tv   pieceval
# Tp   piece
# Tcd   cord
# Tg   grow array
#
# Tfe  FOR in enum
# Tfs  FOR in string
# Tfr  FOR in range
#
# Tcode  code location
# Tcb    callback
# Tn     environment struct
# Ta     array head
# Td     dict head
# Tl     list head
#

IMPORT.PROTO "../zui.proto"

IMPORT "WriteArrayC.zu"
IMPORT "WriteListC.zu"
IMPORT "WriteDictC.zu"
IMPORT "WriteIMT.zu"

IMPORT "../ArrayStuff.zu"
IMPORT "../BitsType.zu"
IMPORT "../BitsValueType.zu"
IMPORT "../BlockScope.zu"
IMPORT "../Builtin.zu"
IMPORT "../CallbackType.zu"
IMPORT "../ClassType.zu"
IMPORT "../CodeTable.zu"
IMPORT "../Config.zu"
IMPORT "../ContainerType.zu"
IMPORT "../Conversion.zu"
IMPORT "../Declaration.zu"
IMPORT "../DeclStore.zu"
IMPORT "../DictStuff.zu"
IMPORT "../EnumType.zu"
IMPORT "../EnumValueType.zu"
IMPORT "../ExprArg.zu"
IMPORT "../ExprEval.zu"
IMPORT "../FileScope.zu"
IMPORT "../ForLoopInfo.zu"
IMPORT "../Generate.zu"
IMPORT "../ListStuff.zu"
IMPORT "../ManageMemory.zu"
IMPORT "../MethodScope.zu"
IMPORT "../MethodRefType.zu"
IMPORT "../MethodType.zu"
IMPORT "../ModuleScope.zu"
IMPORT "../ModuleType.zu"
IMPORT "../MultipleType.zu"
IMPORT "../NoAllocType.zu"
IMPORT "../Output.zu"
IMPORT "../ReferenceType.zu"
IMPORT "../Resolve.zu"
IMPORT "../SContext.zu"
IMPORT "../Scope.zu"
IMPORT "../SwitchScope.zu"
IMPORT "../SymUse.zu"
IMPORT "../TargetLang.zu"
IMPORT "../TopScope.zu"
IMPORT "../TryScope.zu"
IMPORT "../Type.zu"
IMPORT "../TupleType.zu"
IMPORT "../UsedFile.zu"
IMPORT "../ValueType.zu"
IMPORT "../WriteCommon.zu"
IMPORT "../ZimbuFile.zu"
IMPORT "../ZuiFile.zu"
IMPORT "../ZuiCodeBlockExt.zu"
IMPORT "../ZuiExpressionExt.zu"
IMPORT "../ZuiMethodCallExt.zu"
IMPORT "../ZuiStatementExt.zu"
IMPORT "../ZuiTryStatementExt.zu"

# The methods that are implemented for the Resolve.I interface are commented
# in resolve.zu.
CLASS WriteC EXTENDS WriteCommon IMPLEMENTS Resolve.I
                           @public @items=public   # TODO: restrict visibility

  TargetLang $targetLang

  NEW()
    $writing = TRUE
    $targetLang.c = TRUE

    $virtualFuncMap = NEW()
    $virtualDeclOut = NEW(NEW())
    $virtualBodyOut = NEW(NEW())
  }

  FUNC $getLangName() string @replace
    RETURN "C"
  }

  FUNC $getTargetLang() TargetLang @replace
    RETURN $targetLang
  }

  FUNC $thisName(bool insideNew) string
    RETURN cThisName
  }

  # Write statement and line end, usually ";\n".
  PROC $statementLineEnd(Output out)
    out.write(";\n")
  }

  # Return TRUE if an abstract method method is not to be generated.
  FUNC $skipAbstractMethod() bool
    RETURN TRUE
  }

  # Return TRUE if a method from the parent is to be written in a child class.
  FUNC $doWriteParentMethod(Declaration decl) bool
    RETURN TRUE
  }

  # Write code for the end of a scope.
  # |willJump| is true when there is a jump next, no need to jump out of the
  # scope here.
  # |statements| can be NIL.
  PROC $writeScopeEnd(bool writeLabel, bool willJump,
               list<Zui.Statement> statements, Zui.Position pos, SContext ctx)
    bool needAStmt
    IF writeLabel && ctx.scope.retLabel != NIL
      ctx.out.write(ctx.scope.retLabel .. ":\n")
      # We need a statement after the label, unless in the method scope.
      needAStmt = ctx.scope ISNOTA MethodScope
    }

    IF ctx.scope.writeEndOfScope(ctx.out)
      needAStmt = FALSE
    }

    Zui.Statement lastStmt
    IF statements != NIL && statements.Size() > 0
      lastStmt = statements[-1]
    }

    # Call Finish for any objects located on the stack.
    # For a method scope it's done in $writeBeforeReturn().
    IF ctx.scope ISNOTA MethodScope
      $writeScopeEndFinish(lastStmt == NIL ? pos : lastStmt.getPos(), ctx)
    }

    bool isLoopOrSwitchScope =
                          ctx.scope.isLoopScope() || ctx.scope.isCaseScope()
    IF isLoopOrSwitchScope
      # When in the loop scope may break or continue.
      # Clear the break and continue flags from "rt", leaving only the flag
      # indicating return.
      IF ctx.scope.hasBreak
        ctx.out.writeIndent(ctx.scope.depth)
        ctx.out.write("if (rt == " .. scopeBreak)
        ctx.out.write(") { rt &= " .. scopeReturn .. "; break; }\n")
        needAStmt = FALSE
      }
      IF ctx.scope.hasContinue
        ctx.out.writeIndent(ctx.scope.depth)
        ctx.out.write("if (rt == " .. scopeContinue)
        ctx.out.write(") { rt &= " .. scopeReturn .. "; continue; }\n")
        needAStmt = FALSE
      }
    }

    IF ctx.scope ISNOTA MethodScope
           && !willJump
           && (ctx.scope.needRetFlag
               || (ctx.scope.hasBreak || ctx.scope.hasContinue)
                                                      && !isLoopOrSwitchScope)
      ctx.out.writeIndent(ctx.scope.depth)

      bool skipIf
      IF lastStmt != NIL && lastStmt.getType() == Zui.StatementType.eBREAK
        # The check for rt being non-zero is not needed after a BREAK, it is
        # always set to 2.  However, if this is inside a TRY with a FINALLY,
        # rt will not have be set.
        Scope s = ctx.scope.tryScope(TRUE, FALSE)
        IF s == NIL || !s.<TryScope>.hasFinally
          skipIf = TRUE
        }
      }
      IF !skipIf
        ctx.out.write("if (rt) ")
      }
      $writeJumpToLabel(ctx)
      needAStmt = FALSE
    }

    IF needAStmt
      # May not have written something after the label.
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write(";\n")
    }
  }

  # Write a goto to the end of the outer scope.
  # Caller must write the indent.
  PROC $writeJumpToLabel(SContext ctx)
    ctx.out.write("goto ")
    IF ctx.scope.outer ISA TryScope
      IF ctx.scope.outer.outer.retLabel == NIL
        ctx.scope.outer.outer.retLabel = getUid(ctx.scope.scopeName)
      }
      ctx.out.write(ctx.scope.outer.outer.retLabel)
    ELSE
      IF ctx.scope.outer.retLabel == NIL
        ctx.scope.outer.retLabel = getUid(ctx.scope.scopeName)
      }
      ctx.out.write(ctx.scope.outer.retLabel)
    }
    ctx.out.write(";\n")
  }

  # Generate the interface member lookup table, when needed.
  PROC $interfaceMemberTable(Declaration decl, Declaration itfDecl,
                                                                 SContext ctx)
    Type itf = itfDecl.type
    IF !decl.type.<ClassType>.isAbstract()
      Declaration useDecl = decl.isUsingInterface(itf, ctx)
      IF useDecl != NIL && $isDeclUsed(useDecl)
        WriteIMT.generateInterfaceMemberTable(decl, itf, ctx)
      }
    }
  }

  # Write interface member lookup tables for a class.
  PROC $writeIMTTables(Declaration decl, set<string> imtDone, SContext ctx)
    ClassType classType = decl.type.<ClassType>

    # For the class, it's parent, parent of parent, etc. generate the
    # interface member lookup table.  Only needed for C and when the class
    # is not abstract (there can be instances).
    IF !classType.isAbstract()
      ClassType itfType = classType
      string cname = ""
      WHILE itfType != NIL
        cname ..= "." .. itfType.name
        # TODO: when there are no children there may be a reference to the
        # interface anyway, but it's rare.  Check if the class was used as an
        # interface and skip generating the table if not.
        IF !imtDone.has(cname)
          Declaration useDecl = decl.isUsingInterface(itfType, ctx)
          IF useDecl != NIL && $isDeclUsed(useDecl)
            WriteIMT.generateInterfaceMemberTable(decl, itfType, ctx)
          }
          imtDone.add(cname)
        }

        IF itfType.interfaces != NIL
          # Also generate a table for each interface that this parent class
          # implements.  But only when not done yet, there can be
          # duplicates.
          FOR idecl IN itfType.interfaces
            string iname = idecl.getInterfaceName(ctx)
            IF !imtDone.has(iname)
              Declaration useDecl = decl.isUsingInterface(idecl, ctx)
              IF useDecl != NIL && $isDeclUsed(useDecl)
                WriteIMT.generateInterfaceMemberTable(decl, idecl.type, ctx)
              }
              imtDone.add(iname)
            }
          }
        }

        itfType = itfType.parent
      }
    }

    IF classType.imttDecl != NIL && $isDeclUsed(classType.imttDecl)
      # Produce a table with all InterfaceMemberTables.  This is used when
      # converting one iobject into another in ZconvertZoref().
      WriteIMT.generateIMTTable(classType, ctx)
    }
  }

  # Write object declaration table for a class.
  PROC $writeToTable(Declaration decl, SContext ctx)
    WriteIMT.writeToTable(decl, ctx)
  }

  # End of writing declaration table for a class.
  PROC $writeIMTend(SContext ctx)
    WriteIMT.writeIMTend(ctx)
  }

  FUNC $getCS(ZimbuFile zimbuFile) ZimbuFile.CodeSpecific
    RETURN zimbuFile.c
  }

  # Return TRUE if there is code at the toplevel (not allowed for imported
  # files).
  FUNC $toplevelLines(ZimbuFile zimbuFile) bool
    RETURN !zimbuFile.c.outputs.mainOut.empty()
  }

  FUNC $catchSignals() bool
    RETURN !Config.noBacktrace || $isDeclUsed(Declaration.try)
  }

  FUNC $gcSignal() bool
    RETURN $isDeclUsed(%pthread) && $manageMemory()
                                             && $isDeclUsed(Declaration.gcRun)
  }

  # Write the main() function and initialization.
  PROC $mainHead(MethodType method, SContext ctx)

    # The deadly signals are caught and can be turned into an exception.  In
    # that case the signal function does not return, thus we must make sure
    # signals are not blocked.  MingW requires another solution.
    IF $catchSignals() || $gcSignal()
      ctx.out.write(''"
#if defined(__MINGW32__) || defined(_MSC_VER)
# define CATCH_SIG(sig, func) signal(sig, func)
  typedef struct SEH_EXCEPTION_REGISTRATION_S SEH_EXCEPTION_REGISTRATION;
  struct SEH_EXCEPTION_REGISTRATION_S
  {
    SEH_EXCEPTION_REGISTRATION *prev;
    PEXCEPTION_HANDLER handler;
  };
  static EXCEPTION_DISPOSITION exception_handler(PEXCEPTION_RECORD pRecord, SEH_EXCEPTION_REGISTRATION *pReg, PCONTEXT pContext, PEXCEPTION_RECORD pRecord2) {
   Zdeadly(11);
   return ExceptionContinueSearch;
  }
#else
# define CATCH_SIG(sig, func) catch_sig(sig, func)
void catch_sig(int sig, void *func) {
 struct sigaction act;
 act.sa_handler = func;
 sigemptyset(&act.sa_mask);
 act.sa_flags = SA_NODEFER;
 sigaction(sig, &act, NULL);
}
#endif
"'')
    }

    ctx.out.write(''"
int Fmain(void);
int main(int argc, char **argv) {
 int r = 0;
 int round = 0;"'')

    # If there is no backtrace and no try-catch a crash is just a crash.
    IF $catchSignals()
      # For MingW us an exception registration structure.
      ctx.out.write(''"
#if defined(__MINGW32__) || defined(_MSC_VER)
 SEH_EXCEPTION_REGISTRATION seh_er;
 seh_er.handler = (PEXCEPTION_HANDLER)(exception_handler);
 asm volatile ("movl %%fs:0, %0" : "=r" (seh_er.prev));
 asm volatile ("movl %0, %%fs:0" : : "r" (&seh_er));
#else
# ifdef SIGSEGV
 CATCH_SIG(SIGSEGV, Zdeadly);
# endif
# ifdef SIGBUS
 CATCH_SIG(SIGBUS, Zdeadly);
# endif
# ifdef SIGFPE
 CATCH_SIG(SIGFPE, Zdeadly);
# endif
#endif"'')
    }
    IF $gcSignal()
      ctx.out.write(''"
 CATCH_SIG(GC_SIG, ZwantGC);"'')
    }

    # Force MingW to do all I/O in binary mode, don't want CR-LF to be
    # converted to LF, that causes lots of trouble.
    # Same for MSVC.
    ctx.out.write(''"
#if defined(__MINGW32__) || defined(_MSC_VER)
# ifdef __MINGW32__
 _fmode = _O_BINARY;
# else
 _set_fmode(_O_BINARY);
# endif
 _setmode(_fileno(stdin), _O_BINARY);
 _setmode(_fileno(stdout), _O_BINARY);
 _setmode(_fileno(stderr), _O_BINARY);
#endif"'')

    IF $isDeclUsed(%pthread)
      ctx.out.write(''"
 ZenvInit();"'')
    }

    # Reserve memory to be used when out of memory, so that we can throw an
    # exception.  Should be enough to contain a stack backtrace with 30
    # entries.
    ctx.out.write(''"
 emergencyAlloc = malloc("'' .. emergencyAllocSize .. ''");"'')

    # Initialize imt tables.
    ctx.out.write(''"
 ZimtInit();"'')

    # Initialize static members of builtin modules.
    # Init sequence round numbers:
    # 0           builtin modules init
    # 1           init ARG types and vars with @earlyInit or object of a class
    #             marked with @earlyInit.
    # 2-1001      Invoke EarlyInit() functions, may call ARG.disable() and do
    #             its own command line parsing.
    # -           Do standard cmdline parsing, unless disabled.
    # 2001        Init non-early vars, they can use flags.
    # 2002 - 3001 Invoke Init() functions.
    ctx.out.write(''"
 ZglobInit(round++);"'')

    # Write main() early init lines for libraries.  Must be after first
    # ZglobInit().
    FOR p IN mainEarlyinitWriters
      p(THIS, ctx.out)
    }

    # Initialize static members of other modules.
    # Call EarlyInit() functions until done.
    ctx.out.write(''"
 ZglobInit(round++);
 while (!ZglobInit(round++)) {
  if (round == 1002) ZthrowCstringInit("Early initialization not done within 1000 rounds");
 }
"'')

    # Write main() init lines for libraries.
    FOR p IN mainInitWriters
      p(THIS, ctx.out)
    }

    # Initialize static members of non-builtin modules.
    # Call Init() functions until done.
    ctx.out.write(''"
 round = 2001;
 ZglobInit(round++);
 while (!ZglobInit(round++)) {
  if (round == 3002) ZthrowCstringInit("Initialization not done within 1000 rounds");
 }
 r = Fmain();
 beforeExit();"'')

    IF (!ctx.scope.noBacktrace && !Config.noBacktrace) || $manageMemory()
      IF $isDeclUsed(%pthread)
        ctx.out.write(''"
 if (ZgetEnv()->topFrame != NULL)"'')
      ELSE
        ctx.out.write(''"
 if (topFrame != NULL)"'')
      }
      ctx.out.write(''" fprintf(stderr, "INTERNAL: topFrame not NULL\n");"'')
    }
    ctx.out.write(''"
 return r;
}

"'')

    $methodLeader(method, ctx.out, ctx)

    # Similar to $methodStart().
    ctx.out.write(''"
int Fmain(void) {
"'')
  }

  PROC $mainMiddle(SContext ctx)
    ctx.out.write(" r = 0;\n")
  }

  PROC $mainEnd(SContext ctx)
    ctx.out.write("}\n")
  }

  PROC $writeVirtual(SContext ctx)
    IF $writing && ctx.scope ISA FileScope
      # Append the functions for virtual methods.
      ctx.outs.declOut.append($virtualDeclOut)
      $virtualDeclOut.clear()
      ctx.outs.bodyOut.append($virtualBodyOut)
      $virtualBodyOut.clear()
    }
  }

  PROC $writeAlloc(string typeName, Declaration finishMethod,
                                                     Output out, SContext ctx)
    IF finishMethod != NIL && $isDeclUsed(Declaration.hasFinish)
      out.write("ZaF(sizeof(" .. typeName .. "), To")
      out.write(typeName .. ", (Ts (*)(void*, Te))" .. finishMethod.pName)
      # TODO: why would scope be NIL?
      out.write(finishMethod.type.<MethodType>.scope?.notOnExit ? ", 1" : ", 0")
      out.write(")")
    ELSE
      out.write("Za(sizeof(" .. typeName .. "))")
    }
  }

  # Write a call to $Init()
  PROC $writeObjectInit(Declaration initMethod, ClassType classType,
                                               Declaration dest, SContext ctx)
    IF dest.type.isNoAlloc() && !dest.type.<NoAllocType>.needAlloc()
      #  "%foo = NEW()" clears %foo instead of allocating an object.
      Declaration finishMethod = Generate.getFinishMethod(classType.scope, ctx)
      $writeNoAllocClear(classType.pName, initMethod, finishMethod, dest, ctx)
    ELSE
      ctx.out.write(initMethod.pName .. "(NULL)")
    }
  }

  # Write a call to clear a not allocated object.
  PROC $writeNoAllocClear(string typeName, Declaration initMethod,
                     Declaration finishMethod, Declaration dest, SContext ctx)
    string className = dest.type.<NoAllocType>.getClassName(typeName)
    string destName = dest.type.getTtype() == Type.Enum.iobject
                                             ? dest.pName .. "_o" : dest.pName
    $writeNoAllocClear(className, initMethod, finishMethod, destName, ctx)
  }

  # Write a call to clear a not allocated item.
  PROC $writeNoAllocClear(string typeName, Declaration initMethod,
                      Declaration finishMethod, string destName, SContext ctx)
    Output out = ctx.out
    out.write("ZnoAllocClear(sizeof(" .. typeName .. "), &" .. destName)
    IF $isDeclUsed(Declaration.hasFinish)
      IF finishMethod != NIL
        out.write(", (Ts (*)(void*, Te))" .. finishMethod.pName)
      ELSE
        out.write(", NULL")
      }
    }
    IF initMethod != NIL
      out.write(", (void *(*)(void*))" .. initMethod.pName)
    ELSE
      out.write(", NULL")
    }
    out.write(")")
    $setDeclUsed(%noAllocClear)
  }

  # Allocate a new string from an array.
  PROC $writeNewString(Zui.MethodCall call, int &undef, SContext ctx)
    Output out = ctx.out
    out.write("ZStringFromArray(")
    list<Zui.Expression> args = call.getArgumentList()
    ContainerType array = Generate.genExpr(args[0], ctx, Type.anArray)
    IF array == NIL || array.itemType == NIL || !array.itemType.isIntType()
      ctx.error("First argument must be an array of int or nat", args[0])
    }
    out.write(", ")
    IF args.Size() >= 2
      Generate.genExpr(args[1], ctx, Type.anInt)
    ELSE
      out.write("0")
    }
    out.write(", ")
    IF args.Size() == 3
      Generate.genExpr(args[2], ctx, Type.anInt)
    ELSE
      out.write("-1")
    }
    out.write(")")
    $setDeclUsed(%stringFromArray)
  }

  PROC $writeArrayAlloc(ContainerType type, string noAllocName,
                                Zui.MethodCall call, int &undef, SContext ctx)
    WriteArrayC.writeArrayAlloc(type, noAllocName, call, undef, ctx)
  }

  PROC $writeListAlloc(ContainerType type, string noAllocName,
                                Zui.MethodCall call, int &undef, SContext ctx)
    WriteListC.writeListAlloc(type, noAllocName, call, undef, ctx)
  }

  PROC $writeDictAlloc(ContainerType type, string noAllocName,
                                            Zui.MethodCall call, SContext ctx)
    WriteDictC.writeDictAlloc(type, noAllocName, call, FALSE, ctx)
  }

  # Write the code to declare a callback type.
  PROC $writeCallbackDecl(CallbackType type, Zui.Position pos, SContext ctx)
    IF !ctx.out.writing
      RETURN
    }
    ctx.outs.typeOut.write("typedef struct " .. type.pName .. "__S "
                                                       .. type.pName .. ";\n")

    # Struct used to store info about the callback.
    # The start is equal to "Tcb".
    ctx.outs.structOut.write("struct " .. type.pName .. "__S {\n"
                      .. $callbackHead() .. " Tcb *cb;\n")  # callback to call
    int argSize = type.arguments.Size()
    int toSize = 1  # one for the object type
    list<Declaration> argClassList = NEW()
    FOR arg IN type.arguments
      # For "USE &$m" we store the object instead of the member.
      Declaration declClass = arg.getClass()
      IF declClass != NIL
        # If the method was copied from a parent, use the current class for
        # the argument, not the parent.
        declClass = type.getClass()
      }
      IF arg.type == NIL
        ctx.error("Unknown type", pos)
      ELSE
        IF arg.type.ttype == Type.Enum.byRef && declClass != NIL
          argClassList.add(declClass)
          ++toSize
        ELSE
          # Other argument, check if it's memory managed.
          argClassList.add(NIL)
          IF arg.type.isManaged()
            ++toSize
          }
        }
      }
    }
    ctx.outs.structOut.write(" To to[" .. toSize .. "];\n")

    # "t" stores the object if it was used when creating the callback:
    # callback<...> cb = NEW(obj.method, ....)  obj is stored in "t"
    ctx.outs.structOut.write(" void *t;\n")

    FOR idx IN 0 UNTIL argSize
      ctx.outs.structOut.write(" ")
      IF argClassList[idx] != NIL
        $vartype(argClassList[idx].type, TRUE, pos, ctx.outs.structOut, ctx)
      ELSE
        $vartype(type.arguments[idx].type, TRUE, pos, ctx.outs.structOut, ctx)
      }
      ctx.outs.structOut.write(" arg" .. (idx + 1))
      ctx.outs.structOut.write(";\n")
    }
    ctx.outs.structOut.write("};\n")

    # Function used to allocate a new callback struct: Za{typename}().
    Output dout = NEW()
    dout.writing = ctx.out.writing
    SContext dctx = ctx.copy(dout)
    dout.write(type.pName .. " *Za" .. type.pName .. "(")
    dout.write(type.pName .. " *p, void *t, Tt *tt, Tcb *cb")
    FOR i IN 1 TO argSize
      dout.write(", ")
      IF argClassList[i - 1] != NIL
        $vartype(argClassList[i - 1].type, TRUE, pos, dout, ctx)
      ELSE
        $vartype(type.arguments[i - 1].type, TRUE, pos, dout, ctx)
      }
      dout.write(" arg" .. i)
    }
    dout.write(")")

    ctx.outs.declOut.append(dout)
    ctx.outs.declOut.write(";\n")

    Output bodyOut = ctx.outs.origBodyOut ?: ctx.outs.bodyOut
    bodyOut.append(dout)
    bodyOut.write(" {\n" .. " " .. type.pName .. " *r = p == NULL ? Za(sizeof(")
    bodyOut.write(type.pName .. ")) : p;\n")
    bodyOut.write(" r->cfunc = Zcb" .. type.pName .. ";\n")
    bodyOut.write(" r->toCount = " .. toSize .. ";\n")
    bodyOut.write(" r->t = t;\n")
    bodyOut.write(" r->cb = cb;\n")
    int toIdx
    FOR i IN 1 TO argSize
      bodyOut.write(" r->arg" .. i .. " = arg" .. i .. ";\n")
      Type argType
      IF argClassList[i - 1] != NIL
        argType = argClassList[i - 1].type
      ELSE
        argType = type.arguments[i - 1].type
      }
      IF argType != NIL && argType.isManaged()
        bodyOut.write(" r->to[" .. toIdx .. "].off = (void*)(&r->arg"
                                                    .. i .. ") - (void*)r;\n")
        bodyOut.write(" r->to[" .. toIdx .. "].type = "
                                           .. getTname(argType, ctx) .. ";\n")
        ++toIdx
      }
    }

    # store type of the object
    bodyOut.write(" r->to[" .. toIdx .. "].off = (void*)(&r->t) - (void*)r;\n")
    bodyOut.write(" r->to[" .. toIdx .. "].type = tt;\n")
    bodyOut.write(" return r;\n")
    bodyOut.write("}\n")

    $writeCallbackFunc(type, argClassList, NIL, pos, ctx)
  }

  # For a callback<> |type| is set, for a simple method ref |decl| is set.
  # For a callback<> |argClassList| has a non-NIL for an argument that is an
  # object member.
  PROC $writeCallbackFunc(CallbackType type, list<Declaration> argClassList,
                             Declaration decl, Zui.Position pos, SContext ctx)
    # Function used to invoke the callback:
    # {return-type} Zcb{typename}({typename} *cb, arg1, arg2) {
    #  [return] {type cast}cb->func(arg1, arg2, cb->arg1, cb->arg2);
    # }
    Output dout = NEW()
    dout.writing = ctx.out.writing
    SContext dctx = ctx.copy(dout)

    MethodType method
    string pName
    string typeName
    IF type == NIL
      method = decl.type.getMethod()
      pName = decl.pName
      typeName = "Tcb"
    ELSE
      method = type.methodType.getMethod()
      pName = type.pName
      typeName = pName
    }
    $writeReturnType(method, pos, dctx)
    dout.write(" Zcb" .. pName .. "(" .. typeName .. " *cb")

    int objectArgIdx
    FOR i IN 0 UNTIL argClassList.Size()
      IF argClassList[i] != NIL
        objectArgIdx = i + 1
        BREAK
      }
    }

    # The object is only passed when there is no "USE &$m" argument.
    IF method.getClassName() != NIL && objectArgIdx == 0
      dout.write(", " .. method.getClassName() .. " *t")
    }
    FOR i IN 0 UNTIL method.arguments.Size()
      dout.write(", ")
      $vartype(method.arguments[i].type, TRUE, pos, dout, ctx)
      dout.write("arg" .. i)
    }
    dout.write(")")

    ctx.outs.declOut.append(dout)
    ctx.outs.declOut.write(";\n")

    Output bout = ctx.outs.origBodyOut ?: ctx.outs.bodyOut
    SContext bctx = ctx.copy(bout)
    bout.append(dout)
    bout.write(" {\n")

    FOR withObject IN type == NIL ? [FALSE] : [TRUE, FALSE]
      IF type != NIL
        IF withObject
          bout.write(" if (cb->t) ")
        ELSE
          bout.write(" else ")
        }
      }

      IF method.returnType != NIL
        bout.write("return ")
      }
      string comma = ""
      IF type == NIL
        # For a ZCB_ we know the function to be called.
        bout.write(pName .. "(")
      ELSE
        # Need a type cast with first the arguments of the called method, then
        # the USE arguments.
        $refCast(type != NIL ? type.calledMethodType : method, TRUE,
                                                        withObject, pos, bctx)
        bout.write("cb->cb->cfunc)(cb->cb")
        comma = ", "
      }
      IF withObject
        bout.write(comma .. "cb->t")
        comma = ", "
      ELSEIF method.getClassName() != NIL
        bout.write(comma)
        IF objectArgIdx > 0
          bout.write("cb->arg" .. objectArgIdx)
        ELSE
          bout.write("t")
        }
        comma = ", "
      }
      FOR i IN 0 UNTIL method.arguments.Size()
        bout.write(comma .. "arg" .. i)
        comma = ", "
      }
      IF type != NIL
        FOR i IN 1 TO type.arguments.Size()
          bout.write(comma)
          Declaration argDecl = type.arguments[i - 1]
          IF argClassList[i - 1] != NIL
            # "USE &$m" Passed in is a pointer to the object, get a reference to
            # the member.
            bout.write("&cb->arg" .. i .. "->" .. argDecl.pName)
          ELSEIF argDecl.type == NIL
            ctx.error("Unknown type", pos)
          ELSE
            bool at = argDecl.type.isAllocType(ctx)
            IF at
              bout.write("&")
            }
            bout.write("cb->arg" .. i)
            IF at
              bout.write("->Vm")
            }
          }
          comma = ", "
        }
      }
      bout.write(");\n")
    }

    bout.write("}\n")
  }

  # Allocate a new callback for |type|.
  PROC $writeCallbackAlloc(CallbackType type,
                           string noAllocName,
                           Generate.CallbackInfo cbInfo,
                           Zui.MethodCall call,
                           int &undef,
                           SContext ctx)
    list<Zui.Expression> args = call.getArgumentList()
    int argOffset = cbInfo != NIL ? 0 : 1
    IF args.Size() != type.arguments.Size() + argOffset
      ctx.error("Expected " .. (type.arguments.Size() + argOffset)
                        .. " arguments, found " .. args.Size(), call.getPos())
      RETURN
    }
    ctx.out.write("Za" .. type.pName .. "(")
    IF noAllocName == NIL
      ctx.out.write("NULL, ")
    ELSE
      ctx.out.write("&" .. noAllocName .. ", ")
    }

    bool isObject
    bool isIobject
    Zui.Expression methodExpr = cbInfo != NIL ? call.getName() : args[0]
    Type leftType
    Zui.Expression left
    IF methodExpr.getType() == Zui.ExprType.eMEMBER
      left = methodExpr.getLeft()
      leftType = genExpr(left, ctx.copyNoOut())
      IF leftType != NIL
        isIobject = leftType.getTtype() == Type.Enum.iobject
        isObject = leftType.getTtype() == Type.Enum.object
      }
    }

    # TODO: when "left" is not a simple variable will need to put the result
    # of the expression in a temp var.
    IF isObject
      Type objType = genExpr(left, ctx)
      ctx.out.write(", " .. $getAnyType(objType, left.getPos(), ctx) .. ", ")
    ELSEIF isIobject
      genExpr(left, ctx)
      ctx.out.write(".ptr, (Tt*)")
      genExpr(left, ctx)
      ctx.out.write(".table[0], ")
    ELSE
      ctx.out.write("NULL, NULL, ")
    }

    # Write the function reference.
    IF cbInfo == NIL
      Generate.genExpr(methodExpr, ctx, type.calledMethodType.getMethodRef())
    ELSEIF isIobject
      ctx.gen.iobjectFuncUse(cbInfo.methodType, leftType, left, ctx)
      SymUse symUse = NEW(methodExpr.getPos(), ctx)
      Generate.markMethodsUsed(cbInfo.methodType,
                         leftType.getClassType(ctx), cbInfo.methodType.name,
                                                                symUse, ctx)
    ELSE
      $namelessFuncUse(cbInfo.methodType, ctx)
    }

    FOR i IN argOffset UNTIL args.Size()
      ctx.out.write(", ")
      Generate.genExpr(args[i], ctx, type.arguments[i - 1].type)
    }
    ctx.out.write(")")
  }

  # Allocate a new closure for |type|.
  PROC $writeClosureAlloc(CallbackType type, MethodType method, bool typeCast,
                                                     int &undef, SContext ctx)
    IF typeCast
      ctx.out.write("(Tcb*)")
    }
    # TODO: second argument can be an object, with third its type?
    ctx.out.write("Za" .. type.pName .. "(NULL, NULL, NULL, ")
    $namelessFuncUse(type.calledMethodType, ctx)
    FOR l IN [method.useArguments, method.autoArguments]
      FOR arg IN l
        ctx.out.write(", ")
        IF arg.type ISA MethodRefType
          # PROC foo(USE funcName): generate callback decl for funcName
          Generate.generateMethodUse(undef, arg.type.getMethod(),
                                                    arg.type.getMethod(), ctx)
        ELSE
          Declaration argClass = arg.getClass()
          IF arg.type.ttype == Type.Enum.byRef && argClass != NIL
            # Pass the object reference, so that it remains referenced for
            # garbage collection.
            ctx.out.write(ctx.scope.thisName)
          ELSE
            IF arg.type.ttype == Type.Enum.byRef
              ctx.out.write("&")
            }
            IF arg.getClass() != NIL && !arg.type.isAllocType(ctx)
              ctx.out.write(ctx.scope.thisName .. "->")
            }
            ctx.out.write(arg.pName)
          }
        }
      }
    }
    ctx.out.write(")")
  }

  # Write the code to declare a tuple type.
  PROC $writeTupleDecl(TupleType tupleType, Zui.Position zuiPos, SContext ctx)
    IF !ctx.out.writing
      RETURN
    }
    Output typeOut = ctx.outs.typeOut
    Output structOut = ctx.outs.structOut
    Output declOut = ctx.outs.declOut
    Output imtOut = ctx.outs.imtInitOut

    typeOut.write("typedef struct \(tupleType.pName)__S \(tupleType.pName); /* \(tupleType.typeName(FALSE)) */\n")

    # Struct used to store info about the tuple.
    structOut.write("struct \(tupleType.pName)__S {\n")
    IF $hasNpField()
      structOut.write(linkedDecl)
    }

    bool didTo
    int toSize = 1
    string tableName = "To" .. tupleType.getTypeName(ctx)
    Output tmpOut = NEW()
    tmpOut.writing = TRUE

    FOR index IN 0 UNTIL tupleType.types.Size()
      Type type = tupleType.types[index].type
      string pName = "m" .. index
      structOut.write(" ")
      $vartype(type, TRUE, zuiPos, structOut, ctx)
      structOut.write(pName .. ";\n")

      IF type.isManaged()
        WriteIMT.writeIMTline(tupleType.pName, tableName,
                                          TRUE, toSize, pName, &didTo, imtOut)
        tmpOut.write(" {0, (Tt*)&" .. type.getTypeName(ctx) .. "__T},\n")
        ++toSize
      }
    }
    structOut.write("};\n")
    IF didTo
      imtOut.write("}\n")
    }

    # Declaration of the To struct.
    structOut.write("To " .. tableName .. "[" .. toSize .. "];\n")

    Output bodyOut = ctx.outs.origBodyOut ?: ctx.outs.bodyOut
    bodyOut.write("To " .. tableName .. "[] = {\n")
    bodyOut.write(" {" .. (toSize - 1) .. ", 0},\n")
    bodyOut.append(tmpOut)
    bodyOut.write("};\n")

    # Whether tuple<>.ToString() is used.
    bool useTupleToString = $isDeclUsed(Type.aDyn)
                              || (tupleType.toStringDecl != NIL
                                       && $isDeclUsed(tupleType.toStringDecl))
    IF useTupleToString
      # Write function for tuple.ToString().
      $writeTupleToString(tupleType, zuiPos, ctx)
    }

    string tcName = $writeStaticString(tupleType.typeName(), ctx)
    declOut.write("Tto " .. tupleType.pName .. "__T = {320, (Tc*)&"
                                                            .. tcName .. ", ")
    IF useTupleToString
      declOut.write(tupleType.pName .. "ToString")
    ELSE
      declOut.write("0")
    }
    IF $ttoHasMemberNames()
      # TODO: list of member names
      declOut.write(", 0")
    }
    IF $ttoHasMethods()
      # TODO: Size()
      declOut.write(", 0")

      # TODO: Finish()
      declOut.write(", 0")

      # TODO: Equal()
      declOut.write(", 0")

      # TODO: Compare()
      declOut.write(", 0")
    }

    declOut.write(", " .. tableName .. "};\n")

    # Function used to allocate a new tuple struct: Za{typename}(a1, a2).
    Output dout = NEW()
    dout.writing = ctx.out.writing
    SContext dctx = ctx.copy(dout)
    dout.write(tupleType.pName .. " *Za" .. tupleType.pName .. "(")
    dout.write(tupleType.pName .. " *p")
    FOR i IN 0 UNTIL tupleType.types.Size()
      dout.write(", ")
      $vartype(tupleType.types[i].type, TRUE, zuiPos, dout, ctx)
      dout.write("arg" .. i)
    }
    dout.write(")")

    ctx.outs.declOut.append(dout)
    ctx.outs.declOut.write(";\n")

    bodyOut.append(dout)
    bodyOut.write(" {\n")
    bodyOut.write(" " .. tupleType.pName .. " *r = p == NULL ? Za(sizeof(")
    bodyOut.write(tupleType.pName .. ")) : p;\n")
    FOR i IN 0 UNTIL tupleType.types.Size()
      bodyOut.write(" r->m" .. i .. " = arg" .. i .. ";\n")
    }
    bodyOut.write(" return r;\n")
    bodyOut.write("}\n")
  }

  PROC $writeTupleAlloc(TupleType type, string noAllocName,
                                Zui.MethodCall call, int &undef, SContext ctx)
    list<Zui.Expression> args = call.getArgumentList()
    IF args.Size() == 0
      # NEW() allocates without setting values.
      IF noAllocName == NIL
        ctx.out.write("Za(sizeof(" .. type.pName .. "))")
      ELSE
        $writeNoAllocClear(type.pName, NIL, NIL, noAllocName, ctx)
      }
    ELSEIF args.Size() != type.types.Size()
      ctx.error("Expected " .. (type.types.Size() + 1)
                        .. " arguments, found " .. args.Size(), call.getPos())
    ELSE
      # NEW(a1, a2) allocates and sets values.
      ctx.out.write("Za" .. type.pName .. "(")
      IF noAllocName == NIL
        ctx.out.write("NULL")
      ELSE
        ctx.out.write("&" .. noAllocName)
      }
      FOR i IN 0 UNTIL args.Size()
        ctx.out.write(", ")
        Generate.genExpr(args[i], ctx, type.types[i].type)
      }
      ctx.out.write(")")
    }
  }

  # Generate a call for tuple.ToString().
  PROC $callTupleToString(Zui.MethodCall call,
                                 Type type, Zui.Expression expr, SContext ctx)
    Output out = ctx.out
    out.write(type.getEffType().pName .. "ToString(")
    Generate.generateVarname(expr, ctx, type)
    out.write(")")
  }

  # Generate a function for tuple.ToString().
  PROC $writeTupleToString(TupleType tupleType, Zui.Position pos, SContext ctx)
    Output dout = NEW()
    dout.writing = TRUE
    dout.write("Tc *" .. tupleType.pName .. "ToString(")
    $vartype(tupleType, TRUE, pos, dout, ctx)
    dout.write("t)")
    ctx.outs.declOut.append(dout)
    ctx.outs.declOut.write(";\n")

    Output bodyOut = ctx.outs.origBodyOut ?: ctx.outs.bodyOut
    bodyOut.append(dout)
    bodyOut.write(''" {
 Tg ga;"'')
    IF !$manageMemory()
      bodyOut.write(''"
 Tc *r;"'')
    }
    bodyOut.write(''"
 if (t == NULL) return (Tc*)&ZNilString;
 ga.data = NULL;
 ga.used = 0;
 ga_append(&ga, "[");"'')
    FOR i IN 0 UNTIL tupleType.types.Size()
      IF i > 0
        bodyOut.write("\n ga_append(&ga, \", \");")
      }
      Type type = tupleType.types[i].type
      SContext newCtx = ctx.copyNewOut()
      int undef
      int t = getArgumentType(type, pos, &undef, newCtx)
      bodyOut.write("\n ZitemToString(" .. getTname(type, ctx))
      IF t < 100
        bodyOut.write(", 1, (Tz)t->m" .. i)
      ELSEIF t == 360
        # dyn is a struct, take its reference
        bodyOut.write(", 1, (Tz)(void*)&t->m" .. i)
      ELSE
        bodyOut.write(", 1, (Tz)(void*)t->m" .. i)
      }
      bodyOut.write(", &ga);")
    }

    bodyOut.write(''"
 ga_append(&ga, "]");"'')
    IF $manageMemory()
      bodyOut.write(''"
 return ZnewString(ga.data, ga.used);"'')
    ELSE
      bodyOut.write(''"
 r = ZnewString(ga.data, ga.used);
 Zfree(ga.data - ZOH_OFF);
 return r;"'')
      $setDeclUsed(%zfree)
    }
    bodyOut.write("\n}\n")

    $setDeclUsed(%garray)
    $setDeclUsed(Declaration.itemToString)
  }

  PROC $callTypeToString(Zui.Expression expr, SContext ctx)
    ctx.out.write("Ztype2string(")
    genExpr(expr, ctx, Type.aType)
    ctx.out.write(")")
  }

  PROC $callTypeName(Zui.Expression expr, SContext ctx)
    ctx.out.write("ZtypeName(")
    genExpr(expr, ctx, Type.aType)
    ctx.out.write(")")
  }

  PROC $writeNewThis(MethodType method, Declaration initMethod,
                     Declaration finishMethod, Zui.Position pos, SContext ctx)
    string thisName = ctx.scope.thisName
    ctx.out.writeIndent(1)
    ctx.out.write("if (" .. thisName .. " == NULL) {")
    IF !ctx.scope.noBacktrace && !Config.noBacktrace && !ctx.scope.primitive
      $writeSetStackPos(pos, TRUE, ctx)
      ctx.out.write("; ")
    }
    ctx.out.write(thisName .. " = ")
    IF initMethod == NIL
      string className = method.getClassName()
      $writeAlloc(className, finishMethod, ctx.out, ctx)
    ELSE
      ctx.out.write(initMethod.pName .. "(NULL)")
    }
    ctx.out.write(";}\n")
  }

  PROC $writeNewArg(bool useThis, string className, Declaration dest,
                    Declaration initMethod, Declaration finishMethod,
                    bool hasArg, SContext ctx)
    IF useThis
      # calling NEW() inside NEW(): pass the already constructed object
      ctx.out.write(ctx.scope.thisName)
    ELSEIF className != NIL
      $writeNoAllocClear(className, initMethod, finishMethod, dest, ctx)
    ELSE
      # calling NEW() elsewhere: pass null so that a new object is
      # constructed.
      ctx.out.write("NULL")
    }
    IF hasArg
      ctx.out.write(", ")
    }
  }

  # Return TRUE when stack frames are used.  Also true when @backtrace=no is
  # used but the stack frame is needed for garbage collection.
  FUNC $doStackFrame(SContext ctx) bool
    RETURN ($manageMemory()
              || (!ctx.scope.noBacktrace
                  && !Config.noBacktrace
                  && ctx.scope.wantBacktrace))
          && !ctx.scope.primitive
  }

  # Return TRUE when |method| has local variables that might be allocated or
  # a DEFER statement.
  FUNC $useFrameOffsets(MethodType method, SContext ctx) bool
    RETURN $doStackFrame(ctx) && $hasNpField()
          && (method.scope?.refVars != NIL || method.scope?.hasDefer)
  }

  # Return the code to write at the end of a function to undo ZsD().
  # Excludes the indent, includes the line break;
  FUNC $stackBack() string
    IF $isDeclUsed(%pthread)
      RETURN "e->topFrame = sf.prev;\n"
    }
    RETURN "topFrame = sf.prev;\n"
  }

  # Write the code that goes before writing " return r;" in a normal function.
  PROC $writeBeforeReturn(Zui.Position pos, SContext ctx)
    # If an object located on the stack has a Finish() method, call it.
    $writeScopeEndFinish(pos, ctx)

    IF ctx.scope.methodScope?.hasDefer
      ctx.out.write(" ZdeferCall(&deferList);\n")
    }

    IF $doStackFrame(ctx)
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write($stackBack())
    }
  }

  # For variables declared in the current scope, which are allocated on the
  # stack, call their Finish() method.
  PROC $writeScopeEndFinish(Zui.Position pos, SContext ctx)
    IF !$isDeclUsed(Declaration.hasFinish)
      RETURN
    }

    bool didOne
    FOR declList IN ctx.scope.declDict?.values()
      FOR decl IN declList
        Declaration finish
        bool childHasFinish
        bool isIobj
        IF decl.type != NIL && decl.type.isNoAlloc()
          ClassType class = decl.type.getClassType(ctx)
          IF class != NIL
            isIobj = decl.type.getTtype() == Type.Enum.iobject
            finish = Generate.getFinishMethod(class.scope, ctx)
            IF finish == NIL && isIobj && class.hasFinishMethod(ctx)
              # Some child class has Finish().
              childHasFinish = TRUE
            }
          }
        }
        IF finish != NIL || childHasFinish
          IF !didOne
            didOne = TRUE
            $setStackPos(pos, TRUE, ctx)
          }
          IF isIobj
            $setDeclUsed(%finishIobj)
            ctx.out.writeIndent(ctx.scope.depth)
            ctx.out.write("ZFinishIobj(&" .. decl.pName .. ", 2);\n")
          ELSE
            ctx.out.writeIndent(ctx.scope.depth)
            ctx.out.write("if (" .. decl.pName .. ".np" .. " != NULL) {")
            ctx.out.write(finish.pName .. "(&" .. decl.pName .. ", 2); "
                                            .. decl.pName .. ".np = NULL;}\n")
          }
        }
      }
    }
  }

  PROC $writeNewReturn(Zui.Position pos, SContext ctx)
    $writeBeforeReturn(pos, ctx)
    ctx.out.write(" return " .. cThisName .. ";\n")
  }

  # Write the name of this symbol, surrounding it with what is required to
  # access it.
  # When |read| is TRUE the symbol is read from, not assigned to or called.
  PROC $writeSymName(Declaration decl, Type type, bool read, SContext ctx)
    IF ctx.out.writing
      IF decl == NIL
        THROW "decl is NIL: " .. type.typeToString()
      ELSEIF decl.pName == NIL
        THROW "decl.pName is NIL: " .. type.typeToString()
      ELSEIF type.ttype == Type.Enum.byRef
        ctx.out.write("(*" .. decl.pName .. ")")
      ELSEIF type.isAllocType(ctx)
        ctx.out.write(decl.pName .. "->Vm")
      ELSEIF decl.getClass() != NIL && !type.isMethodType()
        ctx.out.write(ctx.scope.thisName)
        IF decl.type.isNoAlloc()
          ctx.out.write(".")
        ELSE
          ctx.out.write("->")
        }
        ctx.out.write(decl.pName)
      ELSEIF (type.ttype == Type.Enum.proc || type.ttype == Type.Enum.func)
        $namelessFuncUse(decl, ctx)
      ELSE
        bool close
        IF ($generatingArg || read) && decl.isUsedInTry
          # Remove the "volatile" attribute.
          ctx.out.write("((")
          $vartype(decl.type, FALSE, decl.zuiPos, ctx)
          ctx.out.write(")")
          close = TRUE
        }
        $writeVarName(decl, ctx)
        IF close
          ctx.out.write(")")
        }
      }
    }
  }

  PROC $writeVarName(Declaration decl, SContext ctx)
    IF decl.type.isNoAlloc() && !$isIobject(decl.type)
      ctx.out.write("(&" .. decl.pName .. ")")
    ELSE
      ctx.out.write(decl.pName)
    }
  }

  PROC $namelessFuncUse(Declaration decl, SContext ctx)
    IF ctx.out.writing
      ctx.out.write("(&" .. directRefName(decl.pName) .. ")")
      useDirectRef(decl)
    }
  }

  PROC $namelessFuncReference(Declaration decl, SContext ctx)
    useDirectRef(decl)
  }

  PROC $writeReturnType(MethodType method, Zui.Position pos, SContext ctx)
    IF method.returnType == NIL
      ctx.out.write("void")
    ELSE
      $vartype(method.returnType, FALSE, pos, ctx)
    }
  }

  PROC $refCast(Type type, Zui.Position pos, SContext ctx)
    $refCast(type, FALSE, FALSE, pos, ctx)
  }

  # Generate the type cast for a proc_ref or func_ref.
  PROC $refCast(Type type, bool callback, bool withObject,
                                               Zui.Position pos, SContext ctx)
    Output out = ctx.out
    MethodType method = type.getMethod()
    # ((returnType (*)(arg1Type, arg2Type))Vobj->Vmember)(arg1, arg2)
    out.write("((")
    $writeReturnType(method, pos, ctx)
    out.write(" (*)(")

    string comma = ""
    IF callback
      out.write(comma .. "Tcb *")
      comma = ", "
    }
    bool didObject
    IF (type.ttype == Type.Enum.procRef || type.ttype == Type.Enum.funcRef)
      Type ct = method.classType
      IF ct != NIL
        # THIS for an object method
        out.write(comma)
        IF withObject
          # avoid "Tr"
          out.write("void *")
        ELSE
          $vartype(ct, FALSE, pos, ctx)
        }
        comma = ", "
        didObject = TRUE
      }
    ELSEIF type.getClassName() != NIL
      # THIS for an object method
      out.write(comma .. type.getClassName() .. " *")
      comma = ", "
      didObject = TRUE
    }
    IF withObject && !didObject
      out.write(comma .. "void *")
      comma = ", "
    }

    IF method.arguments != NIL
      FOR arg IN method.arguments
        out.write(comma)
        $vartype(arg.type, FALSE, pos, ctx)
        comma = ", "
      }
    }
    out.write("))")
  }

  PROC $refCast(SContext ctx)
    ctx.out.write("(void*)")
  }

  # Generate an object initializer.
  PROC $objectInit(Zui.Expression initExpr, Declaration dest, SContext ctx)
    Type destType = dest?.type
    ClassType classType = destType?.getClassType(ctx)
    IF classType == NIL
      IF ctx.doError()
        ctx.error("Destination must be an object", initExpr.getPos())
      }
    ELSE
      bool useTempVar
      string separator = ", "
      string tmpvar = genTempUseStart(initExpr,
                      $vartypeString(destType, TRUE, initExpr.getPos(), ctx),
                      &useTempVar, &separator, ctx)
      Generate.generateEmptyNewCall(initExpr.getPos(), destType, ctx)

      SymUse symUse = NEW(initExpr.getPos(), ctx)
      ctx.addUsedItem(destType)
      FOR init IN initExpr.getInitItemList()
        string name = init.getName()
        Zui.Expression expr = init.getValue()
        Declaration decl = classType.findObjectMember(name, symUse,
                                                           searchParent, TRUE)
        IF decl == NIL
          IF ctx.doError()
            ctx.error("Member not found in class: " .. name, expr.getPos())
          }
        ELSE
          ctx.out.write(separator .. tmpvar .. "->" .. decl.pName .. " = ")
          Generate.genExprDoConv(expr, ctx, decl.type)
          ZuiExpressionExt.get(initExpr).undefined +=
                                          ZuiExpressionExt.get(expr).undefined
          ctx.addUsedItem(decl)
        }
      }
      IF useTempVar
        ctx.out.write(", " .. tmpvar .. ")")
      }
    }
  }


  # Write the stack frame offset table.
  PROC $methodLeader(MethodType method, Output out, SContext ctx)
    IF $useFrameOffsets(method, ctx)
      dict<string, Declaration> refVars = method.scope.refVars
      out.write("Zfo " .. method.pName)
      out.write("fo[" .. ((refVars == NIL ? 0 : refVars.Size())
                                      + (method.scope?.hasDefer ? 1 : 0) + 1))
      out.write("] = {")

      int i
      FOR pName IN refVars?.keys()
        out.write("{0,(Tt*)&" .. refVars[pName].type.getTypeName(ctx)
                                                                   .. "__T},")
      }
      IF method.scope?.hasDefer
        out.write("{0,(Tt*)&defer__T},")
      }
      out.write("{0,0}};\n")
    }
  }

  FUNC $methodReturnType(Zui.Declaration decl, bool isNew, bool isInit,
                                                          SContext ctx) Type
    Type retType
    Zui.TypeEnum type = decl.getType().getType()
    IF isNew || isInit
      retType = ctx.scope.classType
      ctx.out.write(retType.getClassName() .. " *")
    ELSEIF type == Zui.TypeEnum.eFUNC
      Zui.MethodType method = decl.getType().getMethodDecl()
      list<Declaration> types
      IF method.sizeReturnType() > 1
        types = NEW()
      }

      FOR t IN method.getReturnTypeList()
        Zui.Expression expr = t.getName()
        IF expr.getType() == Zui.ExprType.eTHIS
          # Returning THIS, the object itself.
          retType = ctx.scope.classType
        ELSE
          retType = Generate.generateDeclType(expr,
                      ctx.copyNoOut(TRUE), isDecl + dotI + markUsed,
                      NEW(expr.getPos(), ctx))
        }
        IF types != NIL && retType != NIL
          types.add(retType.getValueType(ctx))
        }
      }
      IF method.sizeReturnType() > 1
        MultipleType mt = NEW(types, "ret")
        mt.getTypeName(ctx)  # make sure it has a pName
        retType = mt
      }
      IF retType != NIL
        $vartype(retType, TRUE, method.getReturnType(0).getName().getPos(), ctx)
      }
    ELSE
      ctx.out.write("void ")
    }
    RETURN retType
  }

  PROC $methodStart(Declaration decl, bool hasArguments, SContext ctx)
    ctx.out.write(decl.pName .. "(")
    IF ctx.scope.isClassScope() && decl.getClassName() != NIL
      ctx.out.write(decl.getClassName() .. " *" .. ctx.scope.thisName)
      IF hasArguments
        ctx.out.write(", ")
      }
    }

    # If this is an Init() or EarlyInit() method we need a variable to hold
    # the result.
    IF decl.name == "Init" || decl.name == "EarlyInit"
                                                  && !ctx.scope.isClassScope()
      string pName = decl.pName
      string readyName
      IF decl.name[0] == 'E'
        pName ..= "__e"
        readyName = "EarlyReady"
      ELSE
        pName ..= "__r"
        readyName = "Ready"
      }
      IF decl.scopeName != NIL
        readyName = decl.scopeName .. "." .. readyName
      ELSE
        readyName = ctx.scope.name .. "." .. readyName
      }
      ctx.outs.declOut.write("int " .. pName .. " = 0; /* "
                                                      .. readyName .. " */\n")
    }
  }

  PROC $methodBodyStart(MethodType method, bool isNew, bool isInit,
                                               Zui.Position pos, SContext ctx)
    IF $doStackFrame(ctx)
      ctx.out.write($stackDeeper(" "))
    }

    Type retType = method.returnType
    IF retType != NIL && !isNew && !isInit
      # Need a var for the return value.  When it's reference counted need to
      # init to zero.
      IF retType.getTtype() == Type.Enum.multiple
        # make sure it has been given a name
        retType.getTypeName(ctx)
      }
      ctx.out.writeIndent(1)
      $vartype(retType, TRUE, pos, ctx)
      IF $isIobject(retType) || retType.getTtype() == Type.Enum.dyn
        ctx.out.write("r = {NULL};\n")
      ELSEIF retType.getTtype() == Type.Enum.multiple
        ctx.out.write("r;\n")
      ELSE
        ctx.out.write("r = 0;\n")
      }
    }

    IF method.scope?.hasDefer
      # The init is either for the "np" field or for "itemType".
      ctx.out.write(" Tl deferList = {NULL};\n")
    }

    # Declare pointer variables.
    IF method.scope?.refVars != NIL
      dict<string, Declaration> refVars = method.scope.refVars
      FOR decl IN refVars
        IF !decl.isArg
          $writeDeclaration(decl, method.scope, FALSE, TRUE, FALSE,
                                                                 ctx.out, ctx)
        }
      }

    }

    bool useStackFrameTable = $useFrameOffsets(method, ctx)
    IF useStackFrameTable
      # Declare the flag indicating whether the table has been initialized.
      ctx.out.write(" static int sfF = 0;\n")
    }

    # Declare remaining temp variables.
    IF method.scope?.tempVars != NIL
      FOR decl IN method.scope.tempVars
        IF !decl.inMethodScope
          $writeDeclaration(decl, method.scope, FALSE, TRUE, FALSE, ctx.out, ctx)
        }
      }
    }

    IF isInit
      string className = method.getClassName()
      ctx.out.writeIndent(1)
      ctx.out.write("if (")
      ctx.out.write(ctx.scope.thisName)
      ctx.out.write(" == NULL) ")
      ctx.out.write(ctx.scope.thisName)
      ctx.out.write(" = ")
      $writeAlloc(className, NIL, ctx.out, ctx)
      ctx.out.write(";\n")
    }
    IF ctx.scope.needRetFlag
      IF ctx.scope.retFlagInTry
        ctx.out.write(" volatile")
      }
      ctx.out.write(" int rt = 0;\n")
    }

    IF $doStackFrame(ctx)
      IF $hasNpField()
        IF useStackFrameTable
          ctx.out.write(" if (!sfF) {\n")
          ctx.out.write("  sfF = 1;\n")
          int i
          FOR pName IN method.scope.refVars?.keys()
            ctx.out.write("  ")
            ctx.out.write(method.pName)
            ctx.out.write("fo[" .. i .. "].off = ")
            string close = ";\n"
            IF method.scope.refVars[pName].type.isNoAlloc()
#                             || $isIobject(method.scope.refVars[pName].type)
              # Variables on the stack have one added to the offset, so that
              # the GC knows this is not a pointer but the object itself.
              # This is used in ZgcMarkItems().
              ctx.out.write("1 + (int)(")
              close = ");\n"
            }
            ctx.out.write("(void*)&sf - (void*)&")
            ctx.out.write(pName)
            ctx.out.write(close)
            ++i
          }
          IF method.scope?.hasDefer
            ctx.out.write("  ")
            ctx.out.write(method.pName)
            ctx.out.write("fo[" .. i
                     .. "].off = 1 + (int)((void*)&sf - (void*)&deferList);\n")
          }
          ctx.out.write(" }\n")

          ctx.out.write(" sf.frof = ")
          ctx.out.write(method.pName)
          ctx.out.write("fo;\n")
        ELSE
          ctx.out.write(" sf.frof = NULL;\n")
        }
      }

      ctx.out.write($initStackFrame(" ", TRUE, ctx))
    }

    string thisName

    IF ctx.scope.isClassScope() && ctx.scope.thisName != NIL
                                                          && !isNew && !isInit
      thisName = ctx.scope.thisName
    ELSEIF ctx.scope.insideBuiltin()
            && method.arguments.Size() > 0
            && method.arguments[0].name == "this"
               # not when "this" is a valuetype
            && ["INT", "INT8", "INT16", "INT32", "NAT", "BOOL", "STATUS", "DYN"]
                  .find(ctx.scope.outer.name) < 0
      thisName = "Athis"
    }
    IF thisName != NIL
      # Throw an exception when THIS is NIL
      # Except for Size() in a library module.
      # Not when the first statement is IFNIL.
      IF ctx.scope.statements.Size() == 0
              || ctx.scope.statements[0].getType() != Zui.StatementType.eIFNIL
        ctx.out.write(" if (")
        ctx.out.write(thisName)
        ctx.out.write(" == NULL) {\n ")
        $beforeStatement(pos, TRUE, ctx)
        ctx.out.write("  ZthrowThisNil();\n")
        ctx.out.write(" }\n")
      }
    }
  }

  PROC $writeMethodCall(Declaration funcDecl, bool moreArgs, SContext ctx)
    ctx.out.write(funcDecl.pName .. "(")
    IF funcDecl.getClass() != NIL
      ctx.out.write(ctx.scope.thisName)
      IF moreArgs
        ctx.out.write(", ")
      }
    }
  }

  # object.Type()
  PROC $callObjectType(Zui.MethodCall call, ClassType class, Type object,
                                            Zui.Expression expr, SContext ctx)
    IF object.getEffType().ttype == Type.Enum.object
      ctx.out.write("(Tt*)(&")
      ctx.out.write(class.pName)
      ctx.out.write("__T)")
    ELSE
      ctx.out.write("(Tt*)(")
      Generate.generateVarname(expr, ctx, object)
      ctx.out.write(".table[0])")
    }
  }

  # object.ToString()
  PROC $callObjectToString(Zui.MethodCall call, ClassType class, Type object,
                                            Zui.Expression expr, SContext ctx)
    IF object.getEffType().ttype == Type.Enum.object
      ctx.out.write("ZobjectToStringval(&")
      ctx.out.write(class.pName)
      ctx.out.write("__T, ")
    ELSE
      # For an iobject the type will be figured out at runtime.
      ctx.out.write("ZiobjectToStringval(")
    }
    Generate.generateVarname(expr, ctx, object)
    ctx.out.write(")")
  }

  # Add a DEFER'ed function to the defer list
  PROC $addDefer(Zui.MethodCall call, Generate.CallbackInfo cbInfo,
                                                                 SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("ZdeferAdd(&deferList, (Tcb*)")
    int undef
    $writeCallbackAlloc(cbInfo.callback, NIL, cbInfo, call, &undef, ctx)
    ctx.out.write(");\n")
  }

  # Call to a function reference.
  FUNC $functionRefCall(Zui.MethodCall call, Declaration decl,
                                  string funcName, Type destType, SContext ctx
                       ) Type
    Type refType = decl.type
    MethodType type = refType.getMethod()
    $refCast(refType, TRUE, FALSE, call.getPos(), ctx)
    # When funcName is NIL call the method directly:  { => "foo" }()
    Type useType = funcName == NIL ? type : refType
    $writeSymName(decl, useType, FALSE, ctx)
    ctx.out.write("->cfunc")
    ctx.out.write(")((Tcb*)")
    $writeSymName(decl, useType, FALSE, ctx)
    IF call.sizeArgument() > 0
      ctx.out.write(", ")
    }
    Generate.generateArgumentsCheck(call, funcName, ctx, type, destType)
    ctx.out.write(")")
    RETURN type.returnType
  }

  # Call to a method reference.
  FUNC $methodRefCall(Zui.MethodCall call,
                  Type mtype,
                  Type object,
                  Zui.Expression objExpr,
                  string pName,
                  Type destType,
                  SContext ctx) Type
    # Need to generate a type cast, since the variable is declared as
    # "void *".
    $refCast(mtype, TRUE, FALSE, objExpr.getPos(), ctx)
    Output varnameOut = NEW()
    varnameOut.writing = ctx.out.writing
    SContext varnameCtx = ctx.copy(varnameOut)
    Declaration decl = Generate.generateVarname(objExpr, varnameCtx, object)
    Type type = decl == NIL ? NIL : decl.type
    # TODO: if the name has side effects need to use a temp var.
    $member(varnameOut, objExpr.getPos(), type, NIL, FALSE, pName, ctx)
    ctx.out.write("->cfunc")
    ctx.out.write(")(")
    $member(varnameOut, objExpr.getPos(), type, NIL, FALSE, pName, ctx)
    IF call.sizeArgument() > 0
      ctx.out.write(", ")
    }

    MethodType mt = mtype.getMethod()
    string methodName = call.getName().getRight().getId().getName()
    Generate.generateArgumentsCheck(call, methodName, ctx, mt, destType)
    ctx.out.write(")")

    IF mt != NIL && mt.returnType != NIL
      RETURN mt.returnType
    }
    RETURN NIL
  }

  FUNC $objectCall(Zui.MethodCall call,
                   bool i_object_arg,
                   list<Declaration.C> arglist,
                   Declaration mdecl,
                   Type object,
                   Zui.Expression objExpr,
                   string pName,
                   Type destType,
                   SContext ctx) Type
    MethodType methodType
    bool isCallback
    IF mdecl.type ISA CallbackType
      # The method is actually a callback:
      #     {object}->callback({object}->callback, {object}, args)
      # A bit like functionRefCall()
      methodType = mdecl.type.<CallbackType>.methodType
      isCallback = TRUE
    ELSE
      # Normal method: method({object}, args)
      methodType = mdecl.type
    }
    Zui.Expression nameExpr = call.getName()   # object.method()
    string methodName = nameExpr.getRight().getId().getName()  # method
    Type retType = methodType.returnType
    string close = ")"

    # Default is to use the argument type list of the method.
    # But when generating a virtual function we use the types of the arguments
    # passed in.
    list<Declaration.C> useArglist = methodType.getArgList()

    IF !(ctx.scope.isClassScope() && ctx.scope.classType.isAbstract())
      # For C we need to call the right function and pass "THIS".
      # But we don't write anything for an abtract class.
      ClassType class = object.getClassType(ctx)

      bool dotnil = nameExpr.hasDotnil() && nameExpr.getDotnil()
      string objVarName
      string objectExpr
      IF !$exprIsaName(objExpr, ctx) && ctx.out.writing
          && (dotnil || isCallback
                      || (object.ttype == Type.Enum.iobject && !i_object_arg))
        # Need to store "{object}" in a variable, so that it is evaluated only
        # once.
        # Declare a variable to hold the pointer to the object.
        objVarName = getUid(ctx.scope.scopeName)
        ctx.outs.varOut.writeIndent(ctx.scope.depth)
        IF object.ttype == Type.Enum.iobject
          ctx.outs.varOut.write("Tr " .. objVarName .. " = {NULL};\n")
        ELSE
          ctx.outs.varOut.write("void *" .. objVarName .. " = NULL;\n")
        }
        close = "))"

        ctx.out.write("(")
        ctx.out.write(objVarName)
        ctx.out.write(" = ")
        Generate.genExprParent(objExpr, ctx, object)
        ctx.out.write(", ")
        objectExpr = objVarName
      ELSE
        # Evaluate the expression once and store the resulting string in
        # objectExpr.
        Output varnameOut = NEW()
        varnameOut.writing = ctx.out.writing
        $generatingArg = TRUE
        Generate.genExprParent(objExpr, ctx.copy(varnameOut), object)
        $generatingArg = FALSE
        objectExpr = varnameOut.ToString()
      }
      IF dotnil
        # with "{object}" just being an ID:
        #    (id == NULL ? 0 : call(id, ...))
        # otherwise:
        #    (objVarName = {object}, objVarName == NULL
        #                                         ? 0 : call(objVarName, ...))
        IF objVarName == NIL
          ctx.out.write("(")
          ctx.out.write(objectExpr)
          close = "))"
        ELSE
          ctx.out.write(objVarName)
        }
        IF object.getTtype() == Type.Enum.iobject
          ctx.out.write(".ptr")
        }
        ctx.out.write(" == NULL ? ")
        $writeNilValue(retType, ctx.out)
        ctx.out.write(" : ")
      }

      IF object.ttype == Type.Enum.object && !i_object_arg
        # object.method(arg) -> method_name(object, arg)
        IF isCallback
          # object.method(arg) -> object.callback(object.callback, object, arg)
          $refCast(methodType, TRUE, FALSE, objExpr.getPos(), ctx)
          ctx.out.write(objectExpr)
          ctx.out.write("->")
          ctx.out.write(mdecl.pName)
          ctx.out.write("->cfunc)")
        ELSE
          ctx.out.write(pName)
        }
        ctx.out.write("(")
        IF isCallback
          ctx.out.write("(Tcb*)")
          ctx.out.write(objectExpr)
          ctx.out.write("->")
          ctx.out.write(mdecl.pName)
          ctx.out.write(", ")
        }
        ctx.out.write(objectExpr)
      ELSEIF object.ttype == Type.Enum.iobject && !i_object_arg
        # object.method(arg)
        #      -> (p3 = object, ((ret (*)(args))(p3->table[method_idx]))
        #                                                    (p3->ptr, arg))
        # Assignment to p3 is needed to avoid evaluating the expression twice.
        # Except when the expression is just an ID:
        #      -> ((ret (*)(args))(Vi->table[method_idx]))(Vi->ptr, arg)
        #
        # TODO: doesn't work for PARENT.method()
        ctx.out.write("(")
        IF methodType.hasIfnil()
          # If the method has IFNIL and expr is NULL, then we use the actual
          # method name, since we can't use expr->table[2].  Do the function
          # typecast as for when using ->table, the argument types are
          # different.
          ctx.out.write(objectExpr)
          ctx.out.write(".ptr")
          ctx.out.write(" == NULL ? ")
          ctx.out.write("(")
          Generate.generateMethodReturnType(methodType, ctx)
          ctx.out.write(" (*)(")
          Generate.generateMethodArgTypes(methodType, ctx)
          ctx.out.write("))(")
          ctx.out.write(methodType.pName)
          ctx.out.write(")")
          ctx.out.write(" : ")
        }
        ctx.out.write("(")
        Generate.generateMethodReturnType(methodType, ctx)
        ctx.out.write(" (*)(")
        Generate.generateMethodArgTypes(methodType, ctx)
        ctx.out.write("))(")
        ctx.out.write(objectExpr)
        ctx.out.write(".table[")
        ctx.out.write(WriteIMT.classMemberTableIndex(class.<ClassType>,
                                                  mdecl, ctx.doError()) .. "")
        ctx.out.write("]))(")
        ctx.out.write(objectExpr)
        ctx.out.write(".ptr")
      ELSE
        # One of the arguments is of i_object type.
        # object.method(arg) -> method_func(object, arg)
        # Define a function that does the work:
        # RetType method_func(objectType *object, argType arg) {
        #   int idx = object->type * NTYPES + arg->type;
        #   if (some_table[idx])  /* arg used as i_object */
        #     return func_table[idx](object, arg)
        #   return func_table[idx](object, arg->ptr)
        # }
        # TODO: doesn't work for PARENT.method()
        string funcName = class.pName
        IF object.ttype == Type.Enum.iobject
          funcName ..= "_I"
        }

        # Make a function name that includes all the argument types to
        # make it unique.
        string objectArgName = ""
        IF arglist != NIL
          VAR pArglist = methodType.arguments
          FOR i IN 0 UNTIL arglist.Size()
            Declaration.C d = arglist[i]
            IF d != NIL
              IF d.type.ttype == Type.Enum.unknown
                  || d.type.ttype == Type.Enum.nilval
                  || (d.type ISA ContainerType
                                    && d.type.<ContainerType>.itemType == NIL)
                  || d.type.isValueType()
                # The argument is NEW(), NIL or [], use the argument type
                # of the found method.
                # For value types also use the argument type of the found
                # method.  E.g., for a "9" (natval) may use an "int" type.
                d = pArglist[i]
                arglist[i] = d
              }
              IF d.type.ttype == Type.Enum.iobject
                objectArgName ..= "__"
                               .. d.type.getClassType(ctx).pName .. "_I"
              ELSEIF d.type.ttype == Type.Enum.object
                                     || d.type.ttype == Type.Enum.class
                objectArgName ..= "__" .. d.type.getClassType(ctx).pName
              ELSE
                objectArgName ..= "__" .. d.type.ttype.ToString()
              }
            }
          }
        }

        funcName ..= "__M" .. methodName .. "_I" .. objectArgName
        int udef
        Declaration.C fd = $generateVirtualFunc(funcName, object,
                     nameExpr.getRight().getId().getName(), nameExpr.getPos(),
                                                          &udef, arglist, ctx)
        IF fd != NIL
          retType = fd.type
          funcName = fd.name  # use short name
        ELSE
          retType = NIL
        }
        ctx.out.write(funcName .. "(")
        ctx.out.write(objectExpr)

        # Must generate the arguments for the virtual function, same types as
        # the arguments that are passed in (thus no iobject -> object
        # conversion).
        useArglist = arglist
      }
      IF call.hasArgument()
        ctx.out.write(", ")
      }

      # Generate the arguments.
      Generate.generateArgumentsCheck(call, methodName, ctx, useArglist,
                                                         methodType, destType)
      ctx.out.write(close)
    }
    RETURN retType
  }

  # Return TRUE when |expr| evaluates to a variable name.
  # E.g. "x" or "IO.stderr".
  FUNC $exprIsaName(Zui.Expression expr, SContext ctx) bool
    IF expr.getType() == Zui.ExprType.eID
      RETURN TRUE
    }
    IF expr.getType() != Zui.ExprType.eMEMBER
      RETURN FALSE
    }
    Type type = Generate.genExpr(expr.getLeft(), ctx.copyNoOut())
    IF type == NIL || !(type.ttype == Type.Enum.module
                     || type.ttype == Type.Enum.builtinModule
                     || type.ttype == Type.Enum.class)
      RETURN FALSE
    }
    SymUse symUse = NEW(expr.getPos(), ctx)
    Declaration decl = type.findMember(expr.getRight().getId().getName(),
                                                                       symUse)
    RETURN decl != NIL && (type.ttype != Type.Enum.class || !decl.inShared())
  }

  PROC $usingIobjectMethod(Declaration mdecl,
                   list<Declaration.C> arglist,
                   Type objectType,
                   int &udef,
                   string methodName,
                   Zui.Position pos,
                   string baseFuncName,
                   SContext ctx)
  }

  # Remember which functions have been generated, don't do one twice.
  # Key is a concatenation of class, argument, etc.
  dict<string, Declaration.C> $virtualFuncMap

  # Write declaration output here, it's appended to declOut later.
  Output $virtualDeclOut

  # Write function body here, it's appended to bodyOut later.
  Output $virtualBodyOut

  # Generate a function that takes an object or i_object and a list of
  # arguments and figures out the method to be invoked.
  # |nameExpr| is the method name.
  # Returns a symbol with the return type, NIL for a PROC.
  # Keep in sync with Resolve.generateVirtualFunc()!!!
  FUNC $generateVirtualFunc(string funcKey,
                            Type varType,
                            string methodName,
                            Zui.Position pos,
                            int &undef,
                            list<Declaration.C> callArglist,
                            SContext ctx
                           ) Declaration
    IF $virtualFuncMap.has(funcKey)
      RETURN $virtualFuncMap.get(funcKey)
    }
    Type retType

    # When writing use a short name instead of the function key name.
    string funcName = funcKey
    IF ctx.out.writing
      funcName = getUid(funcKey)
    }
    Declaration.C funcDecl = NEW(funcName)

    # Make a list with list of possible symbols for THIS and each argument.
    # altList[0] for A0 THIS
    # altList[1] for A1 arg 1
    # altList[1] for A2 arg 2
    # etc.
    list<list<Declaration>> altList = Resolve.getDeclAltList(
                            varType, methodName, pos, undef, callArglist, ctx)
    IF altList == NIL
      RETURN NIL
    }

    list<int> indexes = NEW()
    FOR l IN altList
      indexes.add(0)
    }

    # Find out for what arguments with more than one possible type, the type
    # makes us pick another method.  If the type doesn't matter, just use the
    # first one.  This avoids adding a switch where all alternatives are
    # equal.
    FOR tryIdx IN 0 UNTIL altList.Size()
      IF altList[tryIdx].Size() > 1
        # For every possible combination of types for arguments other than
        # tryIdx see if the picked method changes if we use a different type
        # for tryIdx.
        bool pickedAnother = FALSE
        indexes.map({ i => 0 })
        WHILE !pickedAnother
          # Gather the arguments for this combination.
          indexes[tryIdx] = 0
          list<Declaration.C> argtry = NEW()
          FOR idx IN 1 UNTIL altList.Size()
            Declaration.C decl = NEW("")
            decl.type = altList[idx][indexes[idx]].type
            argtry.add(decl)
          }

          # Try every type of altList[tryIdx], see if the picked method
          # changes
          Type pickedMethod
          FOR tryIdxVal IN 0 UNTIL altList[tryIdx].Size()
            indexes[tryIdx] = tryIdxVal
            IF tryIdx > 0 && tryIdxVal > 0
              # Change the argument at tryIdx to tryIdxVal
              argtry[tryIdx - 1].type = altList[tryIdx][tryIdxVal].type
            }
            Declaration object = altList[0][indexes[0]]
            Declaration mdecl
            mdecl = Generate.findMethodArglist(object.type, methodName,
                                  TRUE, argtry, NIL, ctx, TRUE,
                                  searchParent + allowInvisible,
                                  ctx.doError(),
                                  pos, "", undef)
            IF mdecl == NIL
              # can't find method, error given elsewhere
              pickedAnother = TRUE
              BREAK
            }
            IF pickedMethod == NIL
              pickedMethod = mdecl.type
            ELSEIF mdecl.type ISNOT pickedMethod
              pickedAnother = TRUE
              BREAK
            }
          }
          IF pickedAnother
            BREAK
          }

          # Next combination of arguments other than tryIdx.
          bool didinc
          FOR i IN 0 UNTIL indexes.Size()
            IF i != tryIdx && altList[i].Size() > 1
              IF indexes[i] + 1 < altList[i].Size()
                ++indexes[i]
                didinc = TRUE
                BREAK
              }
              indexes[i] = 0
            }
          }
          IF !didinc
            BREAK
          }
        }

        IF !pickedAnother
          # type of this argument doesn't matter, set its size to one.
          altList[tryIdx].remove(1, -1)
        }
      }
    }

    # If there is only one matching function we can skip all the conditions
    # and just write that one.
    # TODO: can skip a lot of stuff now that we figure out haveTwoMethods
    # early.
    bool haveTwoMethods
    FOR l IN altList
      IF l.Size() > 1
        haveTwoMethods = TRUE
        BREAK
      }
    }

    Output tmpOut = NEW(NEW())
    tmpOut.writing = ctx.out.writing

    # For every permutation find a matching function.
    # E.g. A0 is an i_object with 2 possible classes, A2 is an i_object with
    # three possible classes
    #        switch (A0->type) {
    #          case 0:
    #                  switch (A2->type) {
    #                    case 0:
    #                             return func_obj0_obj0(A0->ptr, A1, A2->ptr);
    #                    case 1:
    #                             return func_obj0_itf(A0->ptr, A1, A2);
    #                    case 2:
    #                             return func_obj0_itf(A0->ptr, A1, A2);
    #                  }
    #          case 1:
    #                  switch (A2->type) {
    #                    case 0:
    #                             return func_obj1_obj0(A0->ptr, A1, A2->ptr);
    #                    case 1:
    #                             return func_obj1_obj1(A0->ptr, A1, A2->ptr);
    #                    case 2:
    #                             return func_obj1_obj2(A0->ptr, A1, A2->ptr);
    #                  }
    #        }
    #
    # Every possible class must have a matching method, either with that class
    # or with an interface.

    indexes.map({ i => 0 })

    string lastCall
    set<int> argNotNull = NEW()  # argument indices that can't be NIL
    Type foundRetType
    int maxTmpIdx

    # depth indicates what to do when a matching func is found:
    # 0: write "switch" for A0
    # 1: write "case" for A0
    # 2: write "switch" for A1
    # 3: write "case" for A1
    # etc.
    int depth

    WHILE TRUE
      list<Declaration.C> argtry = NEW()
      FOR idx IN 1 UNTIL altList.Size()
        Declaration.C decl = NEW("")
        decl.type = altList[idx][indexes[idx]].type
        argtry.add(decl)
      }

      Declaration object = altList[0][indexes[0]]
      Declaration mdecl
      mdecl = Generate.findMethodArglist(object.type, methodName, TRUE,
                      argtry, NIL,
                      ctx, TRUE, searchParent + allowInvisible,
                      ctx.doError(), pos, "", undef)
      Type mtype = mdecl?.type
      IF mtype == NIL
        IF ctx.out.writing
          ctx.error("Missing implementation for " .. methodName
                                      .. " in " .. object.getName(TRUE), pos)
        }
      ELSE
        IF mtype.ttype == Type.Enum.func && mtype.<MethodType>.returnType != NIL
          # TODO: check the return types of all methods are equal.
          retType = mtype.<MethodType>.returnType
          IF foundRetType != NIL
                            && !Type.matchingTypes(foundRetType, retType, ctx)
            IF ctx.doError()
              Generate.typeError(foundRetType, retType, pos, ctx)
            }
          }
          foundRetType = retType
        }

        WHILE depth < 2 * altList.Size()
          int idx = depth / 2
          IF altList[idx].Size() > 1
            IF (depth & 1) == 0
              argNotNull.set(idx)
              tmpOut.write(" switch (A" .. idx .. ".type) {\n")
            ELSE
              tmpOut.write("  case " .. indexes[idx] .. ":\n")
            }
          }
          depth++
        }

        # Generate the function call only if it was marked as used.
        IF $isDeclUsed(mdecl)
          IO.StringWriter sw = NEW()
          sw.write("   ")
          IF mtype.ttype == Type.Enum.func
            sw.write("return ")
          }
          sw.write(mdecl.pName .. "(A0")
          IF varType.ttype == Type.Enum.iobject
            argNotNull.set(0)
            sw.write(".ptr")
          }
          int tmpIdx
          list<Declaration.C> methodArgList = mtype.getArgList()
          FOR ai IN 0 UNTIL argtry.Size()
            IF callArglist[ai].type.ttype == Type.Enum.iobject
              ClassType srcClass = callArglist[ai].type.getClassType(ctx)
              ClassType destClass = methodArgList[ai].type.getClassType(ctx)
              IF argtry[ai].type.ttype != Type.Enum.iobject
                          && methodArgList[ai].type.ttype != Type.Enum.iobject
                # iobject -> object
                int idx = srcClass.childIndex(destClass, FALSE)
                IF idx < 0
                  ctx.error("Class type mismatch " .. srcClass.typeName()
                                          .. " to " .. destClass.typeName(),
                                                                     pos)
                }
                sw.write(",(void*)Zio(" .. idx .. ", ")
                sw.write($getPosNumber(pos, ctx))
                sw.write(", &A" .. (ai + 1))
                sw.write(")")
              ELSEIF srcClass IS destClass
                # iobject -> iobject of same class
                sw.write(",A" .. (ai + 1))
              ELSE
                # iobject -> iobject of other class
                argNotNull.set(ai + 1)
                sw.write(",ZconvertZioref(A" .. (ai + 1))
                string close = $convertZorefArgs(srcClass, destClass, pos, ctx)
                sw.write(close)
              }
            ELSEIF callArglist[ai].type.ttype == Type.Enum.object
                          && methodArgList[ai].type.ttype == Type.Enum.iobject
              # object -> iobject
              ClassType srcClass = callArglist[ai].type.getClassType(ctx)
              ClassType destClass = methodArgList[ai].type.getClassType(ctx)
              Output convOut = NEW()
              convOut.writing = TRUE
              string tmpName
              tmpName = "t" .. tmpIdx++
              string close = $object2iobject(srcClass, destClass, tmpName,
                                                            pos, convOut, ctx)
              sw.write(",")
              sw.write(convOut.ToString())
              sw.write("A" .. (ai + 1))
              sw.write(close)
            ELSEIF callArglist[ai].type.ttype == Type.Enum.byRef
                            && methodArgList[ai].type.ttype != Type.Enum.byRef
              # &var -> var
              sw.write(",*A" .. (ai + 1))
            ELSE
              sw.write(",A" .. (ai + 1))
            }
          }
          sw.write(");")
          IF maxTmpIdx < tmpIdx
            maxTmpIdx = tmpIdx
          }

          # The call up to here is remembered for if there is only one method.
          lastCall = sw.ToString()
          tmpOut.write(lastCall)
          sw.clear()

          IF mtype.ttype != Type.Enum.func
            tmpOut.write(" return;")
          }
          tmpOut.write("\n")
        ELSE
          tmpOut.write("   return")
          IF mtype.ttype == Type.Enum.func
            tmpOut.write(" 0")
          }
          tmpOut.write(";\n")
        }
      }

      # Advance to the next class for the argument.
      int idx = altList.Size()
      WHILE idx > 0
        idx--
        IF depth > idx * 2
          depth--
        }
        IF altList[idx].Size() > 1
          indexes[idx]++
          IF indexes[idx] < altList[idx].Size()
            BREAK
          }
          indexes[idx] = 0
          IF depth > idx * 2
            depth--
            tmpOut.write(" }\n")
          }
        ELSE
          depth--
        }
      }
      IF depth <= 0
        BREAK
      }
    }

    $virtualDeclOut.writing = ctx.out.writing
    $virtualBodyOut.writing = ctx.out.writing

    Output headOut = NEW(NEW())
    headOut.writing = ctx.out.writing
    SContext virtualCtx = ctx.copy(headOut)

    # Write return type.
    IF retType == NIL || retType.ttype == Type.Enum.unknown
      headOut.write("void ")
    ELSE
      $vartype(retType, TRUE, pos, virtualCtx)
    }

    headOut.write(funcName .. "(")

    # produce the arguments: "(classType A0, arg1Type A1, arg2Type A2)"
    IF varType.ttype == Type.Enum.object
      $vartype(varType.getClassType(ctx), TRUE, pos, virtualCtx)
    ELSE
      $vartype(varType, TRUE, pos, virtualCtx)
    }
    headOut.write("A0")
    int argIdx = 1
    FOR d IN callArglist
      headOut.write(", ")
      # TODO: remove unknown
      IF d.type.ttype == Type.Enum.nilval || d.type.ttype == Type.Enum.unknown
        # Should be a NIL.
        headOut.write("void *")
      ELSE
        $vartype(d.type.getEffType(), TRUE, pos, virtualCtx)
      }
      headOut.write("A" .. argIdx)
      argIdx++
    }
    headOut.write(")")

    # Append the function declaration to virtualDeclOut.
    $virtualDeclOut.append(headOut)
    $virtualDeclOut.write("; /* " .. funcKey .. " */\n")

    # Append the function body to virtualBodyOut.
    $virtualBodyOut.append(headOut)
    $virtualBodyOut.write(" {\n")

    FOR i IN 0 UNTIL maxTmpIdx
      $virtualBodyOut.write(" Tr t" .. i .. ";\n")
    }

    IF haveTwoMethods
      # The type of object matters.  When an argument is NIL we don't know
      # what method to call, thus throw an exception.
      IF argNotNull.Size() > 0
        FOR ai IN argNotNull.keys()
          string what
          IF ai == 0
            what = "object"
          ELSE
            what = "argument " .. ai
          }
          $setDeclUsed(Declaration.throwCstringNil)
          $virtualBodyOut.write(" if (A" .. ai
              .. ".ptr == NULL) ZthrowCstringNil(\""
              .. methodName .. ": "
              .. what .. " is NIL, cannot select method to invoke\");\n")
        }
      }

      $virtualBodyOut.append(tmpOut)
      # If we get to the end something is wrong.
      $virtualBodyOut.write(
          " ZthrowCstringBadValue(\""
              .. methodName .. ": cannot select method to invoke\");\n")
      $setDeclUsed(Declaration.throwCstringBadValue)
      # Avoid a compiler warning for missing return.
      IF retType == NIL || retType.ttype == Type.Enum.unknown
        $virtualBodyOut.write(" return;\n")
      ELSE
        $virtualBodyOut.write(" return ")
        $writeNilValue(retType, $virtualBodyOut)
        $virtualBodyOut.write(";\n")
      }
    ELSE
      # There is only one method to call, do that directly here.
      $virtualBodyOut.write(lastCall)
      $virtualBodyOut.write("\n")
    }
    $virtualBodyOut.write("}\n")

    funcDecl.type = retType
    IF retType != NIL && retType.ttype == Type.Enum.object
      # It is possible that a child is found for a class later, then
      # the type changes from object to iobject and we need to come
      # back here to take care of that.
      ClassType ct = retType.getClassType(ctx)
      IF ct != NIL
        ct.scope.addScopeDependency(ctx.scope)
      }
    }

    IF ctx.out.writing
      $virtualFuncMap[funcKey] = funcDecl
    }
    RETURN funcDecl
  }

  # "object.member.(expr)(arg)" -> (cast)(expr)(object.member, arg);
  FUNC $memberExpr(Zui.MethodCall method, Generate.CallbackInfo cbInfo,
                                             SContext ctx, Type destType) Type
    Zui.Expression nameExpr = method.getName()
    VAR ext = ZuiMethodCallExt.get(method)

    # We don't want an iobject "Tr" here but the actual class.
    bool avoidTr = ext.typeObj.getMethod().classType != NIL
    $refCast(ext.typeObj, TRUE, avoidTr, method.getPos(), ctx)

    # Evaluate "(expr)": function pointer
    ctx.out.write("(")
    # TODO: when the expression has side effects need a temp var.
    genExpr(nameExpr.getRight(), ctx)

    ctx.out.write(")")
    ctx.out.write("->cfunc")
    ctx.out.write(")(")
    genExpr(nameExpr.getRight(), ctx)
    ctx.out.write(", ")

    # Evaluate "object.member", the THIS argument for the method.
    MethodType mt = ext.typeObj.getMethod()
    Type exprType = genExpr(nameExpr.getLeft(), ctx, mt.classType)
    IF exprType?.getTtype() == Type.Enum.iobject
      # TODO: is this the right way?
      ctx.out.write(".ptr")
    }

    # Evaluate "(arg)"
    list<Declaration.C> argList = ext.typeObj.getArgList()
    IF argList != NIL && argList.Size() > 0
      ctx.out.write(", ")
      Generate.generateArgumentsCheck(method, "{expr}", ctx, argList, NIL,
                                                                     destType)
    }
    ctx.out.write(")")

    IF ext.typeObj != NIL
      RETURN ext.typeObj.getReturnType()
    }
    RETURN NIL
  }

  PROC $argWithType(bool first, Type type, Zui.Position pos,
                                               string argName, SContext ctx)
    IF !first
      ctx.out.write(", ")
    }
    $vartype(type, TRUE, pos, ctx)
    ctx.out.write(argName)
  }

  # Write a varargs argument for |args[startIndex]| .. |args[args.Size() - 1]|
  # |decl| has the type of the method varargs.
  # Return the number of undefined symbols.
  FUNC $writeVarargs(Zui.MethodCall call, Type type, TupleType tupleType,
                  list<Zui.Expression> args, int startIndex, SContext ctx) int
    WriteArrayC.writeVarargs(call, type, tupleType, args, startIndex, ctx)
    RETURN 0
  }

  # Return TRUE when forward declarations are to be written.
  FUNC $doWriteDecl() bool
    RETURN TRUE
  }

  FUNC $subscript(Zui.Expression expr, SContext ctx, Type destType) Type
    Zui.Expression left = expr.getLeft()
    Zui.Expression right = expr.getRight()

    # Get type of "expr".
    # TODO: this is a hack, it should be possible to use expr.typeObj
    Type type = genExpr(left, ctx.copyNoOut())

    Type ret
    IF type != NIL && type.ttype != Type.Enum.unknown
      # Flatten typedef
      type = type.getEffType()

      IF type.ttype == Type.Enum.array
        ret = WriteArrayC.generateSubscript(type.<ContainerType>,
                                                   expr, FALSE, ctx, destType)
      ELSEIF type.ttype == Type.Enum.list
        ret = WriteListC.generateSubscript(type.<ContainerType>,
                                                   expr, FALSE, ctx, destType)
      ELSEIF type.ttype == Type.Enum.dict
        ret = WriteDictC.generateSubscript(type.<ContainerType>,
                                                   expr, FALSE, ctx, destType)
      ELSEIF type.ttype == Type.Enum.string
        ctx.out.write("ZstringGetChar(")
        $genArg(left, ctx, Type.aString)
        ctx.out.write(", ")
        $genArg(right, ctx, Type.anInt)
        ctx.out.write(")")
        ret = Type.anInt
#      ELSEIF type.type == Type.Enum.varString
#        # TODO
#        ret = Type.anInt
      ELSEIF type.ttype == Type.Enum.byteString
        ctx.out.write("ZbyteStringGetByte(")
        $genArg(left, ctx, Type.aByteString)
        ctx.out.write(", ")
        $genArg(right, ctx, Type.anInt)
        ctx.out.write(", 0)")
        ret = Type.anInt
#      ELSEIF type.type == Type.Enum.varByteString
#        # TODO
#        ret = Type.anInt
      ELSEIF type.ttype == Type.Enum.tuple
        # tupleVar[3]
        ret = $tupleSubscript(type.<TupleType>, left, right, ctx)
      ELSEIF type.ttype == Type.Enum.multiple
        # multiRetFunc()[3]
        ret = $multipleSubscript(type.<MultipleType>, left, right, ctx)
      ELSEIF ctx.doError()
        ctx.error("type does not allow subscript: " .. type.typeName(), expr)
      }
    ELSEIF ctx.out.writing
      # Generate the error message for "expr"
      genExpr(left, ctx)
    }
    RETURN ret
  }


  FUNC $tupleSubscript(TupleType type, Zui.Expression left,
                                      Zui.Expression right, SContext ctx) Type
    bool dummy
    int idx = ExprEval.evalInt(right, ctx, TRUE, &dummy)
    IF idx < 0 || idx >= type.types.Size()
      IF ctx.doError()
        ctx.error("Subscript out of range: " .. idx
                       .. ", must be 0 .. " .. (type.types.Size() - 1), right)
      }
      RETURN NIL
    }
    RETURN $tupleItem(type, left, idx, ctx)
  }

  FUNC $tupleItem(TupleType type, Zui.Expression left, int idx,
                                                            SContext ctx) Type
    ctx.out.write("(")
    genExpr(left, ctx, type)
    ctx.out.write(")->m")
    ctx.out.write(idx)
    RETURN type.types[idx].type
  }

  PROC $tupleItem(string tempName, int idx, Zui.Position pos, SContext ctx)
    ctx.out.write(tempName)
    ctx.out.write("->m")
    ctx.out.write(idx)
  }

  FUNC $multipleSubscript(MultipleType type, Zui.Expression left,
                                      Zui.Expression right, SContext ctx) Type
    bool dummy
    int idx = ExprEval.evalInt(right, ctx, TRUE, &dummy)
    IF idx < 0 || idx >= type.types.Size()
      IF ctx.doError()
        ctx.error("Subscript out of range: " .. idx
                       .. ", must be 0 .. " .. (type.types.Size() - 1), right)
      }
      RETURN NIL
    }
    ctx.out.write("(")
    genExpr(left, ctx, type)
    ctx.out.write(").a" .. idx)
    RETURN type.types[idx].type
  }

  PROC $multiReturnItem(Declaration tempDecl, int i,
                                   Zui.Position pos, Output out, SContext ctx)
    out.write(tempDecl.pName)
    out.write(".a" .. i)
  }

  FUNC $varnameSubscript(Type type, Zui.Expression expr, bool lvalue,
                                             SContext ctx, Type destType) Type
    Type.Enum ttype = type?.getTtype()
    IF ttype == Type.Enum.tuple
      # tupleVar[3]
      RETURN $tupleSubscript(type.getEffType().<TupleType>,
                                         expr.getLeft(), expr.getRight(), ctx)
    }

    Type effType = type?.getEffType()
    IF effType != NIL && effType ISA ContainerType
      ContainerType cont = effType
      IF ttype == Type.Enum.array
        WriteArrayC.generateSubscript(cont, expr, lvalue, ctx, destType)
      ELSEIF ttype == Type.Enum.list
        WriteListC.generateSubscript(cont, expr, lvalue, ctx, destType)
      ELSEIF ttype == Type.Enum.dict
        WriteDictC.generateSubscript(cont, expr, lvalue, ctx, destType)
      }
      RETURN cont?.itemType
    }

# TODO: unused
#    ELSE
#      bool cast
#      IF ttype == Type.Enum.string || ttype == Type.Enum.byteString
#        cast = TRUE
#        ctx.out.write("((Tc*)(")
#      }
#      Generate.generateVarnamePart(expr.getLeft(), FALSE, ctx, destType)
#      IF cast
#        ctx.out.write("))")
#      }
#      ctx.out.write("[")
#      genExpr(expr.getRight(), ctx, Type.anInt)
#      ctx.out.write(" + ZOH_OFF]")
#    }
    RETURN NIL
  }

  FUNC $dictGet(ContainerType type, Zui.Expression dictExpr,
                                                       Zui.Expression keyExpr,
                         Zui.Expression defExpr, SContext ctx, Type destType
                 ) Type
    RETURN WriteDictC.generateGet(
                              type, dictExpr, keyExpr, defExpr, ctx, destType)
  }

  # Generate accessing an object member |objDecl| of an interface |itfType|.
  # When |genVarname| is TRUE use generateVarnamePart instead of genExpr.
  PROC $iobjectMember(Declaration objDecl, Type itfType,
                      Zui.Expression expr, bool dotnil,
                               SContext ctx, Type destType, bool genVarname)
    int idx = WriteIMT.classMemberTableIndex(
                                    itfType.getClassType(ctx), objDecl, TRUE)
    $iobjectMemberIdx(objDecl, itfType, expr, dotnil,
                                               ctx, destType, genVarname, idx)
  }

  # Like $iobjectMember() but for a callback, where |methodDecl| is used to
  # find the method index and |callbackDecl| is the actual callback to invoke.
  PROC $iobjectCallbackMember(Declaration methodDecl,
                      Declaration callbackDecl, Type itfType,
                      Zui.Expression expr, bool dotnil,
                               SContext ctx, Type destType, bool genVarname)
    int idx = WriteIMT.classMemberTableIndex(
                                    itfType.getClassType(ctx), methodDecl, TRUE)
    ++idx  # callback is in table[] after the method
    IF methodDecl.hasDirectRef
      ++idx  # a Tcb is in between the method and the callback
    }
    $iobjectMemberIdx(callbackDecl, itfType, expr, dotnil,
                                               ctx, destType, genVarname, idx)
  }

  PROC $iobjectMemberIdx(Declaration objDecl, Type itfType,
                      Zui.Expression expr, bool dotnil,
                        SContext ctx, Type destType, bool genVarname, int idx)
    # some.member -> (*(type *)(some->ptr + (size_t)some->table[index]))
    # BUT: if "some" may have side effects do it like this:
    #      (*(type *)ZoM(some, index))
    ctx.out.write("(*(")
    $vartype(objDecl.type, FALSE, expr.getPos(), ctx)
    ctx.out.write("*)")
    Zui.Expression left = expr.getLeft()
    IF left.getType() == Zui.ExprType.eID && !dotnil
      ctx.out.write("(")
      IF genVarname
        Generate.generateVarnamePart(left, FALSE, ctx, destType)
      ELSE
        genExpr(left, ctx, destType)
      }
      ctx.out.write(".ptr + (size_t)")
      IF genVarname
        Generate.generateVarnamePart(left, FALSE, ctx, destType)
      ELSE
        genExpr(left, ctx, destType)
      }
      ctx.out.write(".table[")
      ctx.out.write(idx .. "")
      ctx.out.write("])")
    ELSE
      IF dotnil
        ctx.out.write("ZoD(")
      ELSE
        ctx.out.write("ZoM(")
      }
      IF genVarname
        Generate.generateVarnamePart(left, FALSE, ctx, destType)
      ELSE
        genExpr(left, ctx, destType)
      }
      ctx.out.write(", ")
      ctx.out.write(WriteIMT.classMemberTableIndex(
                              itfType.getClassType(ctx), objDecl, TRUE) .. "")
      ctx.out.write(")")
    }
    ctx.out.write(")")
  }

  PROC $iobjectFuncUse(Declaration objDecl, Type itfType,
                                            Zui.Expression expr, SContext ctx)
    ctx.out.write("(Tcb*)(")
    genExpr(expr, ctx, Type.aParent)
    ctx.out.write(").table[")
    ctx.out.write(WriteIMT.classMemberTableIndex(itfType.getClassType(ctx),
                                                objDecl, ctx.doError()) .. "")
    # The IMT stores the ZCB pointer in the next entry.
    ctx.out.write(" + 1]")
  }

  # Binary operator with int values.
  FUNC $numberOp(Zui.Expression expr, SContext ctx) Type
    IF expr.getType() == Zui.ExprType.eREMAINDER
                        && ZuiExpressionExt.get(expr).leftExprType?.getTtype()
                                                            == Type.Enum.float
      # float % requires a function call.
      $setDeclUsed(%math)
      ctx.out.write("fmod(")
      genExpr(expr.getLeft(), ctx, Type.aFloat)
      ctx.out.write(", ")
      genExpr(expr.getRight(), ctx, Type.aFloat)
      ctx.out.write(")")
      RETURN Type.aFloat
    }
    RETURN numberOp(expr, ctx)
  }

  FUNC $stringConcat(Zui.Expression expr, string cast, SContext ctx) string
    ctx.out.write(" = ")
    IF cast != NIL
      ctx.out.write(cast)
    }
    ctx.out.write(" ZcS(")
    $genArg(expr, ctx, Type.aString)
    ctx.out.write(", ")
    RETURN ")"
  }

  FUNC $varStringConcatAssign(Zui.Assignment assign, SContext ctx) int
    ctx.out.write("ZvarStringConcatAssign(")
    Generate.generateLVarname(assign.getLhs(), TRUE, ctx, NIL)
    ctx.out.write(", ")
    genExpr(assign.getRhs(), ctx, Type.aByteString)
    ctx.out.write(");\n")
    RETURN 0
  }

  PROC $concatStringOp(Zui.Expression expr, SContext ctx, Type destType)
    ctx.out.write("ZcS(")
    # The .. operator supports automatic conversion string or byteString.
    $generatingArg = TRUE
    Generate.genExprDoConv(expr.getLeft(), ctx, destType)
    ctx.out.write(", ")
    Generate.genExprDoConv(expr.getRight(), ctx, destType)
    $generatingArg = FALSE
    ctx.out.write(")")
  }

  # A sequence of 3 or more string concatenation operators.
  PROC $concatStringOp(list<Zui.Expression> concats,
                                                  SContext ctx, Type destType)
    int size = concats.Size()
    int unused
    list<Zui.Expression> doHere = concats
    string comma = ""
    IF size == 3
      ctx.out.write("ZcS3(")
      $setDeclUsed(%concat3)
      unused = 0
    ELSEIF size <= 5
      ctx.out.write("ZcS5(")
      $setDeclUsed(%concat5)
      unused = 5 - size
    ELSEIF size <= 8
      ctx.out.write("ZcS8(")
      $setDeclUsed(%concat8)
      unused = 8 - size
    ELSE
      ctx.out.write("ZcS12(")
      $setDeclUsed(%concat12)
      IF size > 12
        IF size == 13
          # split into 3 + 10
          $concatStringOp(concats.slice(0, 2), ctx, destType)
          doHere = concats.slice(3)
          unused = 1
        ELSE
          # split into N + 11
          $concatStringOp(concats.slice(0, -12), ctx, destType)
          doHere = concats.slice(-11)
          unused = 0
        }
        comma = ", "
      ELSE
        unused = 12 - size
      }
    }

    $generatingArg = TRUE
    FOR expr IN doHere
      ctx.out.write(comma)
      Generate.genExprDoConv(expr, ctx, destType)
      comma = ", "
    }
    $generatingArg = FALSE

    FOR i IN 1 TO unused
      ctx.out.write(", (Tc*)1")
    }
    ctx.out.write(")")
  }

  PROC $concatVarStringOp(Zui.Expression expr, SContext ctx, Type destType)
    Type valType = (destType.ttype == Type.Enum.varByteString)
                                             ? Type.aByteString : Type.aString
    string types

    Type.Enum left = Generate.resultType(expr.getLeft(), ctx)
    Type leftType
    IF left == Type.Enum.stringval || left == valType.ttype
      leftType = valType
      types = "V"
    ELSE
      leftType = destType
      types = "B"
    }

    Type.Enum right = Generate.resultType(expr.getRight(), ctx)
    Type rightType
    IF right == Type.Enum.stringval || right == valType.ttype
      rightType = valType
      types ..= "V"
    ELSE
      rightType = destType
      types ..= "B"
    }

    ctx.out.write("ZconcatVarString" .. types .. "(")
    # The .. operator supports automatic conversion varString or varByteString.
    Generate.genExprDoConv(expr.getLeft(), ctx, leftType)
    ctx.out.write(", ")
    Generate.genExprDoConv(expr.getRight(), ctx, rightType)
    ctx.out.write(")")
  }

  # Generate code for a literal number.
  PROC $generateInt(Zui.Expression expr, SContext ctx)
    int n = expr.getNumber()
    IF n > 0x7fff'ffff
               || n < (expr.getType() == Zui.ExprType.eNAT ? 0 : -0x7fff'ffff)
      IF expr.getType() == Zui.ExprType.eNAT
        # The nat was stored as an int, turn it back into a nat here.
        nat u = n
        ctx.out.write(u .. "UL")
      ELSE
        # The largest negative integer causes a compiler warning with C99,
        # because it first uses the unsigned number before it applies the "-"
        # sign. Need this weird solution.
        IF n == -0x8000'0000'0000'0000
          ctx.out.write("(-0x7fffffffffffffffLL - 1)")
        ELSE
          ctx.out.write(n .. "LL")
        }
      }
    ELSE
      ctx.out.write(n .. "")
    }
  }

  # Generate code for a literal float number.
  PROC $generateFloat(Zui.Expression expr, SContext ctx)
    # With 64 bits there are about 16 significant digits.
    ctx.out.write(expr.getFnumber().ToString(".16g"))
  }

  # Generate code for a literal string.
  PROC $stringValue(string value, SContext ctx)
    Output out = ctx.out

    out.write("Zstr(\"")

    # Handle limited set of special characters.
    int i = 0
    byteString s = value.asByteString()
    WHILE i < s.Size()
      int c = s[i]
      IF c == '\n'
        out.write("\\n")
      ELSEIF c == '\r'
        out.write("\\r")
      ELSEIF c == '\t'
        out.write("\\t")
      ELSEIF c == '"'
        out.write("\\\"")
      ELSEIF c == '\\'
        out.write("\\\\")
      ELSE
        out.write(c.asByteString().ToString())
      }
      i++
    }
    out.write("\")")
  }

  # Keep track of what strings have already been generated. Each one has to be
  # produced only once.
  dict<string, string> $generatedStrings = NEW()

  # Keep track of what string sizes have already been generated. A typedef is
  # generated for each new one.
  set<int> $generatedSizes = NEW()

  # Generate C code for a byteString from a stringLiteral |expr|.
  # Also handle "string .. string", generate it as one long string.
  PROC $byteStringValue(Zui.Expression expr, SContext ctx)
    IF !ctx.out.writing
      RETURN
    }
    string value = Generate.stringExprToString(expr)
    string pName = $writeStaticString(value, ctx)
    Output out = ctx.out
    out.write("((Tc*)&")
    out.write(pName)
    out.write(")")
  }

  # Write a declaration for a static string to declOut.
  # Return the name of the struct.
  FUNC $writeStaticString(string value, SContext ctx) string
    IF !ctx.out.writing
      RETURN ""
    }

    string pName = $generatedStrings.get(value, NIL)
    IF pName == NIL
      IF value == "NIL"
        pName = "ZNilString"
      ELSE
        pName = getUid(value)
      }
      $writeNewStaticString(value, pName, ctx)
    }
    RETURN pName
  }

  PROC $writeNewStaticString(string value, string pName, SContext ctx)
    $generatedStrings.add(value, pName)

    # Write the size as a varint, MSB first.
    int size = value.asByteString().Size()
    int len = size + 1
    string s = ""
    int add = 0
    DO
      s = Generate.toOctal(add + (size & 127)) .. s
      size = size >> 7
      add = 128
      ++len
    UNTIL size == 0
    IF !$generatedSizes.has(len)
      $generatedSizes.set(len)
      Output sout = ctx.outs.structOut
      sout.write("typedef struct {\n")
      IF $hasNpField()
        sout.write(linkedDecl)
      }
      sout.write(" char text[")
      sout.write(len)
      sout.write("];\n")
      sout.write("} Zs")
      sout.write(len)
      sout.write(";\n")
    }

    Output dout = ctx.outs.declOut
    dout.write("Zs" .. len)
    dout.write(" ")
    dout.write(pName)
    dout.write(" = {")
    IF $hasNpField()
      dout.write("&Zstatic, ")
    }
    dout.write("\"")
    dout.write(s)
    WriteCommon.writeByteString(value.asByteString(), dout)
    dout.write("\\000\"};\n")
  }

  # Generate code to set varByteString |dest| from a stringLiteral |expr|.
  PROC $varByteStringSetString(Zui.Expression expr, Declaration dest, SContext ctx)
    Output out = ctx.out
    out.write("ZvarByteStringSet(&")
    out.write(dest.pName)
    out.write(", ")
    $byteStringValue(expr, ctx)
    out.write(")")
    $setDeclUsed(%varByteStringSet)
  }

  FUNC $plusOp(Zui.Expression expr, SContext ctx, Type.Enum destType) Type
    RETURN $numberOp(expr, ctx)
  }

  PROC $incrdecrOp(Zui.Expression expr, SContext ctx)
    incrdecrOp(expr, ctx)
  }

  # "expr ISA classType" and "expr ISNOTA classType"
  PROC $isaOp(Zui.Expression expr, SContext ctx)
    Type rightType = $isaOpType(expr, ctx)
    IF rightType != NIL
      IF $isDeclUsed(rightType)
        $writeIsa(expr, expr.getType() == Zui.ExprType.eISNOTA,
                                                rightType, expr.getPos(), ctx)
      ELSEIF expr.getType() == Zui.ExprType.eISNOTA
        # The RHS type is not used, ISNOTA is always true.
        ctx.out.write("1")
      ELSE
        # The RHS type is not used, ISA is always false.
        ctx.out.write("0")
      }
    }
  }

  # Produce code for ISA, ISNOTA and CATCH.
  # When |expr| is NIL the value to is the thrown exception, otherwise it's
  # an expresion in expr.getLeft().
  # |rightSym| is the classType to compare with.
  PROC $writeIsa(Zui.Expression expr, bool isnota, Type rightType,
                                               Zui.Position pos, SContext ctx)
    # If "classType" is SomeClass.I we need to check a range of types.
    IF rightType.ttype == Type.Enum.iobject
      $setDeclUsed(%typeInRange)
      IF isnota
        ctx.out.write("!")
      }
      ctx.out.write("ZTypeInRange(")
    }
    ctx.out.write("(")

    Type leftType
    IF expr == NIL  # catch
      ctx.out.write("te->thrown[te->thrownUsed - 1]")
      leftType = Builtin.getExceptionDotIType()
    ELSE
      # generate "expr"
      leftType = genExpr(expr.getLeft(), ctx)
    }
    IF leftType != NIL
      IF leftType.ttype != Type.Enum.iobject
        ctx.error("Expected interface type, got " .. leftType.typeName(), pos)
      }
      ctx.out.write(").type")
      ClassType leftClass = leftType.getClassType(ctx)
      IF leftClass == NIL
        ctx.error("class unknown", expr == NIL ? pos : expr.getLeft().getPos())
      ELSEIF rightType.ttype == Type.Enum.class
        IF isnota
          ctx.out.write(" != ")
        ELSE
          ctx.out.write(" == ")
        }
        int i = leftClass.childIndex(rightType, FALSE)
        IF i < 0
          ctx.error("Incompatible interface and class", pos)
        }
        ctx.out.write(i .. "")
      ELSEIF rightType.ttype == Type.Enum.iobject
        ClassType rightClass = rightType.getClassType(ctx)
        int low = leftClass.childIndex(rightClass, FALSE)
        IF low < 0
          ctx.error("Incompatible interfaces", pos)
        }
        ctx.out.write(", " .. low .. ", ")

        int high = leftClass.childIndex(rightClass, TRUE)
        ctx.out.write((high - 1) .. ")")
      ELSE
        ctx.error("Expected class or interface type, got "
                                                .. rightType.typeName(), pos)
      }
    }
  }

  # Write field of an iobject for assignment.
  PROC $writeDerefLhs(Output out)
    out.write(".ptr")
  }

  # When |expr| results in an i_object, dereference it, otherwise produce it
  # directly.
  PROC $mayDeref(Zui.Expression expr, SContext ctx)
    Type type = genExpr(expr, ctx.copyNoOut(TRUE), Type.aNil)
    IF type != NIL && type.ttype == Type.Enum.iobject
      IF $isIobject(type)
        ctx.out.write("((")
        $genArg(expr, ctx, Type.aNil)
        ctx.out.write(").ptr)")
      ELSE
        $setDeclUsed(%deref)
        ctx.out.write("Zderef(")
        $genArg(expr, ctx, Type.aNil)
        ctx.out.write(")")
      }
    ELSE
      $wrapExpr(expr, ctx, Type.aNil)
    }
  }

  PROC $booleanOp(Zui.Expression expr, bool isCompare, SContext ctx)
    bool isNot = expr.getType() == Zui.ExprType.eNOTEQUAL
                                      || expr.getType() == Zui.ExprType.eISNOT
    Zui.Expression left = expr.getLeft()
    Zui.Expression right = expr.getRight()
    VAR exprExt = ZuiExpressionExt.get(expr)

    # val == NAN and NAN == val need to use isNan().
    IF left.getType() == Zui.ExprType.eNAN
      IF isNot
        ctx.out.write("!")
      }
      $isNan(right, ctx)
      RETURN
    }
    IF right.getType() == Zui.ExprType.eNAN
      IF isNot
        ctx.out.write("!")
      }
      $isNan(left, ctx)
      RETURN
    }

    IF exprExt.leftExprType == NIL
      # Avoid checking for NIL many times.
      exprExt.leftExprType = Type.anUnknown
    }
    IF exprExt.rightExprType == NIL
      # Avoid checking for NIL many times.
      exprExt.rightExprType = Type.anUnknown
    }

    # "not-alloced type == NIL" checks if it was initialized.
    IF exprExt.leftExprType.isNoAlloc()
        && (expr.getType() == Zui.ExprType.eEQUAL
                                  || expr.getType() == Zui.ExprType.eNOTEQUAL)
        && (left.getType() == Zui.ExprType.eNIL
                                       || right.getType() == Zui.ExprType.eNIL)
      IF left.getType() == Zui.ExprType.eNIL
        genExpr(right, ctx, Type.aNil)
      ELSE
        genExpr(left, ctx, Type.aNil)
      }
      ctx.out.write("->np ")
      ctx.out.write(isNot ? "!" : "=")
      ctx.out.write("= NULL")
      RETURN
    }

    string op = compareOp(expr)
    IF exprExt.leftExprType.ttype == Type.Enum.dyn
                                 || exprExt.rightExprType.ttype == Type.Enum.dyn
      IF isNot
        ctx.out.write("!")
      }
      IF exprExt.leftExprType.ttype == Type.Enum.dyn
                                 && exprExt.rightExprType.ttype == Type.Enum.dyn
        $writeFuncLeftRight(expr, isCompare ? "ZdynCompare" : "ZdynEqual",
                                                               Type.aDyn, ctx)
        IF isCompare
          ctx.out.write(op)
          ctx.out.write("0")
        }
        RETURN
      }
      ctx.out.write(isCompare ? "ZdynCompareOne(" : "ZdynEqualOne(")
      IF exprExt.leftExprType.ttype == Type.Enum.dyn
        $wrapExpr(left, ctx, Type.aDyn)
      ELSE
        $wrapExpr(right, ctx, Type.aDyn)
      }
      ctx.out.write(", ")
      Type other
      IF exprExt.leftExprType.ttype == Type.Enum.dyn
        other = exprExt.rightExprType
        genTzArg(other, right, ctx)
      ELSE
        other = exprExt.leftExprType
        genTzArg(other, left, ctx)
      }
      ctx.out.write(", ")
      ctx.out.write($getAnyType(other, expr.getPos(), ctx))
      ctx.out.write(")")
      RETURN
    }

    IF expr.getType() == Zui.ExprType.eEQUAL
            || expr.getType() == Zui.ExprType.eNOTEQUAL
            || isCompare
      # == !=  > >= < <= for container types
      string name
      IF exprExt.leftExprType.ttype == Type.Enum.array
        $setDeclUsed(isCompare ? WriteArrayC.arrayCompare
                                                     : WriteArrayC.arrayEqual)
        name = "ZArray"
      ELSEIF exprExt.leftExprType.ttype == Type.Enum.list
        $setDeclUsed(isCompare ? WriteListC.listCompare : WriteListC.listEqual)
        name = "ZList"
      ELSEIF exprExt.leftExprType.ttype == Type.Enum.dict
        $setDeclUsed(isCompare ? WriteDictC.dictCompare : WriteDictC.dictEqual)
        name = "ZDict"
      }
      IF name != NIL
        IF isNot
          ctx.out.write("!")
        }
        $writeFuncLeftRight(expr, name .. (isCompare ? "Compare" : "Equal"),
                                                                     NIL, ctx)
        IF isCompare
          ctx.out.write(op)
          ctx.out.write("0")
        }
        RETURN
      }
    }

    ctx.out.write("(")
    IF exprExt.leftExprType.ttype == Type.Enum.nilval
      $wrapExpr(left, ctx, Type.aNil)
      IF ZuiExpressionExt.get(left).resultType?.getTtype() == Type.Enum.dyn
        # dyn == NIL ->  dyn.type == NULL
        ctx.out.write(".type")
      }
      ctx.out.write(op)
      $wrapExpr(right, ctx, Type.aNil)
      IF ZuiExpressionExt.get(right).resultType?.getTtype() == Type.Enum.dyn
        # NIL == cyn ->  NULL = dyn.type
        ctx.out.write(".type")
      }
    ELSEIF exprExt.leftExprType.ttype == Type.Enum.iobject
      $mayDeref(left, ctx)
      ctx.out.write(op)
      $mayDeref(right, ctx)
    ELSEIF exprExt.leftExprType.ttype == Type.Enum.string
        || exprExt.leftExprType.ttype == Type.Enum.byteString
      $setDeclUsed(%stringCmp)
      $stringCmpOp(expr, ctx, "ZstringCmp",
                                exprExt.leftExprType.ttype == Type.Enum.string
                                            ? Type.aString : Type.aByteString)
    ELSEIF exprExt.leftExprType.ttype == Type.Enum.varString
        || exprExt.leftExprType.ttype == Type.Enum.varByteString
      LOG.internal("Sorry, varString/varByteString compare not implemented yet")
      $setDeclUsed(%varByteStringCmp)
      $stringCmpOp(expr, ctx, "ZvarByteStringCmp",
               exprExt.leftExprType.ttype == Type.Enum.varString
                                      ? Type.aVarString : Type.aVarByteString)
    ELSEIF exprExt.leftExprType.ttype != Type.Enum.unknown
      IF exprExt.leftExprType.ttype == Type.Enum.object
        IF isNot
          ctx.out.write("!")
        }
        # Generate a call to left.Equal(right) or left.Compare(right)
        Generate.generateEqualCall(expr, isCompare, ctx)
        IF isCompare
          ctx.out.write(op)
          ctx.out.write("0")
        }
      ELSE
        $wrapExpr(expr.getLeft(), ctx, exprExt.leftExprType)
        ctx.out.write(op)
        $wrapExpr(expr.getRight(), ctx, exprExt.rightExprType)
      }
    ELSEIF ctx.doError()
      bool err = genExpr(expr.getLeft(), ctx) == NIL
      err = err || genExpr(expr.getRight(), ctx) == NIL
      IF !err
        ctx.error("INTERNAL: booleanOp()", expr)
      }
    }
    ctx.out.write(")")
  }

  # Write a C function call with left and right of |expr|.
  PROC $writeFuncLeftRight(Zui.Expression expr, string name, Type type,
                                                                 SContext ctx)
    ctx.out.write(name)
    ctx.out.write("(")
    $wrapExpr(expr.getLeft(), ctx, type)
    ctx.out.write(", ")
    $wrapExpr(expr.getRight(), ctx, type)
    ctx.out.write(")")
  }

  PROC $stringCmpOp(Zui.Expression expr, SContext ctx, string name, Type type)
    bool leftEmpty = expr.getLeft().getType() == Zui.ExprType.eSTRING
                                      && expr.getLeft().getStringValue() == ""
    bool rightEmpty = expr.getRight().getType() == Zui.ExprType.eSTRING
                                      && expr.getRight().getStringValue() == ""
    IF leftEmpty || rightEmpty
      # "" == s -> s.Size() == 0
      # "" != s -> s.Size() != 0
      # s == "" -> s.Size() == 0
      # s != "" -> s.Size() != 0
      IF type.ttype == Type.Enum.string || type.ttype == Type.Enum.byteString
        ctx.out.write("ZbyteStringSize(")
      ELSE
        ctx.out.write("ZvarByteStringSize(")
      }
      $generatingArg = TRUE
      Generate.genExprDoConv(leftEmpty ? expr.getRight() : expr.getLeft(),
                                                                    ctx, type)
      $generatingArg = FALSE
    ELSE
      ctx.out.write(name .. "(")
      $generatingArg = TRUE
      Generate.genExprDoConv(expr.getLeft(), ctx, type)
      ctx.out.write(", ")
      Generate.genExprDoConv(expr.getRight(), ctx, type)
      $generatingArg = FALSE
    }
    IF expr.getType() == Zui.ExprType.eEQUAL
      ctx.out.write(") == 0")
    ELSE
      ctx.out.write(") != 0")
    }
  }

  PROC $andorOp(Zui.Expression expr, SContext ctx)
    andorOp(expr, ctx)
  }

  FUNC $parens(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    ctx.out.write("(")
    Type ret = Generate.genExprConv(expr.getRight(), ctx, exprArg)
    ctx.out.write(")")
    RETURN ret
  }

  FUNC $altOp(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    RETURN altOp(expr, ctx, exprArg)
  }

  int $ptrIdx
  FUNC $ifnilOp(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    int idx
    IF ctx.out.writing
      # Need to get the value, genExprConv() is recursive.
      idx = ++$ptrIdx
    }
    ctx.out.write("((p" .. idx .. " = (")
    Type typeL = Generate.genExprConv(expr.getLeft(), ctx, exprArg)
    ctx.out.write("))")
    IF exprArg.destType()?.getTtype() == Type.Enum.iobject
      ctx.out.write(".ptr")
    }
    ctx.out.write(" == NULL ? (")

    IF ctx.out.writing && typeL != NIL
      ctx.outs.varOut.writeIndent(ctx.scope.depth)
      IF typeL.getTtype() == Type.Enum.iobject
        ctx.outs.varOut.write("Tr ")
      ELSE
        ctx.outs.varOut.write("void *")
      }
      ctx.outs.varOut.write("p" .. idx .. ";\n")
    }

    ExprArg r = exprArg.copy()
    IF r.dest == NIL || !r.dest.type.typeDefined()
      # Helps for the argument of FOR.
      r.dest = typeL
    }
    Type typeR = Generate.genExprConv(expr.getRight(), ctx, r)
    ctx.out.write(") : p" .. idx .. ")")

    # TODO: if destType is NIL check typeL and typeR are the same type
    IF typeR == NIL || !typeR.typeDefined()
      typeR = typeL
    }
    IF typeR != NIL
      IF typeR.isValueType()
        ctx.error("Expected a reference", expr.getRight())
      }
      RETURN typeR
    }

    RETURN NIL
  }

  PROC $newVarByteString(string noAllocName, SContext ctx)
    ctx.setDeclUsed(Declaration.alloc)
    ctx.setDeclUsed(%varByteStringType)
    IF noAllocName == NIL
      $writeAlloc("Ty", NIL, ctx.out, ctx)
    ELSE
      $writeNoAllocClear("Ty", NIL, NIL, noAllocName, ctx)
    }
  }

  FUNC $listInitStart(Zui.Expression expr, Declaration dest,
                                             SContext ctx, Type destType) Type
    IF destType == NIL
      RETURN NIL
    }
    MethodType newFromList = destType.findNewFromContainerMethod(
                                            expr, Type.Enum.list, "list", ctx)
    IF newFromList == NIL
      ctx.error("Cannot find NEW() method that accepts a list", expr)
      RETURN NIL
    }
    ctx.out.write(newFromList.pName .. "(")
    $writeNoAllocInit(dest, ctx)
    ctx.out.write(", ")
    RETURN newFromList.getArgList()[0].type.<ContainerType>.itemType
  }

  # Write the initialization for a not allocated type, when the destination is
  # an object.
  PROC $writeNoAllocInit(Declaration dest, SContext ctx)
    IF dest == NIL || dest.type.<NoAllocType>.needAlloc()
      ctx.out.write("NULL")
    ELSE
      ClassType class = dest.type.getClassType(ctx)
      Declaration initMethod = Generate.findUsefulInit(class.scope)
      Declaration finishMethod = Generate.getFinishMethod(class.scope, ctx)
      $writeNoAllocClear(class.pName, initMethod, finishMethod, dest, ctx)
    }
  }

  PROC $listInitTail(SContext ctx)
    ctx.out.write(")")
  }

  FUNC $dictInitStart(Zui.Expression expr, Declaration dest,
                                    SContext ctx, Type destType) ContainerType
    IF destType == NIL
      RETURN NIL
    }
    MethodType newFromDict = destType.findNewFromContainerMethod(
                                            expr, Type.Enum.dict, "dict", ctx)
    IF newFromDict == NIL
      ctx.error("Cannot find NEW() method that accepts a dict", expr)
      RETURN NIL
    }
    ctx.out.write(newFromDict.pName .. "(")
    $writeNoAllocInit(dest, ctx)
    ctx.out.write(", ")
    RETURN newFromDict.getArgList()[0].type
  }

  PROC $dictInitTail(SContext ctx)
    ctx.out.write(")")
  }

  FUNC $newArrayInit(Zui.Expression expr, string noAllocName,
                                             Type destType, SContext ctx) Type
    RETURN WriteArrayC.generateListPart(expr, noAllocName, ctx, destType)
  }

  FUNC $newListInit(Zui.Expression expr, string noAllocName,
                                             Type destType, SContext ctx) Type
    RETURN WriteListC.generateListPart(expr, noAllocName, ctx, destType)
  }

  PROC $newDictInit(Zui.Expression expr, string noAllocName,
                            SContext ctx, ContainerType type, Type destType)
    WriteDictC.generateNewDict(expr, noAllocName, ctx, type, destType)
  }

  # tuple = [item, item]
  PROC $newTupleInit(Zui.Expression expr, string noAllocName,
                                             TupleType destType, SContext ctx)
    ctx.out.write("Za")
    ctx.out.write(destType.pName)
    ctx.out.write("(")
    IF noAllocName == NIL
      ctx.out.write("NULL")
    ELSE
      ctx.out.write("&")
      ctx.out.write(noAllocName)
    }
    FOR idx IN 0 UNTIL destType.types.Size()
      ctx.out.write(", ")
      Zui.Expression item = expr.getListItem(idx)
      Generate.genExprDoConv(item, ctx, destType.types[idx].type)
    }
    ctx.out.write(")")
  }

  FUNC $dictMethodCall(ContainerType type, Zui.MethodCall call,
                                                 SContext ctx, Type destType
                      ) Type
    RETURN WriteDictC.generateMethodCall(type, call, ctx, destType)
  }

  FUNC $listMethodCall(ContainerType type, Zui.MethodCall call,
                                                   SContext ctx, Type destType
                      ) Type
    RETURN WriteListC.generateMethodCall(type, call, ctx, destType)
  }

  FUNC $arrayMethodCall(ContainerType type, Zui.MethodCall call,
                                                   SContext ctx, Type destType
                      ) Type
    RETURN WriteArrayC.generateMethodCall(type, call, ctx, destType)
  }

  # Bits assignment of |rhs| to |lhs|, of type |bitsMember|.
  # Return the number of undefined symbols in |lhs|.
  FUNC $bitsAssign(Zui.Expression lhs, Zui.Expression rhs,
                                     ValueType bitsMember, SContext ctx) int
    RETURN bitsAssign(lhs, rhs, bitsMember, ctx)
  }

  # A bool field in a BITS.
  PROC $bitsMemberBool(Zui.Expression left, ValueType memberType,
                                                                 SContext ctx)
    bitsMemberBool(left, memberType, ctx)
  }

  # An int (or nat) member of a BITS
  PROC $bitsMemberInt(Zui.Expression left, ValueType memberType,
                                                                 SContext ctx)
    bitsMemberInt(left, memberType, ctx)
  }

  FUNC $expr(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    # First write the expression to a temporary output, so that we can wrap
    # the conversion around it when needed.
    Output exprOut = NEW(NEW())
    exprOut.writing = ctx.out.writing
    SContext exprOutCtx = ctx.copy(exprOut)

    # Assume that a conversion means using the expression as an argument.
    bool saveGeneratingArg = $generatingArg
    IF ZuiExpressionExt.get(expr).conversion != Conversion.none
      $generatingArg = TRUE
    }
    Type type = Generate.genExprChecked(expr, exprOutCtx, exprArg)
    $generatingArg = saveGeneratingArg

    RETURN $conversion(expr, type, exprOut, ctx, exprArg)
  }

  FUNC $conversion(Zui.Expression expr, Type type,
                           Output exprOut, SContext ctx, ExprArg exprArg) Type
    # Detect the required conversion again.  It may change when producing a
    # method for multiple subclasses.
    Type typeConverted = Resolve.exprConversion(expr, type, ctx, exprArg)

    # When needed: store the result in a temp variable: (t = expr)
    # For a eLIST "[1, 2, 3]" it's done in $newListInit().
    # For an iobject it's done in Znao().
    bool doClose
    VAR exprExt = ZuiExpressionExt.get(expr)
    IF ctx.out.writing && exprExt.tempDecl != NIL
                       && expr.getType() != Zui.ExprType.eLIST
                       && exprExt.conversion != Conversion.object2iobject
      ctx.out.write("(")
      ctx.out.write(exprExt.tempDecl.pName)
      ctx.out.write(" = ")
      doClose = TRUE
    }

    string close = ""
    IF exprArg.destType() != NIL
                              && exprArg.destType().ttype != Type.Enum.unknown
      SWITCH exprExt.conversion
        CASE Conversion.none
          BREAK
        CASE Conversion.int2string
          $setDeclUsed(%int2string)
          ctx.out.write("Zint2string(")
          close = ")"
        CASE Conversion.nat2string
          $setDeclUsed(%nat2string)
          ctx.out.write("Znat2string(")
          close = ")"
        CASE Conversion.float2string
          $setDeclUsed(%float2string)
          ctx.out.write("Zfloat2string(")
          close = ")"
        CASE Conversion.bool2string
          $setDeclUsed(%bool2string)
          ctx.out.write("Zbool2string(")
          close = ")"
        CASE Conversion.status2string
          $setDeclUsed(%status2string)
          ctx.out.write("Zstatus2string(")
          close = ")"
        CASE Conversion.int2varString
          $setDeclUsed(%int2varString)
          ctx.out.write("Zint2varString(")
          close = ")"
        CASE Conversion.bool2varString
          $setDeclUsed(%bool2varString)
          ctx.out.write("Zbool2varString(")
          close = ")"
        CASE Conversion.status2varString
          $setDeclUsed(%status2varString)
          ctx.out.write("Zstatus2varString(")
          close = ")"
        CASE Conversion.string2varString
          $setDeclUsed(%string2varString)
          ctx.out.write("Zstring2varString(")
          close = ")"
        CASE Conversion.varString2string
          ctx.setDeclUsed(%varString2string)
          ctx.out.write("ZvarString2string(")
          close = ")"
        CASE Conversion.object2iobject
          ClassType destClass = exprArg.destType().getClassType(ctx)
          IF exprExt.retClass == NIL || destClass == NIL
            ctx.error("Target class unknown", expr)
          ELSE
            string tempName
            IF exprArg.dest != NIL && (exprArg.dest.type.isNoAlloc()
                                           || $isIobject(exprArg.dest.type))
                                   && exprArg.dest.pName != NIL
                                   && !exprArg.dest.isClassMember()
              tempName = exprArg.dest.pName
            ELSEIF exprExt.tempDecl != NIL
              tempName = exprExt.tempDecl.pName
            }
            close = $object2iobject(exprExt.retClass, destClass, tempName,
                                                  expr.getPos(), ctx.out, ctx)
          }
        CASE Conversion.iobject2noalloc
          close = $object2noalloc(exprArg.dest, ctx.out)
        CASE Conversion.iobject2object
          ClassType destClass = exprArg.destType().getClassType(ctx)
          IF exprExt.retClass == NIL || destClass == NIL
            ctx.error("Target class unknown", expr)
          ELSE
            int idx = exprExt.retClass.childIndex(destClass, FALSE)
            IF idx < 0
              ctx.error("Class type mismatch " .. exprExt.retClass.typeName()
                                      .. " to " .. destClass.typeName(), expr)
            }
            $typecast(exprArg.destType(), ctx)
            ctx.out.write("Znio(" .. idx .. ", ")
            ctx.out.write($getPosNumber(expr.getPos(), ctx))
            ctx.out.write(", (")
            close = ")))"
          }
        CASE Conversion.iobject2iobject
          ClassType destClass = exprArg.destType().getClassType(ctx)
          ctx.out.write("ZconvertZioref(")
          close = $convertZorefArgs(exprExt.retClass, destClass,
                                                           expr.getPos(), ctx)
        CASE Conversion.callback2method
          ctx.out.write("((Tcb*)")
          close = ")"
          typeConverted = type.getEffType().<CallbackType>.methodType

        CASE Conversion.bool2dyn
        CASE Conversion.status2dyn
        CASE Conversion.int2dyn
        CASE Conversion.int82dyn
        CASE Conversion.int162dyn
        CASE Conversion.int322dyn
        CASE Conversion.nat2dyn
        CASE Conversion.byte2dyn
        CASE Conversion.nat162dyn
        CASE Conversion.nat322dyn
        CASE Conversion.enum2dyn
        CASE Conversion.bits2dyn
          close = $conv2dyn(type, "ZVtoDyn", NIL, expr.getPos(), ctx)

        CASE Conversion.float2dyn
          close = $conv2dyn(type, "ZFtoDyn", NIL, expr.getPos(), ctx)

        CASE Conversion.string2dyn
        CASE Conversion.byteString2dyn
        CASE Conversion.tuple2dyn
        CASE Conversion.type2dyn
        CASE Conversion.object2dyn
        CASE Conversion.array2dyn
        CASE Conversion.list2dyn
        CASE Conversion.dict2dyn
          close = $conv2dyn(type, "ZPtoDyn", NIL, expr.getPos(), ctx)

        CASE Conversion.iobject2dyn
          close = $conv2dyn(type, "ZIobjtoDyn", NIL, expr.getPos(), ctx)

        CASE Conversion.dyn2bool
        CASE Conversion.dyn2status
        CASE Conversion.dyn2int
        CASE Conversion.dyn2int8
        CASE Conversion.dyn2int16
        CASE Conversion.dyn2int32
        CASE Conversion.dyn2nat
        CASE Conversion.dyn2byte
        CASE Conversion.dyn2nat16
        CASE Conversion.dyn2nat32
        CASE Conversion.dyn2enum
          close = $convFromDyn(exprArg.destType(), "ZDynToV", NIL,
                                                           expr.getPos(), ctx)

        CASE Conversion.dyn2float
          close = $convFromDyn(exprArg.destType(), "ZDynToF", NIL,
                                                           expr.getPos(), ctx)

        CASE Conversion.dyn2byteString
        CASE Conversion.dyn2tuple
        CASE Conversion.dyn2type
        CASE Conversion.dyn2object
        CASE Conversion.dyn2array
        CASE Conversion.dyn2list
        CASE Conversion.dyn2dict
          close = $convFromDyn(exprArg.destType(), "ZDynToP", NIL,
                                                           expr.getPos(), ctx)

        CASE Conversion.dyn2string
          $setDeclUsed(%dynToString)
          ctx.out.write("ZdynToString(")
          close = ")"

        CASE Conversion.dyn2iobject
          ClassType ct = exprArg.destType().getEffType().getClassType(ctx)
          IF ct != NIL
            ctx.out.write("ZaoDyn(")
            close = ", " .. ct.pName .. "__imtt, "
            close ..= "sizeof(" .. ct.pName .. "__imtt) / sizeof(Tc*), (Tt*)&"
            close ..= ct.pName .. "__T, "
            close ..= $getPosNumber(expr.getPos(), ctx) .. ")"
          }

        DEFAULT
          ctx.error("INTERNAL: unsupported conversion: "
                                       .. exprExt.conversion.ToString(), expr)
      }
    }

    ctx.out.append(exprOut)
    ctx.out.write(close)

    IF doClose
      # Write the ) of  (temp = expr)
      ctx.out.write(")")
    }

    RETURN typeConverted == NIL ? type : typeConverted
  }

  # Convert a variable of type |fromClass| to a variable of type |toClass|.
  # This is iobject to iobject.
  # Writes the start of the function and returns a string with the rest.  The
  # caller is expected to write the "from" argument and then the returned
  # string.
  FUNC $convertZorefArgs(ClassType fromClass, ClassType toClass,
                                        Zui.Position pos, SContext ctx) string
    string close = ""
    IF fromClass == NIL
      # This can happen when there is an error in the expression.
      ctx.error("Target class unknown", pos)
    ELSEIF toClass == NIL
      ctx.error("INTERNAL: toClass is NIL", pos)
    ELSE
      # There are two valid situations:
      # 1. destType.getClass() is a parent of fromClass
      #    this always works, add something to the type index
      # 2. destType.getClass() is a child of fromClass
      #    check the type range, subtract something from the type index
      int idx = toClass.childIndex(fromClass, FALSE)
      int maxIdx
      IF idx < 0
        idx = fromClass.childIndex(toClass, FALSE)
        IF idx < 0
          ctx.error("Class type mismatch " .. fromClass.typeName()
                                .. " to " .. toClass.typeName(), pos)
        ELSE
          # 2. destType.getClass() is a child of fromClass
          maxIdx = fromClass.childIndex(toClass, TRUE)
        }
      ELSE
        # 1. destType.getClass() is a parent of fromClass
        idx = -idx
        maxIdx = 99999
      }
      string table = WriteIMT.interfaceMemberTableTableName(toClass)
      close = ", " .. table .. ", " .. idx .. ", " .. maxIdx .. ", "
                                             .. $getPosNumber(pos, ctx) .. ")"
    }
    RETURN close
  }

  FUNC $object2iobject(ClassType symClass, ClassType destClass,
                  string destName, Zui.Position pos, Output out, SContext ctx
                      ) string
    # Need to get the pointer and set the type.  The only way to avoid
    # evaluating the expression twice is by using a function.
    IF destName != NIL
      $setDeclUsed(%noAllocObjectRef)
      out.write("*Znao(&")
      out.write(destName)
      out.write(", ")
    ELSE
      $setDeclUsed(%allocObjectRef)
      out.write("Zao(")
    }
    string tableName = Declaration.interfaceMemberTableName(
                                                     symClass, destClass, ctx)
    int idx = destClass.childIndex(symClass, FALSE)
    IF idx < 0
      string destClassName = destClass.typeName()
      IF destClass.ttype != Type.Enum.interface
        destClassName ..= ".I"
      }
      ctx.error("Cannot convert " .. symClass.typeName()
                                              .. " to " .. destClassName, pos)
    }
    RETURN ", " .. tableName .. ", " .. idx .. ")"
  }

  # Assign in iobject to an iobject of the same type that is not allocated
  FUNC $object2noalloc(Declaration dest, Output out) string
    out.write("(")
    out.write(dest.pName)
    out.write(" = ")
    RETURN ")"
  }

  FUNC $iobjectType(Zui.Expression lhs, Type type, Type exprType,
                                                             SContext ctx) int
    # Set the type of the i_object.
    # TODO: if this is a different i_object the type will change.
    ctx.out.write("; ")
    Generate.generateVarname(lhs, ctx, NIL)
    ctx.out.write("->type = ")
    int idx = type.getClassType(ctx).childIndex(exprType.getClassType(ctx),
                                                                        FALSE)
    IF idx < 0
      IF ctx.doError()
        ctx.error("Type mismatch, expression result does not match the destination class", lhs)
      }
    }
    ctx.out.write("" .. idx)
    RETURN 0
  }

  # Write lines to "myOuts" to include the generated code for imported
  # files.
  PROC $writeIncludeImport(ZimbuFile import, Scope scope, Output.Group myOuts)
    # Add function for inits to bodies
    $writeInits(import, import.c.outputs)

    myOuts.imtInitOut.append(import.c.outputs.imtInitOut)

    # Include the code of the imported file in the current file.
    string pre = "/* including " .. import.rootName
    string done = "/* " .. import.rootName .. " done */\n"

    IF !import.c.outputs.typeOut.empty()
      myOuts.typeOut.write(pre .. " typedefs */\n")
      myOuts.typeOut.append(import.c.outputs.typeOut)
      myOuts.typeOut.write(done)
    }

    IF !import.c.outputs.structOut.empty()
      myOuts.structOut.write(pre .. " structs */\n")
      myOuts.structOut.append(import.c.outputs.structOut)
      myOuts.structOut.write(done)
    }

    IF !import.c.outputs.declOut.empty()
      myOuts.declOut.write(pre .. " declarations */\n")
      myOuts.declOut.append(import.c.outputs.declOut)
      myOuts.declOut.write(done)
    }

    IF !import.c.outputs.bodyOut.empty()
      myOuts.bodyOut.write(pre .. " bodies */\n")
      myOuts.bodyOut.append(import.c.outputs.bodyOut)
      myOuts.bodyOut.write(done)
    }

    IF !(import.c.outputs.earlyInitOut.empty()
                                          && import.c.outputs.initOut.empty())
      # Call the init function.
      myOuts.initOut.write(" done &= " .. import.initFunc .. "(round);\n")
    }
  }

  # Add function for inits to bodies
  PROC $writeInits(ZimbuFile import, Output.Group outputs)
    IF outputs.earlyInitOut.empty() && outputs.initOut.empty()
      RETURN
    }
    outputs.declOut.write("int " .. import.initFunc .. "(int round);\n")

    Output bodyOut = outputs.bodyOut
    bodyOut.write("int " .. import.initFunc .. "(int round) {\n")
    bodyOut.write(" static int round_done = -1;\n")
    bodyOut.write(" int done = 1;\n")

    # Write any temp variables used in init expressions.
    MethodScope ms = import.initScope
    IF ms != NIL && ms.tempVars != NIL
      FOR decl IN ms.tempVars
        bodyOut.write(" ")
        bodyOut.write($vartypeString(decl.type, TRUE, decl.zuiPos, NIL))
        bodyOut.write(decl.pName)
        bodyOut.write(";\n")
      }
    }

    bodyOut.write(" if (round_done < round) {\n")
    IF !Config.noBacktrace || $manageMemory()
      bodyOut.write($stackDeeper("  "))
    }
    IF !Config.noBacktrace || $manageMemory()
      bodyOut.write($initStackFrame("  ", TRUE, NIL))
    }
    bodyOut.write("  round_done = round;\n")

    IF !outputs.earlyInitOut.empty()
      IF outputs.earlyInitLead != NIL
        bodyOut.write(outputs.earlyInitLead)
      }
      bodyOut.append(outputs.earlyInitOut)
      IF outputs.earlyInitLead != NIL
        bodyOut.write("  }\n")
      }
    }

    IF !outputs.initOut.empty()
      IF outputs.initLead != NIL
        bodyOut.write(outputs.initLead)
      }
      bodyOut.append(outputs.initOut)
      IF outputs.initLead != NIL
        bodyOut.write("  }\n")
      }
    }

    IF !Config.noBacktrace || $manageMemory()
      bodyOut.write("  ")
      bodyOut.write($stackBack())
    }
    bodyOut.write(" }\n")
    bodyOut.write(" return done;\n")
    bodyOut.write("}\n")
  }

  # Write after imports, before inits of the file itself.
  PROC $afterImports(Scope scope, Output.Group outs)
    string earlyInit
    string init
    IF scope.scopeType == Scope.Stype.libModule
      earlyInit =  " if (round == 0) {\n"
      init = "  if (round == 0) {\n"
    ELSE
      earlyInit = " if (round == 1) {\n"
      init = " if (round == 2001) {\n"
    }
    IF outs.earlyInitOut.empty()
      outs.earlyInitLead = earlyInit
    ELSE
      outs.earlyInitLead = ""
      outs.earlyInitOut.write(earlyInit)
    }
    IF outs.initOut.empty()
      outs.initLead = init
    ELSE
      outs.initLead = ""
      outs.initOut.write(init)
    }
  }

  # Write after inits of the file itself.
  PROC $afterGenerate(UsedFile usedFile, Output.Group outs, SContext ctx)
    Scope scope = usedFile.scope()
    IF scope.declDict != NIL
      FOR early IN [TRUE, FALSE]
        bool didElse
        Declaration initDecl
        FOR declList IN scope.declDict.values()
          FOR decl IN declList
            $classInit(decl, early, outs, &didElse, ctx)
            IF usedFile.zimbuFile.isMainFile
                     && decl.type.ttype == Type.Enum.func
                     && (decl.name == (early ? "EarlyInit" : "Init"))
              initDecl = decl
            }
          }
        }
        # The main file can have an EarlyInit() and Init() function at the
        # toplevel.
        IF usedFile.zimbuFile.isMainFile
          $writeInitLine(initDecl, early, outs, &didElse)
        }
      }
    }

    # In the main file write the static direct ref structs.
    IF usedFile.zimbuFile.isMainFile
      $writeDirectRefs(outs, ctx)
    }
  }

  # Write the direct referenced function structs.
  PROC $writeDirectRefs(Output.Group outs, SContext ctx)
    bool used
    FOR decl IN directRefs.keys()
      IF $isDeclUsed(decl)
        used = TRUE
        BREAK
      }
    }
    IF used || $isDeclUsed(Declaration.funcRef) || !Generate.skipUnused()
      outs.typeOut.write("typedef struct Tcallback__S Tcb;\n")
      outs.structOut.write("struct Tcallback__S {\n")
      outs.structOut.write($callbackHead())
      outs.structOut.write("};\n")
      IF $manageMemory()
        # Also produce the code in GC marking.
        Declaration.funcRef.setUsed(c)
        outs.typeOut.write("typedef struct Tcallbackx__S Tcbx;\n")
        outs.structOut.write("struct Tcallbackx__S {\n")
        outs.structOut.write($callbackHead())
        outs.structOut.write(" Tcb *cb;\n")
        outs.structOut.write(" To to[1];\n")  # may be another size
        outs.structOut.write("};\n")
      }

      IF used || !Generate.skipUnused()
        outs.declOut.write("/*** callbacks for methods invoked directly ***/\n")
        FOR decl IN directRefs.keys().sort()
          IF $isDeclUsed(decl)
            $writeCallbackFunc(NIL, NIL, decl, decl.zuiPos, ctx)
            outs.declOut.write("Tcb " .. directRefName(decl.pName) .. " = {"
                .. ($hasNpField() ? "0, " : "")   # np
                .. "Zcb" .. decl.pName            # cfunc
                .. ", -1};\n")                    # toCount = -1
          }
        }
      }
    }
  }

  # Return the first fields of a callback struct.  This is the same as for a
  # "Tcb", a callback without extra arguments.
  FUNC $callbackHead() string
    string s = $hasNpField() ? linkedDecl : ""
    s ..= " void *cfunc;\n int toCount;\n"
    RETURN s
  }


  # Write code for initialization, Init() function call.
  # And recurse into nested classes and methods.
  PROC $classInit(Declaration decl, bool early,
                               Output.Group outs, bool &didElse, SContext ctx)
    Type type = decl.type
    # Only do modules and do a class if it is not a template.
    IF (type.ttype == Type.Enum.class || type.ttype == Type.Enum.module)
          && !(decl.zuiDecl != NIL && decl.zuiDecl.hasType()
                   && decl.zuiDecl.getType().getType() == Zui.TypeEnum.eALIAS)
          && (type.getClassType(ctx) == NIL
                                || type.getClassType(ctx).templateList == NIL)
          && decl.pName != NIL
          && (!Generate.skipUnused() || $isDeclUsed(decl))
      Declaration initDecl = type.findMember(early ? "EarlyInit" : "Init", NIL)
      IF initDecl != NIL && initDecl.type.ttype == Type.Enum.func
        $writeInitLine(initDecl, early, outs, didElse)
      }

      # Do nested classes and modules
      VAR declDict = type.getDeclDict()
      IF declDict != NIL
        FOR ndeclList IN declDict.values()
          FOR ndecl IN ndeclList
            $classInit(ndecl, early, outs, didElse, ctx)
          }
        }
      }
    }
  }

  # Write code for one initialization, EarlyInit() or Init() function call.
  PROC $writeInitLine(Declaration init, bool early,
                                             Output.Group outs, bool &didElse)
    IF init == NIL
      # There is no Init() function, the module is always ready.
      RETURN
    }

    string readyName = init.pName
    IF early
      readyName ..= "__e"
    ELSE
      readyName ..= "__r"
    }

    Output out = early ? outs.earlyInitOut : outs.initOut

    # The module or class defines an Init() function.
    # In the first round reset "done" but don't call it yet.
    # In following rounds call it until it returns OK.
    IF !didElse
      out.write("  done = 0;\n")
      IF early
        out.write("  } else if (round > 1 && round < 2000) {\n")
      ELSE
        out.write("  } else if (round > 2001) {\n")
      }
      didElse = TRUE
    }
    out.write("    if (" .. readyName .. " == 0) {\n")
    out.write("      " .. readyName .. " = "
                                             .. init.pName .. "();\n")
    out.write("      done &= " .. readyName .. ";\n")
    out.write("    }\n")
  }

  FUNC $needWrite(ZimbuFile zimbuFile) bool
    IF zimbuFile.c.startedWrite != NIL
      RETURN FALSE
    }
    zimbuFile.c.startedWrite = "yes"
    RETURN TRUE
  }

  PROC $writeClassDef(string name, string comment, Output typeOut)
    typeOut.write("typedef struct " .. name .. "__S " .. name .. "; /* "
        .. comment .. " */\n")
  }

  # Get the head of a object struct.  Has a newline at the start.
  FUNC $getStructHead() string
    IF $hasNpField()
      RETURN " Zoh *np;\n"
    }
    RETURN ""
  }

  # Write class declaration. |structOut| has the body.
  PROC $writeClassDecl(ClassType classType, Output.Group outs,
                                               Output structOut, SContext ctx)
    string name = classType.pName
    outs.structOut.write("struct " .. name .. "__S {\n")

    # If the class has a Finish method, need a flag that is TRUE when Finish
    # returned OK.
    IF Generate.getFinishMethod(classType.scope, ctx) != NIL
                                         && $isDeclUsed(Declaration.hasFinish)
      IF $hasNpField()
        outs.structOut.write(linkedDecl)
      }
      outs.structOut.write(finishDecl)
    ELSE
      outs.structOut.write($getStructHead())
    }

    outs.structOut.append(structOut)
    outs.structOut.write("};\n")

    # We need a forward declaration.
    outs.structOut.write("extern Tto ")
    outs.structOut.write(name)
    outs.structOut.write("__T;\n")
  }

  # Write the default init value for |type|.
  PROC $defaultInit(Type type, Output out)
    IF type.ttype == Type.Enum.iobject || type.ttype == Type.Enum.dyn
      out.write("{NULL}")
    ELSEIF type.isNoAlloc()
      IF $hasNpField()
        out.write("{NULL}")
      ELSE
        out.write("{}")
      }
    ELSE
      SWITCH type.ttype
        CASE Type.Enum.class
        CASE Type.Enum.iobject
        CASE Type.Enum.string
        CASE Type.Enum.byteString
        CASE Type.Enum.array
        CASE Type.Enum.list
        CASE Type.Enum.dict
          out.write("NULL")
        CASE Type.Enum.multiple
          out.write("{}")
        DEFAULT
          out.write("0")
      }
    }
  }

  PROC $nil(Declaration dest, SContext ctx)
    Type destType = dest.type
    Output out = ctx.out

    bool hasFinish
    IF destType.isNoAlloc()
      ClassType ct = destType.getClassType(ctx)
      IF ct != NIL
        hasFinish = Generate.getFinishMethod(ct.scope, ctx) != NIL
      }
    }

    IF $isIobject(destType)
      IF hasFinish
        out.write("ZnoAllocNilIobj(&")
        out.write(dest.pName)
        out.write(")")
        $setDeclUsed(%noAllocNilIobj)
      ELSE
        out.write("trZero")
      }
    ELSEIF destType.isNoAlloc()
      out.write("ZnoAllocNil(&")
      out.write(dest.pName)
      ClassType ct = destType.getClassType(ctx)
      IF ct != NIL && Generate.getFinishMethod(ct.scope, ctx) != NIL
        out.write(", 1)")
      ELSE
        out.write(", 0)")
      }
      $setDeclUsed(%noAllocNil)
    ELSEIF destType.getTtype() == Type.Enum.dyn
      out.write("txZero")
    ELSE
      out.write("NULL")
    }
  }

  PROC $writeNilValue(Type type, Output out)
    IF type.isValueType()
      out.write("0")
    ELSEIF $isIobject(type)
      out.write("trZero")
    ELSEIF type.getTtype() == Type.Enum.dyn
      out.write("txZero")
    ELSE
      out.write("NULL")
    }
  }

  PROC $writeNilReturn(SContext ctx, Output out)
    out.writeIndent(ctx.scope.depth)
    out.write("return ")
    $writeNilValue(ctx.scope.returnType, out)
    out.write(";\n")
  }

  # Write the value used for INF.
  PROC $inf(SContext ctx)
    $setDeclUsed(%math)
    ctx.out.write("INFINITY")
  }

  # Write the value used for NINF.
  PROC $ninf(SContext ctx)
    $setDeclUsed(%math)
    ctx.out.write("-INFINITY")
  }

  # Write the value used for NAN.
  PROC $nan(SContext ctx)
    $setDeclUsed(%math)
    ctx.out.write("NAN")
  }

  # Write an expression and wrap it, when needed, for the ?. operator.
  FUNC $wrapExpr(Zui.Expression expr, SContext ctx, Type destType) Type
    RETURN $wrapExprConv(expr, ctx, NEW(destType, FALSE))
  }

  # Write an expression and wrap it, when needed, for the ?. operator.
  FUNC $wrapExprConv(Zui.Expression expr, SContext ctx, ExprArg exprArg) Type
    Output exprOut = NEW()
    exprOut.writing = ctx.out.writing
    Type ret = Generate.genExprConv(expr, ctx.copy(exprOut), exprArg)
    $wrapExprOutput(exprOut, FALSE, NIL, expr.getPos(), ret, ret, ctx)
    RETURN ret
  }

  # Wrap an expression when needed for the ?. operator when |dotnil| is TRUE.
  # Append |member| when it is not NIL.
  PROC $wrapExprOutput(Output exprOut, bool dotnil, string member,
                   Zui.Position pos, Type objType, Type retType, SContext ctx)
    IF dotnil
      # var?.member ->  ((pname = var) ? pname->member : NULL)
      # TODO: if exprOut is a variable name no temp var is needed.
      string pname = getUid(ctx.scope.scopeName)
      ctx.outs.varOut.writeIndent(ctx.scope.depth)
      $vartype(objType, TRUE, pos, ctx.outs.varOut, ctx)
      ctx.outs.varOut.write(pname .. ";\n")

      ctx.out.write("((")
      ctx.out.write(pname)
      ctx.out.write(" = ")
      ctx.out.append(exprOut)
      ctx.out.write(") ? ")
      ctx.out.write(pname)
      IF member != NIL
        ctx.out.write(member)
      }
      ctx.out.write(" : ")
      $writeNilValue(retType, ctx.out)
      ctx.out.write(")")
    ELSE
      ctx.out.append(exprOut)
      IF member != NIL
        ctx.out.write(member)
      }
    }
  }

  bool $generatingArg

  FUNC $genArg(Zui.Expression arg, SContext ctx, Type destType) Type
    $generatingArg = TRUE
    Type r
    IF destType == NIL
      r = Generate.genExpr(arg, ctx)
    ELSE
      r = Generate.genExpr(arg, ctx, destType)
    }
    $generatingArg = FALSE
    RETURN r
  }

  PROC $writeArgExpr(Zui.Expression arg, SContext ctx, Type destType)
    Output exprOut = NEW()
    exprOut.writing = ctx.out.writing
    $generatingArg = TRUE
    Generate.genTopExprDoConv(arg, ctx.copy(exprOut), destType)
    $generatingArg = FALSE
    ctx.out.append(exprOut)
  }

  PROC $member(Output varnameOut, Zui.Position pos,
           Type objType, Type retType, bool dotnil, string name, SContext ctx)
    string memberAccess = (objType.getTtype() == Type.Enum.iobject
                                                         ? "." : "->") .. name
    $wrapExprOutput(varnameOut, dotnil, memberAccess, pos,
                                                        objType, retType, ctx)
  }

  PROC $toStringFuncCast(SContext ctx)
    ctx.out.write("(Tc * (*)(void*))")
  }

  # Generate an argument for calling ToString on an iobject.
  # This is the index for ToString() in the iobject table.
  PROC $iobjectUseFunc(string what, Zui.Position pos, int &undef, Type type,
                                               Declaration func, SContext ctx)
    # Only used to mark the methods as used.
  }

  FUNC $varsInMethodScope() bool
    RETURN TRUE
  }

  # Write the declaration and init of a variable.
  PROC $declaration(Declaration.C decl,
                    Type valueType,
                    Zui.Statement stmt,
                    bool isShared,
                    Output initExprOut,
                    bool initIsConstant,
                    SContext ctx)
    Output     varOut = ctx.outs.varOut      # output for declaring vars
    IF isShared
      # A variable in a SHARED section is written among the declarations.
      varOut = ctx.outs.declOut
    }
    SContext   varCtx = ctx.copy(varOut)
    Scope      scope = ctx.scope
    bool staticVar = scope.scopeName == NIL
                  || scope ISA ModuleScope
                  || scope.scopeType == Scope.Stype.shared
                  || isShared
    bool initWithDecl = staticVar && initIsConstant
    Zui.Declaration zuiDecl = stmt.getDeclaration()

    # 1. Write the declaration of the variable at the start of the block.
    #    Only when not written at the start of a method.
    bool didDefaultInit
    IF decl.inMethodScope && !isShared
      # Check if the statement can be encountered twice, e.g. inside a loop.
      Scope s = ctx.scope
      WHILE s != NIL
        IF s.scopeType == Scope.Stype.for
            || s.scopeType == Scope.Stype.while
            || s.scopeType == Scope.Stype.do
            || s.scopeType == Scope.Stype.unknown
          BREAK
        }
        IF s ISA MethodScope
          didDefaultInit = TRUE
          BREAK
        }
        s = s.outer
      }
    ELSE
      didDefaultInit = $writeDeclaration(decl, scope, staticVar,
                                          FALSE, initWithDecl, varOut, varCtx)
    }

    # 2. Write the init or assignment.
    IF scope.isInitVar()
      Output iOut = ctx.out
      bool setPos
      int indent
      IF initWithDecl
        iOut = varOut
      ELSEIF staticVar
        # For global variables and for variables in a module write to the
        # ZglobInit() or I{module}() function.
        # IO.eof is written with an #ifdef.
        # Don't write anything for an abstract class.
        IF decl.scopeName == "MIOModule" && zuiDecl.getName() == "eof"
                  || (scope.classType != NIL && scope.classType.isAbstract())
          iOut = Output.noOut
        ELSEIF (zuiDecl.getType().hasAttr()
                                && zuiDecl.getType().getAttr().getEarlyInit())
                     || ((decl.type.ttype == Type.Enum.object
                            || decl.type.ttype == Type.Enum.iobject)
                         && (decl.type.zuiAttr != NIL
                                        && decl.type.zuiAttr.getEarlyInit()))
          iOut = ctx.outs.earlyInitOut
          setPos = TRUE
        ELSE
          iOut = ctx.outs.initOut
          setPos = TRUE
        }
        indent = 3
      ELSE
        # TODO: Only write the position when the init is not a constant.
        IF initExprOut != NIL && !isShared
          $beforeStatement(zuiDecl.getInit().getPos(), stmt, ctx)
        }
        indent = scope.depth
      }

      IF valueType.isAllocType(ctx)
        didDefaultInit = FALSE     # always init below
        setPos = TRUE              # allocating memory
        ZuiStatementExt.get(stmt).props.allocMem = TRUE
      }

      IF $isIobject(decl.type) && initExprOut == NIL && !didDefaultInit
        # Re-init an iobject, set the pointer to NULL.
        iOut.writeIndent(indent)
        iOut.write(decl.pName)
        iOut.write(".ptr = NULL;\n")
      ELSEIF decl.type.getTtype() == Type.Enum.dyn
                                      && initExprOut == NIL && !didDefaultInit
        # Re-init a dyn, set the type to NULL.
        iOut.writeIndent(indent)
        iOut.write(decl.pName)
        iOut.write(".type = NULL;\n")
      ELSEIF initExprOut != NIL || !didDefaultInit
        # Write the init when not yet done above.
        IF setPos && !initWithDecl
          iOut.writeIndent(indent)
          $writeSetStackPos(zuiDecl.getPos(),
                                           $needPauseGC(stmt), ctx.copy(iOut))
          iOut.write(";\n")
        }

        IF decl.type.isNoAlloc()
          # Init the not allocated object with a function call, it's not
          # assigned to the variable.
          iOut.writeIndent(indent)
        ELSE
          IF !initWithDecl
            iOut.writeIndent(indent)
            iOut.write(decl.pName)
          }
          iOut.write(" = ")
        }

        IF valueType.isAllocType(ctx)
          # This is a variable used in a "USE &" argument, it is a class
          # with the actual variable as a member.  Need to allocate the
          # object.
          string className = valueType.getClassType(ctx).pName
          $writeAlloc(className, NIL, iOut, ctx)
          IF initExprOut != NIL
            iOut.write(";\n")
            iOut.writeIndent(indent)
            iOut.write(decl.pName)
            iOut.write("->Vm = ")
            iOut.append(initExprOut)
          }
        ELSEIF initExprOut == NIL
          # No assignment, default init: NIL, FALSE, zero.
          $defaultInit(valueType, iOut)
        ELSE
          # Write the code for the expression, generated previously.
          iOut.append(initExprOut)
        }
        IF initWithDecl
          $declComment(scope.scopeName, decl, iOut)
        }
        iOut.write(";\n")
      }

      # For a not allocated iobject the declaration above is for a "Tr"
      # object. Now we also need to declare the object itself.
      IF decl.type.isNoAlloc() && decl.type.getTtype() == Type.Enum.iobject
                               && !decl.type.<NoAllocType>.needAlloc()
        varOut.write(" ")
        varOut.write($vartypeString(decl.type.getClassType(ctx),
                                              TRUE, TRUE, stmt.getPos(), ctx))
        varOut.write(decl.pName)
        IF $hasNpField()
          varOut.write("_o = {NULL};\n")
        ELSE
          varOut.write("_o = {};\n")
        }
      }

      IF (!scope.hasStatements() || isShared) && $manageMemory()
        # Add static variables to a list.  Ones that may point to allocated
        # memory in $staticVars and ones that point to static memory but may
        # contain pointers to allocated mememory in $noallocVars.
        IF decl.type.isManaged()
          IF $staticVars == NIL
            $staticVars = NEW()
          }
          $staticVars.add(decl)
        ELSE
          int undef
          IF getArgumentType(decl.type, stmt.getPos(), &undef, ctx) >= 300
            IF $noallocVars == NIL
              $noallocVars = NEW()
            }
            $noallocVars.add(decl)
          }
        }
      }
    }
  }

  # Write the declaration of |decl| to |ctx|.out.
  # Return TRUE if the default init was written.
  FUNC $writeDeclaration(Declaration.C decl,
                    Scope scope,
                    bool isGlobal,
                    bool forceInit,
                    bool initWithDeclaration,
                    Output out,
                    SContext ctx) bool
    IF scope.outer != NIL && !isGlobal
      ctx.out.writeIndent(scope.depth)
    }
    $vardecl(decl, ctx)

    # If this is a module variable or a class SHARED variable init it to 0 or
    # NIL.
    # Also in a block when there is a goto label and it is a pointer.
    # Also for a global variable that is not allocated, need to mark it as not
    # initialized.
    # Not when writing the init next.
    bool didDefaultInit
    IF !initWithDeclaration
      Type type = decl.type.getValueType(ctx)
      IF forceInit || (!scope.hasStatements() && scope.isInitVar())
                   || (scope.retLabel != NIL && !type.isValueType())
                   || (isGlobal && type.isNoAlloc())
        ctx.out.write(" = ")
        $defaultInit(type, ctx.out)
        didDefaultInit = TRUE
      }

      ctx.out.write(";")
      $declComment(scope.scopeName, decl, ctx.out)
      ctx.out.write("\n")
    }
    RETURN didDefaultInit
  }

  # Write the type of |decl| and its name: "Tc *Vname".
  PROC $vardecl(Declaration.C decl, SContext ctx)
    IF decl.isUsedInTry && ctx.scope.hasStatements()
      # The optimizer may put local variables in a register, which gets messed
      # up if longjmp() goes back to the setjmp().
      ctx.out.write("volatile ")
    }
    $vartype(decl.type, TRUE, decl.zuiPos, ctx)

    # Output variable name.
    ctx.out.write(decl.pName)

    IF decl.scopeName == "MIOModule" && decl.name == "eof"
      # IO.eof is #defined, don't declare it.
      ctx.out.write("__NOT")
    }
  }

  PROC $vartype(Type type, bool useSpace, Zui.Position pos, SContext ctx)
    $vartype(type, useSpace, pos, ctx.out, ctx)
  }

  # Write the type of a variable or return value to |out|.
  # |pos| may be NIL.
  # When |useSpace| is TRUE add a space before the "*" or after the type.
  # Use that for declarations, use FALSE for type casts.
  PROC $vartype(Type type, bool useSpace,
                                   Zui.Position pos, Output out, SContext ctx)
    IF !out.writing
      RETURN
    }
    out.write($vartypeString(type, useSpace, pos, ctx))
  }

  # Note: |ctx| can be NIL
  FUNC $vartypeString(Type type, bool useSpace,
                                        Zui.Position pos, SContext ctx) string
    RETURN $vartypeString(type, useSpace, type?.isNoAlloc(), pos, ctx)
  }

  # Return TRUE when not using a pointer for |type|.
  FUNC $isIobject(Type type) bool
    Type.Enum ttype = type.getTtype()
    RETURN (ttype == Type.Enum.iobject || ttype == Type.Enum.interface)
  }


  # Note: |ctx| can be NIL
  FUNC $vartypeString(Type type, bool useSpace, bool notAllocated,
                                        Zui.Position pos, SContext ctx) string
    IF type == NIL || type.ttype == Type.Enum.unknown
      RETURN useSpace ? "void " : "void"
    }

    Type etype = type.getEffType()
    string maybeStar = notAllocated ? (useSpace ? " " : "")
                                                     : (useSpace ? " *" : "*")
    SWITCH etype.getTtype()
      CASE Type.Enum.nilval
          RETURN useSpace ? "void *" : "void*"
      CASE Type.Enum.class
      CASE Type.Enum.classDotC
      CASE Type.Enum.object
          IF ctx != NIL && etype.isAbstract() && ctx.doError()
            ctx.error("Cannot use abstract class " .. etype.name, pos)
          }
          IF etype.getClassType(ctx) != NIL
            RETURN etype.getClassType(ctx).getClassName() .. maybeStar
          }
          IF ctx != NIL
            ctx.error("INTERNAL: no class name for "
                                                  .. etype.typeToString(), pos)
          }
      CASE Type.Enum.interface
      CASE Type.Enum.iobject
          RETURN "Tr" .. (useSpace ? " " : "")  # never use a star
      CASE Type.Enum.array
          RETURN "Ta" .. maybeStar
      CASE Type.Enum.list
          RETURN "Tl" .. maybeStar
      CASE Type.Enum.dict
          RETURN "Td" .. maybeStar
      CASE Type.Enum.tuple
          RETURN etype.pName .. maybeStar
      CASE Type.Enum.multiple
          RETURN etype.pName .. " "
      CASE Type.Enum.proc
      CASE Type.Enum.func
      CASE Type.Enum.procRef
      CASE Type.Enum.funcRef
          RETURN "Tcb" .. maybeStar
      CASE Type.Enum.callback
          RETURN etype.pName .. maybeStar
      CASE Type.Enum.string
      CASE Type.Enum.byteString
          RETURN "Tc" .. maybeStar
      CASE Type.Enum.varString
      CASE Type.Enum.varByteString
          ctx.setDeclUsed(%varByteStringType)
          RETURN "Ty" .. maybeStar
      CASE Type.Enum.byRef
          RETURN $vartypeString(etype.<ReferenceType>.reference,
                                                 FALSE, pos, ctx) .. maybeStar
      CASE Type.Enum.dyn
          RETURN "Tx" .. (useSpace ? " " : "")  # never use a star
      CASE Type.Enum.type
          RETURN "Tt" .. maybeStar

      CASE Type.Enum.bool
          RETURN useSpace ? "Tb " : "Tb"
      CASE Type.Enum.status
          RETURN useSpace ? "Ts " : "Ts"
      CASE Type.Enum.bits
          RETURN etype.<BitsType>.valueType == Type.Enum.int
                   ? (useSpace ? "Tbb " : "Tbb") : (useSpace ? "Tbs " : "Tbs")
      CASE Type.Enum.bitsValue
          RETURN etype.<BitsValueType>.bitsType.valueType == Type.Enum.int
                   ? (useSpace ? "Tbb " : "Tbb") : (useSpace ? "Tbs " : "Tbs")
      CASE Type.Enum.enum
      CASE Type.Enum.enumValue
          RETURN useSpace ? "Te " : "Te"
      CASE Type.Enum.int
      CASE Type.Enum.intval
          RETURN useSpace ? "Ti " : "Ti"
      CASE Type.Enum.int8
          RETURN useSpace ? "char " : "char"
      CASE Type.Enum.int16
          RETURN useSpace ? "Ti16 " : "Ti16"
      CASE Type.Enum.int32
          RETURN useSpace ? "Ti32 " : "Ti32"
      CASE Type.Enum.nat
      CASE Type.Enum.natval
          RETURN useSpace ? "Tu " : "Tu"
      CASE Type.Enum.byte
          RETURN useSpace ? "Tc " : "Tc"
      CASE Type.Enum.nat16
          RETURN useSpace ? "Tu16 " : "Tu16"
      CASE Type.Enum.nat32
          RETURN useSpace ? "Tu32 " : "Tu32"
      CASE Type.Enum.float
      CASE Type.Enum.floatval
      CASE Type.Enum.float80    # TODO
      CASE Type.Enum.float128   # TODO
          RETURN useSpace ? "Tf " : "Tf"
      CASE Type.Enum.float32
          RETURN useSpace ? "Tf32 " : "Tf32"
      CASE Type.Enum.ctype
          RETURN useSpace ? etype.getCtypeName() .. " " : etype.getCtypeName()
    }

    IF ctx != NIL && ctx.doError()
      ctx.error("Declaration of unknown type " .. etype.typeName(), pos)
#            LOG.reportStack()
    }
    RETURN useSpace ? "void *" : "void*"
  }

  PROC $enum(Zui.Declaration zuiDecl, EnumType enumType, SContext ctx)
    Output out = ctx.outs.declOut
    IF !$isDeclUsed(enumType) || !out.writing
      RETURN
    }

    bool useValueName = (enumType.usedValueName != NIL
                                        && $isDeclUsed(enumType.usedValueName))
                       || $isDeclUsed(Type.aDyn)
    string tcName
    IF enumType.usedEnumName != NIL && $isDeclUsed(enumType.usedEnumName)
      tcName = $writeStaticString(enumType.name, ctx)
    }
    out.write("Tt " .. enumType.pName .. "__T = {23, ")
    IF tcName != NIL
      out.write("((Tc*)&")
      out.write(tcName)
      out.write(")")
    ELSE
      out.write("0")
    }
    out.write(", ")
    IF useValueName
      out.write(enumType.pName .. "__name")
    ELSE
      out.write("0")
    }
    out.write("};\n")

    IF useValueName
      out = ctx.outs.structOut
      out.write("char *" .. enumType.pName .. "[] = {\n")
      Zui.EnumType enum = zuiDecl.getType().getEnumDecl()
      out.write(" (char*)" .. enum.sizeItem() .. ",\n")
      FOR item IN enum.getItemList()
        out.write(" \"" .. item.getName() .. "\",\n")
      }
      out.write("};\n")
      out.write("char *" .. enumType.pName .. "__name(Te n) {\n")
      out.write(" return (n < 0 || n >= (Te)(size_t)")
      out.write(enumType.pName)
      out.write("[0]) ? \"INVALID\" : ")
      out.write(enumType.pName)
      out.write("[n + 1];\n")
      out.write("};\n")
    }
  }

  FUNC $enumName(EnumValueType type, SContext ctx) string
    $setDeclUsed(%enum2string)
    ctx.out.write("Zenum2string(")
    ctx.out.write(type.enumType.pName)
    ctx.out.write(", ")
    RETURN ")"
  }

  FUNC $enumFromString(EnumType type, SContext ctx) string
    $setDeclUsed(%enumFromString)
    ctx.out.write("ZenumFromString(")
    ctx.out.write(type.pName)
    ctx.out.write(", ")
    RETURN ")"
  }

  # A bits declaration.
  PROC $bits(Zui.Declaration zuiDecl, BitsType bitsType, SContext ctx)
# TODO: not always needed, only when used in container
#    IF bitsType.usedBitsName != NIL && $isDeclUsed(bitsType.usedBitsName)
      string tcName = $writeStaticString(bitsType.name, ctx)
      Output out = ctx.outs.declOut
      out.write("Tt " .. bitsType.pName .. "__T = {25, ")
      out.write("((Tc*)&")
      out.write(tcName)
      out.write(")")
      out.write(", 0};\n")
#    }
  }

  PROC $intAsByteString(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%intAsByteString)
    ctx.out.write("ZintAsByteString(")
    IF expr.getType() == Zui.ExprType.eINT
      ctx.out.write(expr.getNumber() .. "")
    ELSE
      genExpr(expr, ctx, Type.anInt)
    }
    ctx.out.write(")")
  }

  PROC $intAsString(Zui.Expression expr, SContext ctx)
    ctx.out.write("ZintAsString(")
    IF expr.getType() == Zui.ExprType.eINT
      ctx.out.write(expr.getNumber() .. "")
    ELSE
      genExpr(expr, ctx, Type.anInt)
    }
    ctx.out.write(")")
  }

  PROC $stringFormat(Zui.Expression expr, Zui.Expression arg, SContext ctx)
    $setDeclUsed(%stringFormat)
    ctx.out.write("ZStringFormat(")
    genExpr(expr, ctx, Type.aString)
    ctx.out.write(", ")
    genExpr(arg, ctx, Type.aString)
    ctx.out.write(")")
  }

  PROC $intToString(Zui.Expression expr, Zui.Expression format,
                                                      Type type, SContext ctx)
    IF format == NIL
      $setDeclUsed(%int2string)
      ctx.out.write("Zint2string(")
    ELSE
      $setDeclUsed(%intFormat)
      ctx.out.write("ZintFormat(")
      genExpr(format, ctx, Type.aString)
      ctx.out.write(", ")
    }
    IF expr.getType() == Zui.ExprType.eINT
      ctx.out.write(expr.getNumber() .. "")
    ELSEIF type.ttype == Type.Enum.bits
      Type ret = genExpr(expr, ctx)
      IF ret.getTtype() != Type.Enum.bitsValue && ctx.doError()
        ctx.error("Expected bits value", expr)
      }
    ELSE
      genExpr(expr, ctx, type)
    }
    ctx.out.write(")")
  }

  PROC $natToString(Zui.Expression expr, Zui.Expression format,
                                                      Type type, SContext ctx)
    IF format == NIL
      $setDeclUsed(%nat2string)
      ctx.out.write("Znat2string(")
    ELSE
      $setDeclUsed(%natFormat)
      ctx.out.write("ZnatFormat(")
      genExpr(format, ctx, Type.aString)
      ctx.out.write(", ")
    }
    IF expr.getType() == Zui.ExprType.eNAT
      nat n = expr.getNumber()  # remove the sign bit
      ctx.out.write(n .. "")
    ELSE
      genExpr(expr, ctx, type)
    }
    ctx.out.write(")")
  }

  PROC $floatSize(Zui.Expression expr, Type type, SContext ctx)
    SWITCH type.ttype
      CASE Type.Enum.float
        ctx.out.write("8")
      CASE Type.Enum.float32
        ctx.out.write("4")
      CASE Type.Enum.float80
        ctx.out.write("10")  # TODO: figure out padding
      CASE Type.Enum.float128
        ctx.out.write("16")
      DEFAULT
        LOG.internal("float Size() type not recognized: \(type.typeName())")
    }
  }

  PROC $floatToString(Zui.Expression expr, Zui.Expression format,
                                                      Type type, SContext ctx)
    IF format == NIL
      $setDeclUsed(%float2string)
      ctx.out.write("Zfloat2string(")
    ELSE
      $setDeclUsed(%floatFormat)
      ctx.out.write("ZfloatFormat(")
      genExpr(format, ctx, Type.aString)
      ctx.out.write(", ")
    }
    IF expr.getType() == Zui.ExprType.eINT
      ctx.out.write(expr.getNumber() .. "")
    ELSE
      genExpr(expr, ctx, type)
    }
    ctx.out.write(")")
  }

  # float.isNan()
  PROC $isNan(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%math)
    ctx.out.write("isnan(")
    genExpr(expr, ctx, Type.aFloat)
    ctx.out.write(")")
  }

  # float.isInfinite()
  PROC $isInfinite(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%math)
    ctx.out.write("isinf(")
    genExpr(expr, ctx, Type.aFloat)
    ctx.out.write(")")
  }

  # Float function.
  PROC $floatMethod(string name, Zui.Expression expr, Zui.Expression arg,
                                                                 SContext ctx)
    $setDeclUsed(%math)
    ctx.out.write(name == "abs" ? "fabs" : name)
    ctx.out.write("(")
    genExpr(expr, ctx, Type.aFloat)
    IF arg != NIL
    ctx.out.write(", ")
      $genArg(arg, ctx, Type.aFloat)
    }
    ctx.out.write(")")
  }

  # Function for int.Type()
  PROC $callType(Type type, Zui.Position pos, SContext ctx)
    SWITCH type.getTtype()
      CASE Type.Enum.int
        ctx.out.write("&int__T")
      CASE Type.Enum.int8
        ctx.out.write("&int8__T")
      CASE Type.Enum.int16
        ctx.out.write("&int16__T")
      CASE Type.Enum.int32
        ctx.out.write("&int32__T")
      CASE Type.Enum.nat
        ctx.out.write("&nat__T")
      CASE Type.Enum.byte
        ctx.out.write("&byte__T")
      CASE Type.Enum.nat16
        ctx.out.write("&nat16__T")
      CASE Type.Enum.nat32
        ctx.out.write("&nat32__T")
      CASE Type.Enum.float
        ctx.out.write("&float__T")
      CASE Type.Enum.float32
        ctx.out.write("&float32__T")
      CASE Type.Enum.float80
        ctx.out.write("&float80__T")
      CASE Type.Enum.float128
        ctx.out.write("&float128__T")
      CASE Type.Enum.bool
        ctx.out.write("&bool__T")
      CASE Type.Enum.status
        ctx.out.write("&status__T")
      CASE Type.Enum.string
        ctx.out.write("&string__T")
      CASE Type.Enum.byteString
        ctx.out.write("&byteString__T")
      CASE Type.Enum.type
        ctx.out.write("&type__T")
      DEFAULT
        LOG.internal("callType() type not recognized: \(type.typeName())")
    }
  }

  # Function for enum.Type()
  PROC $callEnumType(EnumType type, Zui.Position pos, SContext ctx)
    ctx.out.write("&")
    ctx.out.write(type.pName)
    ctx.out.write("__T")
  }

  # Function for bits.Type()
  PROC $callBitsType(BitsType type, Zui.Position pos, SContext ctx)
    ctx.out.write("&")
    ctx.out.write(type.pName)
    ctx.out.write("__T")
  }

  # Function for tuple<>.Type()
  PROC $callTupleType(TupleType type, Zui.Position pos, SContext ctx)
    ctx.out.write("(Tt*)&")
    ctx.out.write(type.pName)
    ctx.out.write("__T")
  }

  # Function for dyn.Type()
  PROC $callDynType(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%dynType)
    ctx.out.write("ZdynType(")
    genExpr(expr, ctx, Type.aDyn)
    ctx.out.write(")")
  }

  # Function for dyn.ToString()
  PROC $callDynToString(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%dynToString)
    ctx.out.write("ZdynToString(")
    genExpr(expr, ctx, Type.aDyn)
    ctx.out.write(")")
  }

  # Function for dyn.Size()
  PROC $callDynSize(Zui.Expression expr, SContext ctx)
    ctx.out.write("ZdynSize(")
    genExpr(expr, ctx, Type.aDyn)
    ctx.out.write(")")
  }

  # Function for type.Size()
  PROC $callTypeSize(Type type, SContext ctx)
    ctx.out.write("sizeof(Tt)")
  }

  # Function for Module.Type()
  PROC $callModuleType(ModuleType mt, SContext ctx)
    ctx.out.write("&")
    ctx.out.write(mt.name)
    ctx.out.write("__T")
  }

  # Function for Class.Type()
  PROC $callClassType(ClassType ct, SContext ctx)
    ctx.out.write("(Tt*)&")
    ctx.out.write(ct.pName)
    ctx.out.write("__T")
  }

  # Function to turn a bool into a string.
  PROC $boolToString(Zui.Expression expr, list<Zui.Expression> args,
                                                                 SContext ctx)
    ctx.out.write("Zstr((")
    $genArg(expr, ctx, Type.aBool)
    IF args.Size() == 1
      IF args[0].getType() == Zui.ExprType.eSTRING
        IF args[0].getStringValue() == "1b"
          ctx.out.write(") ? \"1\" : \"0\")")
        ELSEIF args[0].getStringValue() == "b"
          ctx.out.write(") ? \"TRUE\" : \"FALSE\")")
        ELSEIF ctx.doError()
          ctx.error("format must be \"b\" or \"1b\"", args[0])
        }
      ELSE
        $setDeclUsed(%cstring)
        ctx.out.write(") ? (strcmp((char*)ZcString(")
        genExpr(args[0], ctx, Type.aString)
        ctx.out.write("), \"1b\") == 0 ? \"1\" : \"TRUE\") : (strcmp((char*)ZcString(")
        genExpr(args[0], ctx, Type.aString)
        ctx.out.write("), \"1b\") == 0 ? \"0\" : \"FALSE\"))")
      }
    ELSE
      ctx.out.write(") ? \"TRUE\" : \"FALSE\")")
    }
  }

  # Function to turn a status into a string.
  PROC $statusToString(Zui.Expression expr, list<Zui.Expression> args,
                                                                 SContext ctx)
    ctx.out.write("Zstr((")
    $genArg(expr, ctx, Type.aStatus)
    IF args.Size() == 1
      IF args[0].getType() == Zui.ExprType.eSTRING
        IF args[0].getStringValue() == "1t"
          ctx.out.write(") ? \"1\" : \"0\")")
        ELSEIF args[0].getStringValue() == "t"
          ctx.out.write(") ? \"OK\" : \"FAIL\")")
        ELSEIF ctx.doError()
          ctx.error("format must be \"t\" or \"1t\"", args[0])
        }
      ELSE
        $setDeclUsed(%cstring)
        ctx.out.write(") ? (strcmp((char*)ZcString(")
        genExpr(args[0], ctx, Type.aString)
        ctx.out.write("), \"1t\") == 0 ? \"1\" : \"OK\") : (strcmp((char*)ZcString(")
        genExpr(args[0], ctx, Type.aString)
        ctx.out.write("), \"1t\") == 0 ? \"0\" : \"FAIL\"))")
      }
    ELSE
      ctx.out.write(") ? \"OK\" : \"FAIL\")")
    }
  }

  # Function to return the size of an int or nat.
  PROC $intSize(Type type, SContext ctx)
    SWITCH type.getTtype()
      CASE Type.Enum.intval
      CASE Type.Enum.int
          ctx.out.write("sizeof(Ti)")
      CASE Type.Enum.natval
      CASE Type.Enum.nat
          ctx.out.write("sizeof(Tu)")

      CASE Type.Enum.int8; ctx.out.write("sizeof(char)")
      CASE Type.Enum.int16; ctx.out.write("sizeof(Ti16)")
      CASE Type.Enum.int32; ctx.out.write("sizeof(Ti32)")

      CASE Type.Enum.byte; ctx.out.write("sizeof(Tc)")
      CASE Type.Enum.nat16; ctx.out.write("sizeof(Tu16)")
      CASE Type.Enum.nat32; ctx.out.write("sizeof(Tu32)")
      DEFAULT
        LOG.internal("intSize() type not recognized: \(type.typeName())")
    }
  }

  # Function to return the size of a bool.
  PROC $boolSize(SContext ctx)
    # Although we use "int", when stored in an array a bool only uses one
    # byte.
    ctx.out.write("1")
  }

  # Function to return the size of a status.
  PROC $statusSize(SContext ctx)
    # Although we use "int", when stored in an array a status only uses one
    # byte.
    ctx.out.write("1")
  }

  # Function to check if a number is a digit character.
  PROC $isDigit(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%ctype_h)
    ctx.out.write("isdigit(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to check if a number is a hex digit character.
  PROC $isHexDigit(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%ctype_h)
    ctx.out.write("isxdigit(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to check if a number is an alphabetic character.
  PROC $isAlpha(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%ctype_h)
    ctx.out.write("isalpha(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to check if a number is a lower case character.
  PROC $isLower(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%ctype_h)
    ctx.out.write("islower(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to check if a number is an upper case character.
  PROC $isUpper(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%ctype_h)
    ctx.out.write("isupper(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to turn a number into a lower case character.
  PROC $intToLowerAscii(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%ctype_h)
    # TODO: only ASCII
    ctx.out.write("tolower(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function to turn a number into an upper case character.
  PROC $intToUpperAscii(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%ctype_h)
    # TODO: only ASCII
    ctx.out.write("toupper(")
    $genArg(expr, ctx, Type.anInt)
    ctx.out.write(")")
  }

  # Function make a number positive.
  PROC $intAbs(Zui.Expression expr, SContext ctx)
    # First find out what the type would be without conversion.
    Type t = $genArg(expr, ctx.copyNoOut(), NIL)
    IF t.isNatType()
      # Avoid a compiler warning for applying llabs() to an unsigned number.
      $genArg(expr, ctx, NIL)
    ELSE
      ctx.out.write("(Tu)llabs(")
      $genArg(expr, ctx, Type.anInt)
      ctx.out.write(")")
    }
  }

  PROC $writeCompare(Zui.Expression var_expr, list<Zui.Expression> args,
                                                      Type type, SContext ctx)
    IF type.ttype == Type.Enum.int
      || type.ttype == Type.Enum.bool
      || type.ttype == Type.Enum.status
      $setDeclUsed(%intCompare)
      ctx.out.write("ZintCompare(")
    ELSEIF type.ttype == Type.Enum.nat
      $setDeclUsed(%natCompare)
      ctx.out.write("ZnatCompare(")
    ELSEIF type.ttype == Type.Enum.float
      $setDeclUsed(%floatCompare)
      ctx.out.write("ZfloatCompare(")
    ELSEIF type.ttype == Type.Enum.dyn
      $setDeclUsed(Declaration.dynCompare)
      ctx.out.write("ZdynCompare(")
    ELSEIF type.ttype == Type.Enum.type
      $setDeclUsed(%typeCompare)
      ctx.out.write("ZtypeCompare(")
    }
    $genArg(var_expr, ctx, type)
    ctx.out.write(", ")
    $genArg(args[0], ctx, type)
    ctx.out.write(")")
  }

  PROC $writeEqual(Zui.Expression var_expr, list<Zui.Expression> args,
                                                      Type type, SContext ctx)
    string middle = " == "
    IF type.ttype == Type.Enum.dyn
      $setDeclUsed(Declaration.dynEqual)
      ctx.out.write("ZdynEqual")
      middle = ", "
    }
    ctx.out.write("(")
    $genArg(var_expr, ctx, type)
    ctx.out.write(middle)
    $genArg(args[0], ctx, type)
    ctx.out.write(")")
  }

  PROC $stringToInt(Zui.Position pos, Zui.Expression expr, bool dotnil,
                           list<Zui.Expression> args, SContext ctx, int radix)
    string name
    IF radix == 10
      name = "ZstringToInt"
    ELSEIF radix == 2
      name = "ZstringBinToInt"
    ELSE
      name = "ZstringHexToInt"
    }
    ctx.out.write(name .. "(")
    $genArg(expr, ctx, Type.aString)
    ctx.out.write(", ")
    int flags = 0
    IF args.Size() == 0
      flags += 1
    }
    IF dotnil
      flags += 2
    }
    ctx.out.write((flags + '0').asString())
    ctx.out.write(", ")
    IF args.Size() > 0
      $genArg(args[0], ctx, Type.anInt)
    ELSE
      ctx.out.write("0")
    }
    ctx.out.write(")")
  }

  PROC $varStringToInt(Zui.Position pos, Zui.Expression expr, bool dotnil,
                           list<Zui.Expression> args, SContext ctx, int radix)
    string name
    IF radix == 10
      name = "ZvarStringToInt"
    ELSEIF radix == 2
      name = "ZvarStringBinToInt"
    ELSE
      name = "ZvarStringHexToInt"
    }
    ctx.out.write(name .. "(")
    $genArg(expr, ctx, Type.aVarString)
    int flags = 0
    IF args.Size() == 0
      flags += 1
    }
    IF dotnil
      flags += 2
    }
    ctx.out.write(", ")
    ctx.out.write((flags + '0').asString())
    ctx.out.write(", ")
    IF args.Size() > 0
      $genArg(args[0], ctx, Type.anInt)
    ELSE
      ctx.out.write("0")
    }
    ctx.out.write(")")
  }

  PROC $stringQuotedToInt(Zui.Position pos, Zui.Expression expr, bool dotnil,
                           list<Zui.Expression> args, SContext ctx, int radix)
    string name
    IF radix == 10
      name = "ZstringQuotedToInt"
    ELSEIF radix == 2
      name = "ZstringQuotedBinToInt"
    ELSE
      name = "ZstringQuotedHexToInt"
    }
    ctx.out.write(name .. "(")
    $genArg(expr, ctx, Type.aString)
    int flags
    IF args.Size() == 0
      flags = 1
    }
    IF dotnil
      flags += 2
    }
    ctx.out.write(", ")
    ctx.out.write((flags + '0').asString())
    ctx.out.write(", ")
    IF args.Size() > 0
      $genArg(args[0], ctx, Type.anInt)
    ELSE
      ctx.out.write("0")
    }
    ctx.out.write(")")
  }

  PROC $varStringQuotedToInt(Zui.Position pos, Zui.Expression expr, bool dotnil,
                           list<Zui.Expression> args, SContext ctx, int radix)
    string name
    IF radix == 10
      name = "ZvarStringQuotedToInt"
    ELSEIF radix == 2
      name = "ZvarStringQuotedBinToInt"
    ELSE
      name = "ZvarStringQuotedHexToInt"
    }
    ctx.out.write(name .. "(")
    $genArg(expr, ctx, Type.aVarString)
    int flags
    IF args.Size() == 0
      flags = 1
    }
    IF dotnil
      flags += 2
    }
    ctx.out.write(", ")
    ctx.out.write((flags + '0').asString())
    ctx.out.write(", ")
    IF args.Size() > 0
      $genArg(args[0], ctx, Type.anInt)
    ELSE
      ctx.out.write("0")
    }
    ctx.out.write(")")
  }

  PROC $stringToFloat(Zui.Position pos, Zui.Expression expr, bool dotnil,
                      list<Zui.Expression> args, SContext ctx)
    $setDeclUsed(%stringToFloat)
    ctx.out.write("Zstring2float(")
    $genArg(expr, ctx, Type.aString)
    ctx.out.write(", ")
    IF args.Size() == 0
      ctx.out.write("0")
    ELSE
      $genArg(args[0], ctx, Type.anIntRef)
    }
    ctx.out.write(")")
  }

  PROC $stringCaseCommon(string name, Zui.Expression expr,
                                                      SContext ctx, Type type)
    ctx.out.write(name)
    ctx.out.write("(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $stringToLowerAscii(Zui.Expression expr, bool dotnil,
                                                      SContext ctx, Type type)
    $stringCaseCommon("ZstringToLowerAscii", expr, ctx, type)
  }

  PROC $stringToUpperAscii(Zui.Expression expr, bool dotnil,
                                                      SContext ctx, Type type)
    $stringCaseCommon("ZstringToUpperAscii", expr, ctx, type)
  }

  PROC $stringToLower(Zui.Expression expr, bool dotnil, SContext ctx, Type type)
    $setDeclUsed(%stringToLower)
    $stringCaseCommon("ZstringToLower", expr, ctx, type)
  }

  PROC $stringToUpper(Zui.Expression expr, bool dotnil, SContext ctx, Type type)
    $setDeclUsed(%stringToUpper)
    $stringCaseCommon("ZstringToUpper", expr, ctx, type)
  }

  PROC $varStringToLowerAscii(Zui.Expression expr, bool dotnil,
                                                      SContext ctx, Type type)
    $stringCaseCommon("ZvarStringToLowerAscii", expr, ctx, type)
  }

  PROC $varStringToUpperAscii(Zui.Expression expr, bool dotnil,
                                                      SContext ctx, Type type)
    $stringCaseCommon("ZvarStringToUpperAscii", expr, ctx, type)
  }

  PROC $varStringToLower(Zui.Expression expr, bool dotnil,
                                                      SContext ctx, Type type)
    $setDeclUsed(%varStringToLower)
    $stringCaseCommon("ZvarStringToLower", expr, ctx, type)
  }

  PROC $varStringToUpper(Zui.Expression expr, bool dotnil,
                                                      SContext ctx, Type type)
    $setDeclUsed(%varStringToUpper)
    $stringCaseCommon("ZvarStringToUpper", expr, ctx, type)
  }

  PROC $stringFindCharF(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx,
                                                 string funcname, Type dest)
    string name = "Z" .. dest.ttype.ToString() .. funcname
    IF args.Size() == 2
      ctx.out.write(name .. "2(")
      $genArg(var_expr, ctx, dest)
      ctx.out.write(", ")
      $genArg(args[0], ctx, Type.anInt)
      ctx.out.write(", ")
      $genArg(args[1], ctx, Type.anInt)
    ELSE                                      # s.find(int c)
      ctx.out.write(name .. "(")
      $genArg(var_expr, ctx, dest)
      ctx.out.write(", ")
      $genArg(args[0], ctx, Type.anInt)
    }
    IF dotnil
      ctx.out.write(", 1)")
    ELSE
      ctx.out.write(", 0)")
    }
  }

  PROC $stringFindChar(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "FindChar", Type.aString)
  }

  PROC $varStringFindChar(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "FindChar", Type.aVarString)
  }

  PROC $byteStringGetByte(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.out.write("ZbyteStringGetByte(")
    $genArg(var_expr, ctx, Type.aByteString)
    ctx.out.write(", ")
    $genArg(args[0], ctx, Type.anInt)
    IF dotnil
      ctx.out.write(", 1)")
    ELSE
      ctx.out.write(", 0)")
    }
  }

  PROC $byteStringGetChar(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.out.write("ZbyteStringGetChar(")
    $genArg(var_expr, ctx, Type.aByteString)
    ctx.out.write(", ")
    $genArg(args[0], ctx, Type.anInt)
    IF dotnil
      ctx.out.write(", 1)")
    ELSE
      ctx.out.write(", 0)")
    }
  }

  PROC $byteStringGetCharSize(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    ctx.out.write("ZbyteStringGetCharSize(")
    $genArg(var_expr, ctx, Type.aByteString)
    ctx.out.write(", ")
    $genArg(args[0], ctx, Type.anInt)
    IF dotnil
      ctx.out.write(", 1)")
    ELSE
      ctx.out.write(", 0)")
    }
  }

  PROC $byteStringFindByte(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "FindByte", Type.aByteString)
  }

  PROC $varByteStringFindByte(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "FindByte",
                                                          Type.aVarByteString)
  }

  PROC $stringFindLastChar(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "FindLastChar", Type.aString)
  }

  PROC $varStringFindLastChar(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "FindLastChar", Type.aVarString)
  }

  PROC $byteStringFindLastByte(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "FindLastByte", Type.aByteString)
  }

  PROC $varByteStringFindLastByte(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringFindCharF(var_expr, dotnil, args, ctx, "FindLastByte",
                                                          Type.aVarByteString)
  }

  PROC $stringSameArgF(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx,
                                              string funcname, Type dest)
    string name = "Z" .. dest.ttype.ToString() .. funcname
    IF name == "ZbyteStringStartsWith"
      name = "ZstringStartsWith"  # works exactly the same way
    ELSEIF name == "ZbyteStringEndsWith"
      name = "ZstringEndsWith"  # works exactly the same way
    ELSEIF name == "ZvarByteStringStartsWith"
      name = "ZvarStringStartsWith"  # works exactly the same way
    ELSEIF name == "ZvarByteStringEndsWith"
      name = "ZvarStringEndsWith"  # works exactly the same way
    ELSEIF name == "ZbyteStringCompare"
      name = "ZstringCompare"  # works exactly the same way
    ELSEIF name == "ZbyteStringEqual"
      name = "ZstringEqual"  # works exactly the same way
    }
    IF args.Size() == 2
      name ..= "2"
    }
    ctx.out.write(name .. "(")
    $generatingArg = TRUE
    $genArg(var_expr, ctx, dest)
    ctx.out.write(", ")
    $genArg(args[0], ctx, dest)
    IF args.Size() == 2
      ctx.out.write(", ")
      $genArg(args[1], ctx, Type.anInt)
    }
    $generatingArg = FALSE
    IF dotnil
      ctx.out.write(", 1)")
    ELSE
      ctx.out.write(", 0)")
    }
  }

  PROC $stringCompare(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "Compare", Type.aString)
  }

  PROC $stringEqual(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "Equal", Type.aString)
  }

  PROC $byteStringCompare(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "Compare", Type.aByteString)
  }

  PROC $byteStringEqual(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "Equal", Type.aByteString)
  }

  PROC $stringFind(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "Find", Type.aString)
  }

  PROC $stringFindLast(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "FindLast", Type.aString)
  }

  PROC $varStringFind(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "Find", Type.aVarString)
  }

  PROC $varStringFindLast(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "FindLast", Type.aVarString)
  }

  PROC $byteStringFind(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "Find", Type.aByteString)
  }

  PROC $byteStringFindLast(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "FindLast", Type.aByteString)
  }

  PROC $varByteStringFind(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "Find", Type.aVarByteString)
  }

  PROC $varByteStringFindLast(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "FindLast", Type.aVarByteString)
  }

  PROC $stringStartsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "StartsWith", Type.aString)
  }

  PROC $stringEndsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "EndsWith", Type.aString)
  }

  PROC $varStringStartsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "StartsWith", Type.aVarString)
  }

  PROC $varStringEndsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "EndsWith", Type.aVarString)
  }

  PROC $byteStringStartsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "StartsWith", Type.aByteString)
  }

  PROC $byteStringEndsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "EndsWith", Type.aByteString)
  }

  PROC $varByteStringStartsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "StartsWith", Type.aVarByteString)
  }

  PROC $varByteStringEndsWith(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $stringSameArgF(var_expr, dotnil, args, ctx, "EndsWith", Type.aVarByteString)
  }

  PROC $stringSlice(Zui.Expression var_expr, bool dotnil,
                               Zui.MethodCall call, SContext ctx, Type dest)
    ctx.out.write("Z" .. dest.ttype.ToString() .. "Slice(")
    $genArg(var_expr, ctx, dest)
    ctx.out.write(", ")
    Generate.generateSliceArgs(call, dotnil, ctx)
    ctx.out.write(")")
  }

  PROC $stringSlice(Zui.Expression var_expr, bool dotnil,
                                          Zui.MethodCall call, SContext ctx)
    $stringSlice(var_expr, dotnil, call, ctx, Type.aString)
  }

  PROC $varStringSlice(Zui.Expression var_expr, bool dotnil,
                                          Zui.MethodCall call, SContext ctx)
    $stringSlice(var_expr, dotnil, call, ctx, Type.aVarString)
  }

  PROC $byteStringSlice(Zui.Expression var_expr, bool dotnil,
                                          Zui.MethodCall call, SContext ctx)
    $stringSlice(var_expr, dotnil, call, ctx, Type.aByteString)
  }

  PROC $varByteStringSlice(Zui.Expression var_expr, bool dotnil,
                                          Zui.MethodCall call, SContext ctx)
    $stringSlice(var_expr, dotnil, call, ctx, Type.aVarByteString)
  }

  PROC $varAdd(Zui.Expression var_expr, list<Zui.Expression> args, SContext ctx,
                                               Type valtype, Type vartype)
    # Check the type of the argument.
    Type type = genExpr(args[0], ctx.copyNoOut(), valtype)
    IF type == NIL
      type = genExpr(args[0], ctx.copyNoOut())
    }
    IF type != NIL
      IF type.ttype == valtype.ttype || type.ttype == Type.Enum.stringval
        ctx.out.write("ZvarStringAddVal(")
        $genArg(var_expr, ctx, vartype)
        ctx.out.write(", ")
        $genArg(args[0], ctx, valtype)
        ctx.out.write(")")
      ELSE
        ctx.error("Sorry, ZvarStringAddBytes not implemented yet", var_expr)
        $setDeclUsed(%varStringAddBytes)
        ctx.out.write("ZvarStringAddBytes(")
        $genArg(var_expr, ctx, vartype)
        ctx.out.write(", ")
        $genArg(args[0], ctx, vartype)
        ctx.out.write(")")
      }
    }
  }

  PROC $varStringAdd(Zui.Expression var_expr,
                                      list<Zui.Expression> args, SContext ctx)
    $varAdd(var_expr, args, ctx, Type.aString, Type.aVarString)
  }

  PROC $varByteStringAdd(Zui.Expression var_expr,
                                      list<Zui.Expression> args, SContext ctx)
    $varAdd(var_expr, args, ctx, Type.aByteString, Type.aVarByteString)
  }

  PROC $split(Zui.Expression var_expr, bool dotnil,
          list<Zui.Expression> args, SContext ctx, Type vartype, Type argtype)
    string name = "Z" .. vartype.ttype.ToString() .. "Split"
    ctx.out.write(name .. "(")
    $genArg(var_expr, ctx, vartype)
    ctx.out.write(", ")
    $genArg(args[0], ctx, argtype)
    IF dotnil
      ctx.out.write(", 1)")
    ELSE
      ctx.out.write(", 0)")
    }
  }

  PROC $stringSplit(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $split(var_expr, dotnil, args, ctx, Type.aString, Type.aString)
  }

  PROC $varStringSplit(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $split(var_expr, dotnil, args, ctx, Type.aVarString, Type.aString)
  }

  PROC $byteStringSplit(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $split(var_expr, dotnil, args, ctx, Type.aByteString, Type.aByteString)
  }

  PROC $varByteStringSplit(Zui.Expression var_expr, bool dotnil,
                                      list<Zui.Expression> args, SContext ctx)
    $split(var_expr, dotnil, args, ctx, Type.aVarByteString, Type.aByteString)
  }

  PROC $stringSize(Zui.Expression expr, SContext ctx, Type type)
    $setDeclUsed(%stringSize)
    ctx.out.write("ZstringSize(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $varStringSize(Zui.Expression expr, SContext ctx, Type type)
    ctx.out.write("ZvarStringSize(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $byteStringSize(Zui.Expression expr, SContext ctx, Type type)
    ctx.out.write("ZbyteStringSize(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $varByteStringSize(Zui.Expression expr, SContext ctx, Type type)
    ctx.out.write("ZvarByteStringSize(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  # Get the hash value of a byteString or string.
  PROC $byteStringHash(Zui.Expression expr, SContext ctx, Type type)
    ctx.out.write("ZbyteStringHash(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  # Get the hash value of a varByteString or varString.
  PROC $varByteStringHash(Zui.Expression expr, SContext ctx, Type type)
    IF ctx.doError()
      ctx.error("hash not yet implemented for varByteString", expr)
    }
    ctx.out.write("ZvarByteStringHash(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $string2varString(Zui.Expression expr, SContext ctx, Type type)
    $setDeclUsed(%string2varString)
    ctx.out.write("Zstring2varString(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $byteString2string(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%byteStringCheckUtf8)
    ctx.out.write("ZbyteStringCheckUtf8(")
    $genArg(expr, ctx, Type.aByteString)
    ctx.out.write(")")
  }

  PROC $byteString2varString(Zui.Expression expr, SContext ctx)
    $setDeclUsed(%byteStringCheckUtf8)
    $setDeclUsed(%string2varString)
    ctx.out.write("Zstring2varString(ZbyteStringCheckUtf8(")
    $genArg(expr, ctx, Type.aByteString)
    ctx.out.write("))")
  }

  PROC $varString2string(Zui.Expression expr, SContext ctx, Type type)
    ctx.setDeclUsed(%varString2string)
    ctx.out.write("ZvarString2string(")
    $genArg(expr, ctx, type)
    ctx.out.write(")")
  }

  PROC $varByteString2string(Zui.Expression expr, SContext ctx)
    ctx.setDeclUsed(%varByteStringCheckUtf8)
    ctx.setDeclUsed(%varString2string)
    ctx.out.write("ZvarString2string(ZvarByteStringCheckUtf8(")
    $genArg(expr, ctx, Type.aVarByteString)
    ctx.out.write("))")
  }

  PROC $varByteString2varString(Zui.Expression expr, SContext ctx)
    ctx.setDeclUsed(%varByteStringCheckUtf8)
    ctx.out.write("ZvarByteStringCheckUtf8(")
    $genArg(expr, ctx, Type.aVarByteString)
    ctx.out.write(")")
  }

  # Turn a string into an array.
  PROC $stringToArray(Zui.Expression expr, SContext ctx)
    ctx.setDeclUsed(%stringToArray)
    ctx.out.write("ZStringToArray(")
    $genArg(expr, ctx, Type.aString)
    ctx.out.write(")")
  }

  # Generate a switch() and return the type of the expression.
  FUNC $switch(Zui.Expression expr, Zui.CodeBlock block, SContext ctx) Type
    ctx.out.writeIndent(ctx.scope.depth)
    Type.Enum ttype = ZuiExpressionExt.get(expr).resultType?.getTtype()
    IF ttype == Type.Enum.type
      IF block != NIL
        string name = ZuiCodeBlockExt.get(block).scope.<SwitchScope>.varName
        ctx.outs.varOut.write(" Tt *")
        ctx.outs.varOut.write(name)
        ctx.outs.varOut.write(";\n")

        ctx.out.write(name)
        ctx.out.write(" = ")
      }
    ELSE
      ctx.out.write("switch (")
    }
    Type switchType = genExpr(expr, ctx)
    IF ttype == Type.Enum.type
      ctx.out.write(";\n")
    ELSE
      ctx.out.write(")\n")
    }
    RETURN switchType
  }

  FUNC $caseString(Zui.Expression expr, bool caseFollows, SContext ctx) string
    Output out = ctx.out
    IF !out.writing
      RETURN ""
    }
    out.writeIndent(ctx.scope.depth - 1)

    Type.Enum ttype = ctx.scope.switchType?.getTtype()
    IF ttype == Type.Enum.type
      IF ctx.scope.<SwitchScope>.wroteCase
        out.write(" || ")
      ELSE
        out.write("if (")
        ctx.scope.<SwitchScope>.wroteCase = TRUE
      }
      out.write(ctx.scope.<SwitchScope>.varName)
      out.write(" == ")
    ELSE
      out.write("case ")
    }

    # First write the output to caseOut, so that we can check for
    # duplicate values and add a type cast when needed.
    Output caseOut = NEW()
    caseOut.writing = TRUE
    genExpr(expr, ctx.copy(caseOut), ctx.scope.switchType)
    out.append(caseOut)
    IF ttype == Type.Enum.type
      IF !caseFollows
        out.write(")\n")
      }
    ELSE
      out.write(":\n")
    }
    RETURN caseOut.ToString()
  }

  PROC $writeProceed(Zui.Statement stmt, SContext ctx)
    IF stmt.getType() == Zui.StatementType.eCASE
      # We enter the next block by setting the switch variable equal th the
      # case value of the next CASE.
      ctx.out.writeIndent(ctx.scope.depth + 1)
      ctx.out.write(ctx.scope.<SwitchScope>.varName)
      ctx.out.write(" = ")
      genExpr(stmt.getExpr(), ctx, ctx.scope.switchType)
      ctx.out.write(";\n")
    }
  }

  PROC $default(SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth - 1)
    Type.Enum ttype = ctx.scope.switchType?.getTtype()
    IF ttype != Type.Enum.type
      ctx.out.write("default:\n")
    }
  }

  # Return TRUE when memory is managed.
  FUNC $manageMemory() bool
    RETURN ManageMemory.manageMemory(THIS)
  }

  # Return TRUE when every object struct has the "np" field.
  # That is when memory is managed, Finish() is used or DEFER is used.
  FUNC $hasNpField() bool
    RETURN $manageMemory()
        || $isDeclUsed(Declaration.hasFinish)
        || $isDeclUsed(Declaration.defer)
  }

  SHARED
    dict<string, string> typeStructs = [
        "int": "int__T",
        "int8": "int8__T",
        "int16": "int16__T",
        "int32": "int32__T",
        "bits": "int__T",
        "nat": "nat__T",
        "byte": "byte__T",
        "nat16": "nat16__T",
        "nat32": "nat32__T",
        "bool": "bool__T",
        "status": "status__T",
        "float": "float__T",
        "string": "string__T",
        "bytes": "byteString__T",  # TODO: remove
        "byteString": "byteString__T",
        "varString": "varString__T",
        "varbytes": "varByteString__T",  # TODO: remove
        "varByteString": "varByteString__T",
        "thread": "thread__T",
        "dyn": "dyn__T",
        "type": "type__T",
        ]
  }

  PROC $writeTtype(string name, Zui.Position pos, SContext ctx)
    string s = typeStructs.get(name, NIL)
    IF s == NIL
      ctx.error("Unsupported type: " .. name, pos)
    ELSE
      ctx.out.write("&" .. s)
    }
  }

  # Return the name of the struct defining type |type|.
  # Similar to getArgumentType().
  # TODO: how about typedef?
  FUNC $getAnyType(Type type, Zui.Position pos, SContext ctx) string
    # Argument for item type
    SWITCH type.getTtype()
      # Value types
      CASE Type.Enum.int
      CASE Type.Enum.natval
      CASE Type.Enum.intval
        RETURN "&int__T"
      CASE Type.Enum.int8
        RETURN "&int8__T"
      CASE Type.Enum.int16
        RETURN "&int16__T"
      CASE Type.Enum.int32
        RETURN "&int32__T"
      CASE Type.Enum.nat
        RETURN "&nat__T"
      CASE Type.Enum.byte
        RETURN "&byte__T"
      CASE Type.Enum.nat16
        RETURN "&nat16__T"
      CASE Type.Enum.nat32
        RETURN "&nat32__T"
      CASE Type.Enum.bool
        RETURN "&bool__T"
      CASE Type.Enum.status
        RETURN "&status__T"
      CASE Type.Enum.enumValue
        RETURN "&" .. type.<EnumValueType>.enumType.pName .. "__T"
      CASE Type.Enum.bitsValue
        RETURN "&" .. type.<BitsValueType>.bitsType.pName .. "__T"

      CASE Type.Enum.float
      CASE Type.Enum.floatval
        RETURN "&float__T"
      CASE Type.Enum.float32
        RETURN "&float32__T"
      CASE Type.Enum.float80
        RETURN "&float80__T"
      CASE Type.Enum.float128
        RETURN "&float128__T"

      # Reference types
      CASE Type.Enum.string
        RETURN "&string__T"
      CASE Type.Enum.byteString
        RETURN "&byteString__T"
      CASE Type.Enum.varString
        RETURN "&varString__T"
      CASE Type.Enum.varByteString
        RETURN "&varByteString__T"
      CASE Type.Enum.tuple
        RETURN "(Tt*)&" .. type.getEffType().pName .. "__T"
      CASE Type.Enum.iobject
        RETURN "&iobj__T"
      CASE Type.Enum.object
# TODO: not needed?
#        string name = type.getClassType(ctx).name
#        IF name == "thread"
#          RETURN "&thread__T"
#        }
        RETURN "(Tt*)&" .. type.getClassType(ctx).pName .. "__T"

#        CASE Type.Enum.iobject
#          RETURN "TODO"
      CASE Type.Enum.array
      CASE Type.Enum.list
      CASE Type.Enum.dict
        RETURN "&" .. type.getEffType().<ContainerType>.typeUsed(ctx).pName
                                                                      .. "__T"
#        CASE Type.Enum.procRef
#        CASE Type.Enum.funcRef
#          RETURN "TODO"
      CASE Type.Enum.dyn
        RETURN "&dyn__T"
      CASE Type.Enum.type
        RETURN "&type__T"
    }
    IF ctx.doError()
      ctx.error("Unsupported item type for dyn: "
                                           .. type.getTtype().ToString(), pos)
    }
    RETURN -1
  }

  FUNC $conv2dyn(Type type, string name, string arg,
                                        Zui.Position pos, SContext ctx) string
    ctx.out.write(name)
    ctx.out.write("(")
    string close = ", " .. $getAnyType(type, pos, ctx)
    IF arg != NIL
      close ..= ", " .. arg
    }
    RETURN close .. ")"
  }

  FUNC $convFromDyn(Type type, string name, string arg,
                                        Zui.Position pos, SContext ctx) string
    ctx.out.write(name)
    ctx.out.write("(")
    string close = ", " .. $getAnyType(type, pos, ctx)
    IF arg != NIL
      close ..= ", " .. arg
    }
    RETURN close .. ", " .. $getPosNumber(pos, ctx) .. ")"
  }

  PROC $startBlock(SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("{\n")
  }

  PROC $forBlockStart(Zui.Position pos, SContext ctx)
    $startBlock(ctx)
  }

  FUNC $forStart(ForLoopInfo info,
                      Type toType, Type untilType, Type stepType, SContext ctx
                ) list<Type>
    Output declOut = NEW()
    declOut.writing = ctx.out.writing
    SContext declCtx = ctx.copy(declOut)
    Output stmtOut = NEW()
    stmtOut.writing = ctx.out.writing
    SContext stmtCtx = ctx.copy(stmtOut)
    Zui.ForStatement stmt = info.forStmt
    list<Type> itemTypes
    ctx.setDeclUsed(Declaration.alloc)

    FOR i IN 0 UNTIL info.iters.Size()
      ForLoopInfo.Iter iter = info.iters[i]
      Type iterType = iter.varDecl.type
      Zui.Expression expr = stmt.getIter(i)
      Type itemType

      Output vout
      SContext vctx
      IF iter.varDecl.inMethodScope
        vout = stmtOut
        vctx = stmtCtx
      ELSE
        vout = declOut
        vctx = declCtx
      }

      IF iter.iteratorType != NIL
        # Use $Iterator() or $KeyIterator() of the class.
        ClassType class = iterType.getClassType(ctx)
        IF class == NIL
          ctx.error("Missing Iterator class", expr)
          RETURN [Type.anInt]
        }
        IF class.templateTypes == NIL
          ctx.error("Missing I.Iterator template type", expr)
          RETURN [Type.anInt]
        }

        vout.writeIndent(ctx.scope.depth + 1)
        IF !iter.varDecl.inMethodScope
          $vartype(iter.iteratorType, TRUE, expr.getPos(), vctx)
        }
        vout.write(iter.varDecl.pName)
        vout.write(" = ")
        IF iter.iteratorMethod != NIL
          vout.write(iter.iteratorMethod.pName)
          vout.write("(")
        }
        $genArg(expr, vctx, NIL)
        IF iter.iteratorMethod != NIL
          vout.write(")")
        }
        vout.write(";\n")

        # I.KeyIterator<int, string> returns int + string..
        IF class.templateTypes.Size() > 1
          IF info.iters.Size() > 1
            ctx.error("Cannot use KeyIterator here", expr)
            RETURN [Type.anInt]
          }
          itemTypes = NEW()
          FOR decl IN class.templateTypes
            itemTypes.add(decl.type)
          }
        ELSE
          # I.Iterator<int> returns int.
          itemType = class.templateTypes[0].type
        }
      ELSE
        Type.Enum ttype = iterType.getTtype()
        SWITCH ttype
          CASE Type.Enum.array
          CASE Type.Enum.list
          CASE Type.Enum.dict
            declOut.writeIndent(ctx.scope.depth + 1)
            declOut.write(ttype == Type.Enum.array ? "Tfa "
                                  : ttype == Type.Enum.list ? "Tfl " : "Tfd ")
            declOut.write(iter.varDecl.pName)
            declOut.write("i;\n")

            vout.writeIndent(ctx.scope.depth + 1)
            IF !iter.varDecl.inMethodScope
              vout.write(ttype == Type.Enum.array ? "Ta *" :
                                    ttype == Type.Enum.list ? "Tl *" : "Td *")
            }
            vout.write(iter.varDecl.pName .. " = ")
            $genArg(expr, vctx, NIL)
            vout.write(";\n")

            # The array/list/dict itself is also stored in a separate
            # variable, so that it's referenced in the method scope if needed.
            stmtOut.writeIndent(ctx.scope.depth + 1)
            stmtOut.write(iter.varDecl.pName)
            stmtOut.write(ttype == Type.Enum.array ? "i.a = " :
                                ttype == Type.Enum.list ? "i.l = " : "i.d = ")
            stmtOut.write(iter.varDecl.pName)
            stmtOut.write(";\n")

            ContainerType ct = iterType.getEffType()
            # When key/item type is NIL must be an empty array/list/dict, use
            # int.
            itemType = ct.itemType ?: Type.anInt
            IF info.forStmt.sizeLoopVar() > 1 && info.iters.Size() == 1
              IF ttype == Type.Enum.dict
                itemTypes = [ct.keyType ?: Type.anInt, itemType]
              ELSE
                itemTypes = [Type.anInt, itemType]
              }
              itemType = NIL
            }

          CASE Type.Enum.string
            ctx.setDeclUsed(%forStringStruct)
            declOut.writeIndent(ctx.scope.depth + 1)
            declOut.write("Tfs i" .. iter.varDecl.pName .. ";\n")

            vout.writeIndent(ctx.scope.depth + 1)
            IF !iter.varDecl.inMethodScope
              vout.write("Tc *")
            }
            vout.write(iter.varDecl.pName .. " = ")
            $genArg(expr, vctx, Type.aString)
            vout.write(";\n")

            stmtOut.writeIndent(ctx.scope.depth + 1)
            stmtOut.write("ZforStringNew(")
            stmtOut.write(iter.varDecl.pName)
            stmtOut.write(", &i")
            stmtOut.write(iter.varDecl.pName)
            stmtOut.write(");\n")

            itemType = Type.anInt

          CASE Type.Enum.byteString
            ctx.setDeclUsed(%forStringStruct)
            declOut.writeIndent(ctx.scope.depth + 1)
            declOut.write("Tfs i" .. iter.varDecl.pName .. ";\n")

            vout.writeIndent(ctx.scope.depth + 1)
            IF !iter.varDecl.inMethodScope
              vout.write("Tc *")
            }
            vout.write(iter.varDecl.pName .. " = ")
            $genArg(expr, vctx, Type.aByteString)
            vout.write(";\n")

            stmtOut.writeIndent(ctx.scope.depth + 1)
            stmtOut.write("ZforBytestringNew(")
            stmtOut.write(iter.varDecl.pName)
            stmtOut.write(", &i")
            stmtOut.write(iter.varDecl.pName)
            stmtOut.write(");\n")

            itemType = Type.anInt

          CASE Type.Enum.int
          CASE Type.Enum.int8
          CASE Type.Enum.int16
          CASE Type.Enum.int32
          CASE Type.Enum.nat
          CASE Type.Enum.byte
          CASE Type.Enum.nat16
          CASE Type.Enum.nat32
          CASE Type.Enum.natval
          CASE Type.Enum.intval
            IF toType == NIL && untilType == NIL
              ctx.error("Not supported: FOR on "
                                           .. iterType.ttype.ToString(), expr)
              RETURN NIL
            }
            ctx.setDeclUsed(%forRange)
            IF !simpleForLoop(stmt, ctx)
              declOut.writeIndent(ctx.scope.depth + 1)
              declOut.write("Tfr " .. iter.varDecl.pName .. ";\n")

              stmtOut.writeIndent(ctx.scope.depth + 1)
              stmtOut.write("ZforRangeNew(")
              $genArg(expr, stmtCtx, Type.anInt)
              stmtOut.write(", ")
              IF toType != NIL
                $genArg(stmt.getTo(), stmtCtx, Type.anInt)
                stmtOut.write(", 0, ")
              ELSE
                $genArg(stmt.getUntil(), stmtCtx, Type.anInt)
                stmtOut.write(", 1, ")
              }
              IF stmt.hasStep()
                $genArg(stmt.getStep(), stmtCtx, Type.anInt)
              ELSE
                stmtOut.write("1")
              }
              stmtOut.write(", &" .. iter.varDecl.pName)
              stmtOut.write(");\n")
            }
            itemType = Type.anInt

          CASE Type.Enum.enum
          CASE Type.Enum.enumValue
            ctx.setDeclUsed(%forEnum)

            declOut.writeIndent(ctx.scope.depth + 1)
            declOut.write("Tfe " .. iter.varDecl.pName .. ";\n")

            stmtOut.writeIndent(ctx.scope.depth + 1)
            stmtOut.write(iter.varDecl.pName)
            stmtOut.write(".count = ")
            EnumType et = iterType.<EnumType>
            IF et.members == NIL
              stmtOut.write(0 .. "")
            ELSE
              stmtOut.write(et.members.Size() .. "")
            }
            stmtOut.write(";\n")

            stmtOut.writeIndent(ctx.scope.depth + 1)
            stmtOut.write(iter.varDecl.pName)
            stmtOut.write(".idx = 0;\n")

            IF iterType ISA EnumType
              itemType = iterType.<EnumType>.getEnumValue()
            ELSE
              itemType = iterType
            }

          CASE Type.Enum.object
          CASE Type.Enum.iobject
            ctx.error("No iterator found for "
                                     .. iterType.getClassType(ctx).name, expr)

          DEFAULT
            ctx.error("Not supported: FOR on "
                                           .. iterType.ttype.ToString(), expr)
        }
      }

      IF itemType != NIL
        IF itemTypes == NIL
          itemTypes = NEW()
        }
        itemTypes.add(itemType)
      }
    }

    ctx.out.append(declOut)
    ctx.out.append(stmtOut)
    RETURN itemTypes
  }

  PROC $forLoop(ForLoopInfo info, list<Declaration> varList, SContext ctx)
    Output out = ctx.out
    Output declOut = NEW()
    declOut.writing = out.writing
    Output startOut = NEW()
    startOut.writing = out.writing
    Output contOut = NEW()
    contOut.writing = out.writing
    Output incOut = NEW()
    incOut.writing = out.writing
    Zui.ForStatement for = info.forStmt

    FOR idx IN 0 UNTIL info.iters.Size()
      ForLoopInfo.Iter iter = info.iters[idx]
      IF idx > 0
        contOut.write(" && ")
      }

      IF iter.iteratorType != NIL
        # it.hasNext() && (Vi = it.next(), 1)
        SContext contCtx = ctx.copy(contOut)
        $forLoopIteratorWhile(info, varList, 0, contCtx)
        CONTINUE
      }

      string type = ""
      Declaration.C varDecl = varList[idx]
      string loopVarName = varDecl.pName
      string iterVarName = iter.varDecl.pName

      ENUM LoopType
        noIdx
        simple
        array
        list
        dict
      }
      LoopType loopType

      bool usingKey = varList.Size() > info.iters.Size()

      SWITCH iter.varDecl.type.ttype
        CASE Type.Enum.array
          loopType = LoopType.array
          type = "Array"
          ctx.setDeclUsed(%forArray)

        CASE Type.Enum.list
          loopType = LoopType.list
          type = "List"

          # FOR over a list is used a lot, do some work at compile time to
          # avoid work at runtime.
          ContainerType ct = iter.varDecl.type.getEffType()
          Type itemType = ct.itemType ?: Type.anInt
          Declaration noKey
          Declaration withKey
          IF itemType.ttype == Type.Enum.iobject
            type ..= "Iobj"
            noKey = %forListIobj
            withKey = %forListIobjKey
          ELSEIF itemType.ttype == Type.Enum.dyn
            type ..= "Dyn"
            noKey = %forListDyn
            withKey = %forListDynKey
          ELSEIF itemType.ttype == Type.Enum.enumValue
            type ..= "Enum"
            noKey = %forListEnum
            withKey = %forListEnumKey
          ELSEIF itemType.isFloatType()
            type ..= "Float"
            noKey = %forListFloat
            withKey = %forListFloatKey
          ELSEIF itemType.isValueType()
            type ..= "Int"
            noKey = %forListInt
            withKey = %forListIntKey
          ELSE
            type ..= "Ptr"
            noKey = %forListPtr
            withKey = %forListPtrKey
          }
          IF usingKey
            type ..= "Key"
            ctx.setDeclUsed(withKey)
          ELSE
            ctx.setDeclUsed(noKey)
          }
          ctx.setDeclUsed(%forList)

        CASE Type.Enum.dict
          loopType = LoopType.dict
          type = "Dict"
          ctx.setDeclUsed(%forDict)

        CASE Type.Enum.string
          type = "String"
          iterVarName = "&i" .. iterVarName

        CASE Type.Enum.byteString
          type = "Bytestring"
          iterVarName = "&i" .. iterVarName

        CASE Type.Enum.enum
        CASE Type.Enum.enumValue
          type = "Enum"
          iterVarName = "&" .. iterVarName

        CASE Type.Enum.int
        CASE Type.Enum.int8
        CASE Type.Enum.int16
        CASE Type.Enum.int32
        CASE Type.Enum.nat
        CASE Type.Enum.byte
        CASE Type.Enum.nat16
        CASE Type.Enum.nat32
        CASE Type.Enum.natval
        CASE Type.Enum.intval
          IF simpleForLoop(for, ctx)
            loopType = LoopType.simple
          ELSE
            type = "Range"
            iterVarName = "&" .. iterVarName
          }
      }

      SWITCH loopType
        CASE LoopType.simple
            IF !startOut.empty()
              startOut.write(", ")
            }
            startOut.write(loopVarName .. " = ")
            SContext startCtx = ctx.copy(startOut)
            genExpr(for.getIter(0), startCtx, Type.anInt)
            bool isContextFree = TRUE
            contOut.write(loopVarName)
            IF !for.hasStep() || ExprEval.evalInt(for.getStep(), ctx,
                                                     TRUE, &isContextFree) > 0
              contOut.write(" <= ")
            ELSE
              contOut.write(" >= ")
            }
            SContext contCtx = ctx.copy(contOut)
            genExpr(for.getTo(), contCtx, Type.anInt)
            IF !incOut.empty()
              incOut.write(", ")
            }
            IF !for.hasStep()
              incOut.write("++" .. loopVarName)
            ELSE
              incOut.write(loopVarName .. " += ")
              SContext incCtx = ctx.copy(contOut)
              genExpr(for.getStep(), incCtx, Type.anInt)
            }

        CASE LoopType.noIdx
          string typeName
          string cast
          IF varDecl.type.isValueType()
            IF varDecl.type.ttype == Type.Enum.enumValue
              typeName = "Enum"
            ELSEIF varDecl.type.isFloatType()
              typeName = "Float"
            ELSE
              typeName = "Int"
            }
            IF varDecl.type.isNatType()
              cast = "(Ti*)"
            ELSE
              cast = ""
            }
          ELSE
            typeName = "Ptr"
            cast = "(Tc **)"
          }
          IF !startOut.empty()
            startOut.write(", ")
          }
          startOut.write("Zfor" .. type .. "Get" .. typeName
                         .. "(" .. iterVarName .. ", "
                         .. cast .. "&" .. loopVarName .. ")")
          contOut.write("Zfor" .. type .. "Cont" .. typeName
                                                 .. "(" .. iterVarName .. ")")
          IF !incOut.empty()
            incOut.write(", ")
          }
          incOut.write("Zfor" .. type .. "Next" .. typeName .. "("
                 .. iterVarName .. ", " .. cast ..  "&" .. loopVarName .. ")")

        CASE LoopType.array
        CASE LoopType.list
        CASE LoopType.dict
          int valIdx = idx
          IF usingKey || loopType != LoopType.list
            # For a list without using the key "keyp" is not used.
            declOut.writeIndent(ctx.scope.depth + 1)
            declOut.write(iter.varDecl.pName)
            declOut.write("i.keyp = ")
            IF usingKey
              declOut.write("(void*)&")
              declOut.write(loopVarName)
              declOut.write(";\n")
              valIdx = 1
            ELSE
              declOut.write("NULL;\n")
            }
          }

          declOut.writeIndent(ctx.scope.depth + 1)
          declOut.write(iter.varDecl.pName)
          declOut.write("i.valp = (void*)&")
          declOut.write(varList[valIdx].pName)
          declOut.write(";\n")

          IF loopType != LoopType.dict
            declOut.writeIndent(ctx.scope.depth + 1)
            declOut.write(iter.varDecl.pName)
            declOut.write("i.i = 0;\n")
          }

          IF loopType == LoopType.dict
            IF !startOut.empty()
              startOut.write(", ")
            }
            startOut.write("ZforDictStart(&" .. iter.varDecl.pName .. "i)")
          }
          contOut.write("Zfor" .. type .. "Cont(&"
                                                .. iter.varDecl.pName .. "i)")
          IF loopType == LoopType.dict
            IF !incOut.empty()
              incOut.write(", ")
            }
            incOut.write("ZforDictNext(&" .. iter.varDecl.pName .. "i)")
          }
      }
    }

    out.append(declOut)
    out.writeIndent(ctx.scope.depth + 1)
    out.write("for (")
    out.append(startOut)
    out.write("; ")
    out.append(contOut)
    out.write("; ")
    out.append(incOut)
    out.write(") {\n")
  }

  PROC $forEnd(Zui.Statement stmt, SContext ctx)
    IF $isDeclUsed(%pthread) && $manageMemory()
                                             && $isDeclUsed(Declaration.gcRun)
      ctx.out.writeIndent(ctx.scope.depth + 1)
      ctx.out.write("if (e->wantGC) ZthreadGC();\n")
    }
    # Write the position of the FOR, that's what happens next.
    ctx.out.write(" ")  # onle extra level of indent
    $beforeStatement(stmt, ctx)
  }

  # A BREAK statement that jumps to a FINALLY.
  PROC $writeBreakGotoFinally(Scope s, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("did_goto_finally = " .. scopeBreak)
    IF ctx.scope.scopeType == Scope.Stype.try
      # In the TRY scope, jump to FINALLY directly.
      ctx.out.write("; goto " .. s.<TryScope>.finallyLabelName)
    ELSE
      # Inside a scope in the TRY scope, jump to end of scope first.
      IF ctx.scope.retLabel == NIL
        ctx.scope.retLabel = getUid(ctx.scope.scopeName)
      }
      ctx.out.write("; goto " .. ctx.scope.retLabel)
    }
    $statementLineEnd(ctx.out)
  }

  # A BREAK statement that finishes a loop.
  PROC $writeBreak(SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("rt = " .. scopeBreak)
    # The jump to retLabel is not needed, this is always the end of the block.
    ctx.out.write(";\n")
  }

  # A CONTINUE statement that jumps to a FINALLY.
  PROC $writeContinueGotoFinally(Scope s, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("did_goto_finally = " .. scopeContinue)
    IF ctx.scope.scopeType == Scope.Stype.try
      # In the TRY scope, jump to FINALLY directly.
      ctx.out.write("; goto " .. s.<TryScope>.finallyLabelName)
    ELSE
      # Inside a scope in the TRY scope, the jump to retLabel is not needed,
      # this is always the end of the block.
    }
    $statementLineEnd(ctx.out)
  }

  # A CONTINUE statement that finishes a loop.
  PROC $writeContinue(SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("rt = " .. scopeContinue)
    # The jump to retLabel is not needed, this is always the end of the block.
    ctx.out.write(";\n")
  }

  # UNITL of a DO block.
  FUNC $until(Zui.Condition cond, SContext ctx) int
    RETURN until(cond, ctx)
  }

  # Write the start of a type cast to |type| and return what needs to be
  # written to close it (usually a ")").
  FUNC $typecast(Type type, SContext ctx) string
    RETURN $ptrTypecast(type, FALSE, ctx)
  }

  FUNC $ptrTypecast(Type type, bool ptr, SContext ctx) string
    string tail = ptr ? " **)" : " *)"
    Type rtype = type
    IF rtype.ttype == Type.Enum.byRef
      rtype = rtype.<ReferenceType>.reference
      tail = ptr ? " ***)" : " **)"
    }
    IF rtype.ttype == Type.Enum.object && rtype.getClassType(ctx) != NIL
      rtype = rtype.getClassType(ctx)
    }
    IF rtype.ttype == Type.Enum.class
      ctx.out.write("((" .. rtype.pName .. tail)
      RETURN ")"
    }
    IF rtype.ttype == Type.Enum.iobject
      ctx.out.write("((Tr" .. tail)
      RETURN ")"
    }
    IF rtype.ttype == Type.Enum.array
      ctx.out.write("((Ta" .. tail)
      RETURN ")"
    }
    IF rtype.ttype == Type.Enum.list
      ctx.out.write("((Tl" .. tail)
      RETURN ")"
    }
    IF rtype.ttype == Type.Enum.string
       || rtype.ttype == Type.Enum.byteString
      ctx.out.write("((Tc" .. tail)
      RETURN ")"
    }
    IF rtype.ttype == Type.Enum.varString
       || rtype.ttype == Type.Enum.varByteString
      ctx.setDeclUsed(%varByteStringType)
      ctx.out.write("((Ty" .. tail)
      RETURN ")"
    }
    RETURN ""
  }

  PROC $throw(Zui.Statement stmt, bool hasNextStmt, Type type, SContext ctx)
    Output out = ctx.out
    IF !out.writing
      RETURN
    }

    bool throwString = type != NIL && type.ttype == Type.Enum.string
    Type throwType = type

    # Need to evaluate the expression before writeScopeEnd().
    IF !ctx.scope.hasEvar
      ctx.scope.hasEvar = TRUE
      ctx.outs.varOut.writeIndent(ctx.scope.depth)
      IF throwString
        ctx.outs.varOut.write("void *ex = NULL;\n")
      ELSE
        ctx.outs.varOut.write("Tr ex;\n")
      }
    }
    out.writeIndent(ctx.scope.depth)
    IF throwString
      out.write("ex = ")
    ELSE
      throwType = NoAllocType.NEW(type, "ex")
      throwType.<NoAllocType>.iobjectType = throwType
      throwType.pName = "ex"
    }
    Generate.genExprDoConv(stmt.getExpr(), ctx, throwType)
    out.write(";\n")

    # Other scopes may jump here.
    IF ctx.scope.retLabel != NIL
      ctx.out.write(ctx.scope.retLabel)
      ctx.out.write(":\n")
    }

    # When jumped here from a RETURN don't throw the exception.
    int indent = ctx.scope.depth
    IF ctx.scope.needRetFlag
      out.writeIndent(ctx.scope.depth)
      out.write("if (!rt) {\n")
      ++indent
    }

    out.writeIndent(indent)
    IF throwString
      out.write("ZthrowPos(")
      out.write($getPosNumber(stmt.getPos(), ctx))
      out.write(", ex);\n")
    ELSE
      out.write("ZthrowIobject(ex);\n")
    }

    IF ctx.scope.needRetFlag
      out.writeIndent(ctx.scope.depth)
      out.write("}\n")

      # Leaving the scope.  Not needed when throwing an exception,
      # ZthrowObject() will do the dereferencing.
      $writeScopeEnd(FALSE, FALSE, NIL, stmt.getPos(), ctx)
    }

    # A THROW at the end of a function won't be followed by a RETURN, but we
    # need a "return" to avoid a compiler warning.
    IF !hasNextStmt && ctx.scope ISA MethodScope
      IF ctx.scope.needRetFlag
        $writeBeforeReturn(stmt.getPos(), ctx)
      }
      IF ctx.scope.returnType != NIL
        IF ctx.scope.needRetFlag
          out.writeIndent(ctx.scope.depth)
          out.write("return r;\n")
        ELSE
          $writeNilReturn(ctx, out)
        }
      }
    }
  }

  # Return the code to write to get the environment pointer.
  # When not using threads there is only one: Zenv;
  # When using threads call a function to get the per-thread environment.
  FUNC $getEnvCode() string
    IF $isDeclUsed(%pthread)
      RETURN "ZgetEnv()"
    }
    RETURN "(&Zenv)"
  }

  PROC $try_block(Zui.Statement stmt, SContext ctx)
    Output out = ctx.out
    out.writeIndent(ctx.scope.depth)
    out.write("volatile int caught = 0;\n")
    out.writeIndent(ctx.scope.depth)
    out.write("Tn *te = " .. $getEnvCode() .. ";\n")
    out.writeIndent(ctx.scope.depth)
    out.write("int try_index = te->tryCtxUsed;\n")
    out.writeIndent(ctx.scope.depth)
    out.write("volatile int did_jump = 0;\n")

    $beforeStatement(stmt.getPos(), TRUE, ctx)
    out.writeIndent(ctx.scope.depth)
    out.write("ZtryDeeper(te, ")
    IF $doStackFrame(ctx)
      out.write("&sf")
    ELSE
      out.write($topFrameName())
    }
    out.write(");\n")

    Zui.TryStatement tryStmt = stmt.getTry()
    TryScope tryScope = ZuiTryStatementExt.get(tryStmt).scope
    IF tryStmt.hasFinally() && (tryScope.foundReturn
                             || tryScope.foundBreak || tryScope.foundContinue)
      out.writeIndent(ctx.scope.depth)
      out.write("int did_goto_finally = 0;\n")
    }
    out.writeIndent(ctx.scope.depth)
    out.write("if (setjmp(te->tryCtx[try_index].jmpBuf) != 0) {\n")
    out.writeIndent(ctx.scope.depth + 1)
    out.write("++did_jump;\n")
    IF $doStackFrame(ctx)
      out.writeIndent(ctx.scope.depth + 1)
      out.write($topFrameName())
      out.write(" = &sf;\n")
    }
    out.writeIndent(ctx.scope.depth)
    out.write("}\n")
    out.writeIndent(ctx.scope.depth)
    out.write("if (did_jump == 0) /* TRY */\n")
  }

  PROC $try_block_end(Zui.Statement stmt, SContext ctx)
    IF !stmt.getTry().hasFinally()
      # no FINALLY, don't catch exceptions with this TRY
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("te->tryCtxUsed = try_index;\n")
    }
  }

  PROC $try_catch(Zui.Catch catch, list<Type> typeList, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("if (did_jump == 1 && !caught && (")
    bool didOne
    FOR type IN typeList
      IF didOne
        ctx.out.write(" || ")
      }
      $writeIsa(NIL, FALSE, type, catch.getPos(), ctx)
      didOne = TRUE
    }
    ctx.out.write(")) /* CATCH */\n")
  }

  PROC $topException(Declaration.C destDecl, Zui.Position pos,
                                              SContext ctx, SContext blockCtx)
    ctx.out.write("te->thrown[--te->thrownUsed]")
    IF destDecl.type.ttype == Type.Enum.iobject
                                    || destDecl.type.ttype == Type.Enum.object
      IF destDecl.type.ttype == Type.Enum.object
        ctx.out.write(".ptr")
      }
    ELSE
      ctx.error("Unexpected symbol type: " .. destDecl.ToString(), pos)
    }
  }

  PROC $try_else(Zui.Statement stmt, SContext ctx)
    IF !stmt.getTry().hasFinally()
      # There is FINALLY, no longer let an exception be caught by this TRY.
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("te->tryCtxUsed = try_index;\n")
    }
    # Exceptions thrown here are like in a CATCH block.
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("did_jump = 1; caught = 1; /* ELSE */\n")
  }

  PROC $try_finally(Zui.Statement stmt, SContext ctx)
    Zui.TryStatement tryStmt = stmt.getTry()
    TryScope tryScope = ZuiTryStatementExt.get(tryStmt).scope
    IF tryScope.foundReturn || tryScope.foundBreak || tryScope.foundContinue
      ctx.out.write(tryScope.finallyLabelName .. ":\n")
    }

    # No longer let an exception be caught by this TRY
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("te->tryCtxUsed = try_index; /* FINALLY */\n")
  }

  PROC $try_end(Zui.Statement stmt, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    # Rethrow when an exception brought us back here and it wasn't caught or
    # when a catch of finally block threw an exception.
    ctx.out.write("if ((did_jump == 1 && !caught) || did_jump > 1) Zrethrow();\n")

    Zui.TryStatement tryStmt = stmt.getTry()
    TryScope tryScope = ZuiTryStatementExt.get(tryStmt).scope

    # This is only needed if there is a FINALLY.
    IF tryStmt.hasFinally()
           && (tryScope.foundReturn
            || tryScope.foundBreak
            || tryScope.foundContinue)
      # handle a RETURN before the FINALLY
      # handle a BREAK before the FINALLY
      # handle a CONTINUE before the FINALLY
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("if (did_goto_finally != 0) {\n")
      ++ctx.scope.depth
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("rt = did_goto_finally;\n")
      ctx.out.writeIndent(ctx.scope.depth)
      $writeJumpToLabel(ctx)
      --ctx.scope.depth
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("}\n")
    }
  }

  PROC $ifnilExpr(SContext ctx)
    IF ctx.scope.isClassScope() && ctx.scope.thisName != NIL
      ctx.out.write(ctx.scope.thisName)
    ELSE
      ctx.out.write("Athis")
    }
    ctx.out.write(" == NULL")
  }

  # Return the code to write at the start of a function to add a backtrace
  # frame.
  FUNC $stackDeeper(string indent) string
    IF $isDeclUsed(%pthread)
      RETURN indent .. "Tn *e = ZgetEnv();\n"
          .. indent .. "Zsf sf;\n"
    }
    RETURN indent .. "Zsf sf;\n"
  }

  # Return the code to init the stack frame at the start of a function.
  # This is after "sf.frof" has been set, unless |ctx| is NIL.
  # "sf.pos" must have been set, unless |initPos| is FALSE.
  FUNC $initStackFrame(string indent, bool initPos, SContext ctx) string
    IO.StringWriter w = NEW()
    w.write(indent .. "sf.prev = ")
    IF $isDeclUsed(%pthread)
      w.write("e->topFrame")
    ELSE
      w.write("topFrame")
    }
    w.write(";\n")

    bool mayCallDoGC = $isDeclUsed(%pthread) && $manageMemory()
                                             && $isDeclUsed(Declaration.gcRun)
    IF initPos
      # The position won't be set, make it zero (plus UNSAFE bit).
      w.write(indent)
      IF mayCallDoGC || ManageMemory.isExitclean()
        w.write("sf.pos = 0x40000000;\n")
      ELSE
        w.write("sf.pos = 0;\n")
      }
    }
    IF ctx == NIL
      # The frof field won't be set, make it NULL.
      w.write(indent .. "sf.frof = NULL;\n")
    }

    w.write(indent)
    IF $isDeclUsed(%pthread)
      w.write("e->topFrame")
    ELSE
      w.write("topFrame")
    }
    w.write(" = &sf;\n")

    IF mayCallDoGC
      w.write(" if (e->wantGC) ZthreadGC();\n")
    }

    RETURN w.ToString()
  }

  PROC $setStackPos(Zui.Position pos, bool pauseGC, SContext ctx)
    IF ctx.out.writing && !ctx.scope.noBacktrace && !Config.noBacktrace
                                                       && !ctx.scope.primitive
      ctx.out.writeIndent(ctx.scope.depth + 1)
      $writeSetStackPos(pos, pauseGC, ctx)
      ctx.out.write(";\n")
    }
  }

  # Like $setStackPos but as a single statement, no indent or ';'.
  # When |pauseGC| is TRUE something is about to happen where GC is not safe.
  # Return TRUE when something was written.
  FUNC $writeSetStackPos(Z.Pos pos, bool pauseGC, SContext ctx) bool
    int idx = CodeTable.addEntry(ctx.scope.fullName(), pos)
    IF pauseGC && $manageMemory()
      idx += pauseGCOffset
    }
    ctx.out.write("sf.pos=" .. idx)
    RETURN TRUE
  }

  FUNC $writeSetStackPos(Zui.Position pos, bool pauseGC, SContext ctx) bool
    int idx = CodeTable.addEntry(ctx.scope.fullName(), ctx.zcPos(pos))
    IF pauseGC && $manageMemory()
      idx += pauseGCOffset
    }
    ctx.out.write("sf.pos=" .. idx)
    RETURN TRUE
  }

  # Get a position number and return it as a string, to be used as a function
  # argument.
  FUNC $getPosNumber(Z.Pos pos, SContext ctx) string
    RETURN CodeTable.addEntry(ctx.scope.fullName(), pos)
  }

  # Get a position number and return it as a string, to be used as a function
  # argument.
  FUNC $getPosNumber(Zui.Position pos, SContext ctx) string
    RETURN CodeTable.addEntry(ctx.scope.fullName(), ctx.zcPos(pos))
  }

  FUNC $needPauseGC(Zui.Statement stmt) bool
    VAR stmtExt = ZuiStatementExt.get(stmt)
    RETURN stmtExt.props.methodCall || stmtExt.props.allocMem
                                                          || stmt.getBlockgc()
  }

  PROC $beforeStatement(Zui.Statement stmt, SContext ctx)
    $beforeStatement(stmt.getPos(), $needPauseGC(stmt), ctx)
  }

  PROC $beforeStatement(Zui.Position pos, Zui.Statement stmt, SContext ctx)
    $beforeStatement(pos, $needPauseGC(stmt), ctx)
  }

  PROC $beforeStatement(Zui.Position pos, bool pauseGC, SContext ctx)
    IF ctx.out.writing && !ctx.scope.noBacktrace && !Config.noBacktrace
                                                       && !ctx.scope.primitive
      ctx.out.writeIndent(ctx.scope.depth)
      $writeSetStackPos(pos, pauseGC, ctx)
      ctx.out.write(";\n")
      ctx.scope.wantBacktrace = TRUE
    }
  }

  PROC $beforeCallStatement(Zui.Position pos, SContext ctx)
    $beforeStatement(pos, TRUE, ctx)
  }

  PROC $afterStatement(Zui.Statement stmt, SContext ctx)
    IF stmt.getBlockgc() && $isDeclUsed(%pthread)
                          && $manageMemory() && $isDeclUsed(Declaration.gcRun)
      # Disabled the GC, may need to check the wantGC flag now.
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("if (e->wantGC) ZthreadGC();\n")
    }
  }

  PROC $afterCall(SContext ctx)
    IF ctx.out.writing && !ctx.scope.noBacktrace && !Config.noBacktrace
      ctx.out.write(")")
    }
  }

  # Write a call statement.
  PROC $callStatement(Type retType, Output callOut, SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.append(callOut)
    $statementLineEnd(ctx.out)
  }

  PROC $returnBefore(bool proc, bool multi, SContext ctx)
    IF !proc
      ctx.out.writeIndent(ctx.scope.depth)
      IF multi
        ctx.out.write("r.a0 = ")
      ELSE
        ctx.out.write("r = ")
      }
    }
  }

  PROC $returnAfter(Type returnType, bool writeScopeEnd,
                                               Zui.Position pos, SContext ctx)
    Scope s = ctx.scope.tryScope(FALSE, FALSE)
    IF s != NIL && s.<TryScope>.hasFinally
      # We are inside a TRY that has a FINALLY, jump there.
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("did_goto_finally = " .. scopeReturn)
      ctx.out.write("; goto " .. s.<TryScope>.finallyLabelName .. ";\n")
    ELSE
      $writeReturn(returnType, writeScopeEnd, pos, ctx)
    }
  }

  # RETURN halfway a MethodScope: jump to the return at the end.
  PROC $jumpToReturn(SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("goto ")
    IF ctx.scope.retLabel == NIL
      ctx.scope.retLabel = getUid(ctx.scope.scopeName)
    }
    ctx.out.write(ctx.scope.retLabel)
    $statementLineEnd(ctx.out)
  }

  # Extra argument for RETURN.
  # expr.undefined will be set.
  PROC $extraReturn(Zui.Expression expr, int idx, SContext ctx, Type destType)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("r.a" .. idx .. " = ")
    Generate.genTopExprDoConv(expr, ctx, destType)
    ctx.out.write(";\n")
  }

  # RETURN in an inner scope: set "rt" flag and jump to the end of the outer
  # scope.
  PROC $jumpToOuterScope(SContext ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    ctx.out.write("rt = 1;\n")
    ctx.out.writeIndent(ctx.scope.depth)
    $writeJumpToLabel(ctx)
  }

  # Write code to exit, before evaluating the argument.
  PROC $exitBefore(Zui.Statement stmt, SContext ctx)
    ctx.out.write("Zexit(")
    IF $isDeclUsed(Declaration.try)
      # The position is only needed for throwing an exception.
      ctx.out.write(newPosString(stmt.getPos(), ctx))
    ELSE
      ctx.out.write("NULL")
    }
    ctx.out.write(", ")
  }

  # Write code to exit, after evaluating the argument.
  PROC $exitAfter(bool lastStatement, SContext ctx)
    ctx.out.write(");\n")
    IF lastStatement && ctx.scope.returnType != NIL
      # Avoid a compiler warning for a missing return value.
      $writeNilReturn(ctx, ctx.out)
    }
  }

  # Write code to return from a method.
  PROC $writeReturn(Type returnType, bool writeScopeEnd,
                                               Zui.Position pos, SContext ctx)
    IF writeScopeEnd
      $writeScopeEnd(TRUE, TRUE, NIL, pos, ctx)
    }
    IF returnType != NIL && ctx.scope.flags.insideFinish
                                         && $isDeclUsed(Declaration.hasFinish)
      # When returning OK set the flag that Finish() is no longer executable.
      ctx.out.writeIndent(ctx.scope.depth)
      ctx.out.write("if (r) t->fok |= FOK_OK;\n")
    }
    $writeBeforeReturn(pos, ctx)
    ctx.out.writeIndent(ctx.scope.depth)
    IF returnType == NIL
      ctx.out.write("return;\n")
    ELSE
      ctx.out.write("return r;\n")
    }
  }

  PROC $writeBacktrace(Zui.MethodCall call, SContext ctx)
    $setDeclUsed(WriteListC.listAdd)
    ctx.scope.wantBacktrace = TRUE
    ctx.out.write("(")
    bool didStackPos = $writeSetStackPos(call.getPos(), TRUE, ctx)
    IF didStackPos
      ctx.out.write(", ")
    }
    ctx.out.write("MZ__backtrace(")
    IF call.sizeArgument() == 0
      ctx.out.write("0")
    ELSE
      Generate.genExpr(call.getArgument(0), ctx, Type.anInt)
    }
    ctx.out.write(", ")
    IF call.sizeArgument() < 2
      ctx.out.write("-1")
    ELSE
      Generate.genExpr(call.getArgument(1), ctx, Type.anInt)
    }
    ctx.out.write("))")
  }

  # Write code to create a Pos with the position of the caller.
  PROC $writeCallerPos(SContext ctx)
    ctx.out.write("MZ__callerPos()")
  }

  # Write a comment about declaring |decl| in |scopeName|.
  PROC $declComment(string scopeName, Declaration decl, Output out) @private
    IF decl.pName[0] != 'V' && decl.pName[0] != 't'
                                               && !decl.pName.startsWith("Zf")
      out.write(" /* " .. scopeName .. "." .. decl.name .. " */")
    }
  }

  # Return TRUE when a module needs to be generated.
  FUNC $doGenerateModule(SContext ctx) bool
    RETURN ctx.scope.usedAsZimbu()
  }

  PROC $moduleType(ModuleType mt, SContext ctx)
    string pName
    # TODO: don't always generate
    # IF enumType.usedEnumName != NIL && $isDeclUsed(enumType.usedEnumName)
      pName = $writeStaticString(mt.name, ctx)
    # }
    Output out = ctx.outs.declOut
    out.write("Tt " .. mt.name .. "__T = {4, ")
    IF pName != NIL
      out.write("((Tc*)&" .. pName .. ")")
    ELSE
      out.write("0")
    }
    out.write(", 0};\n")
  }

  # Set dependencies of used items.  This is called before marking used items
  # in Main().
  PROC $addDependencies()
    FOR fragment IN fragments
      # Add dependencies defined by strings.  These can only be found after
      # resolving symbols.
      IF fragment.stringDeps != NIL
        IF fragment.dependencies == NIL
          fragment.dependencies = NEW()
        }
        FOR dep IN fragment.stringDeps
          fragment.dependencies.add(DeclStore.getDecl(dep[0], dep[1]))
        }
      }

      IF fragment.dependencies != NIL
        $setDeclDependency(fragment.decl, fragment.dependencies)
      }

      IF fragment.condDeps != NIL
        FOR cd IN fragment.condDeps
          IF cd.dep == NIL
            cd.dep = DeclStore.getDecl(cd.stringDep[0], cd.stringDep[1])
          }
          $setDeclCondDependency(fragment.decl, cd.cond, cd.dep)
        }
      }
    }

    $setDeclDependency(Declaration.dict, %string_h)
    $setDeclDependency(Declaration.try, %setjmp_h)
    Declaration.itemToString.addDependsOn(%garray)
    Declaration.itemToString.addDependsOn(%iobjType)

    WriteArrayC.addDependencies(THIS)
    WriteDictC.addDependencies(THIS)
    WriteListC.addDependencies(THIS)
  }

  # Set used flags for dependencies of used items.
  PROC $markUsed()
    # Used in Fmain().
    $setDeclUsed(Declaration.throwCstringInit)

    # used in Zdeadly()
    $setDeclUsed(Declaration.throwDeadly)

    # used in Za()
    $setDeclUsed(Declaration.throwOutOfMemory)

    # Items that are always used.
    # TODO: Only use when needed.
    $setDeclUsed(DeclStore.getDecl("MZModule", "CPos"))

    # Disable memory management when it does not work with threads.
    ManageMemory.checkForThreads(THIS)

    IF ManageMemory.isExitclean()
      $setDeclUsed(Declaration.gcRun)
      $setDeclUsed(Declaration.throwInternal)
    }

    IF $isDeclUsed(%pthread)
      IF ManageMemory.manageLinked()
        # TODO: only when actually managing memory
        $setDeclUsed(WriteListC.listGetPtr)
      ELSE
        # TODO: not always?
        $setDeclUsed(%zfree)
      }
      $setDeclUsed(WriteListC.listFind)
      $setDeclUsed(WriteListC.listRemovePtrItem)
    }

    IF ManageMemory.manageMemory(THIS)
      # TODO: only when actually managing memory
      $setDeclUsed(DeclStore.getDecl("MTIMEModule", "Fcurrent"))
    }
  }

  # Generate global items.
  PROC $writeGlobals(SContext ctx)
    # Generate the "NIL" string: ZNilString.
    $writeStaticString("NIL", ctx)

    # Generate callback declarations.
    CallbackType.generateCallbacks(ctx)

    # Generate tuple declarations.
    TupleType.generateTuples(ctx)
  }

  # Write C code from |outputs| into outFile.
  PROC $writeFile(UsedFile usedFile, SContext ctx,
                                        Output.Group outputs, IO.File outFile)
    $writeIncludes(ctx.topScope, outFile)

    outFile.write("/*\n * TYPEDEFS\n */\n")
    $writeTypedefs(outFile)
    outputs.typeOut.writeToFile(outFile)

    outFile.write("/*\n * STRUCTS\n */\n")
    $writeDecl(ctx, outFile)
    outputs.structOut.writeToFile(outFile)

    outFile.write("/*\n * DECLARE FUNCTIONS AND GLOBALS\n */\n")
    outputs.declOut.writeToFile(outFile)
    outFile.write("\n")

    $writeStaticTable(outFile, ctx)

    outFile.write("int ZglobInit(int round);\n")
    $writeBodies(outFile)

    outFile.write("/*\n * FUNCTION BODIES\n */\n")
    outputs.bodyOut.writeToFile(outFile)

    outFile.write("/*\n * INIT IMT\n */\n")
    outFile.write("void ZimtInit(void) {\n")
    outputs.imtInitOut.writeToFile(outFile)
    outFile.write("}\n\n")

    outFile.write("/*\n * INIT GLOBALS\n */\n")
    outFile.write("int ZglobInit(int round) {\n")
    outFile.write(" int done = 1;\n")

    MethodScope ms = usedFile.zimbuFile.initScope
    IF ms != NIL && ms.tempVars != NIL
      FOR decl IN ms.tempVars
        outFile.write(" ")
        outFile.write($vartypeString(decl.type, TRUE, decl.zuiPos, ctx))
        outFile.write(decl.pName)
        outFile.write(";\n")
      }
    }

    IF !Config.noBacktrace || $manageMemory()
      outFile.write($stackDeeper(" "))
    }
    IF !Config.noBacktrace || $manageMemory()
      outFile.write($initStackFrame(" ", TRUE, NIL))
    }

    IF !outputs.earlyInitOut.empty()
      IF outputs.earlyInitLead != NIL
        outFile.write(outputs.earlyInitLead)
      }
      outputs.earlyInitOut.writeToFile(outFile)
      IF outputs.earlyInitLead != NIL
        outFile.write(" }\n")
      }
    }

    IF !outputs.initOut.empty()
      IF outputs.initLead != NIL
        outFile.write(outputs.initLead)
      }
      outputs.initOut.writeToFile(outFile)
      IF outputs.initLead != NIL
        outFile.write(" }\n")
      }
    }

    IF !Config.noBacktrace || $manageMemory()
      outFile.write(" ")
      outFile.write($stackBack())
    }
    outFile.write(" return done;\n")
    outFile.write("}\n\n")

    outFile.write("/*\n * MAIN\n */\n")
    outputs.mainOut.writeToFile(outFile)
  }

  # Write the required "#include" lines to |fd|.
  PROC $writeIncludes(TopScope topScope, IO.File fd)
    IF $isDeclUsed(%string_h)
      fd.write("#include <string.h>\n")
    }
    fd.write("#include <errno.h>\n")
    # always needed for malloc() and calloc()
    fd.write("#include <stdlib.h>\n")

    # Also needed for getpid().
    IF $isDeclUsed(%unistd) || ManageMemory.isExitclean()
      fd.write("#include <unistd.h>\n")
    }
    IF $isDeclUsed(%sys_types)
      fd.write("#include <sys/types.h>\n")
    }
    IF $isDeclUsed(%dirent)
      fd.write("#include <dirent.h>\n")
    }
    IF $isDeclUsed(%limits)
      fd.write("#include <limits.h>\n")
    }
    # always needed for _O_BINARY
    fd.write("#include <fcntl.h>\n")
    IF $isDeclUsed(%sys_stat)
      fd.write("#include <sys/stat.h>\n")
    }
    IF $isDeclUsed(%pthread)
      Config.addThreadLib()  # adds -lpthread to the build command
      fd.write("#include <pthread.h>\n")
    }
    IF $isDeclUsed(%math) || mathUsed
      Config.addMathLib()    # adds -lm to the build command
      fd.write("#include <math.h>\n")
    }
    IF $isDeclUsed(%ctype_h)
      fd.write("#include <ctype.h>\n")
    }
    fd.write("#include <stdio.h>\n")   # always needed for NULL
    fd.write("#include <signal.h>\n")  # always needed for SIGSEGV

    IF $catchSignals() || $gcSignal()
      fd.write(''"#if defined(__MINGW32__) || defined(_MSC_VER)
# define GC_SIG SIGABRT
# include <excpt.h>
#else
# define GC_SIG SIGUSR2
#endif
"'')
    }

    IF $isDeclUsed(%setjmp_h)
      fd.write("#include <setjmp.h>\n")  # needed for jmp_buf
    }
    IF $isDeclUsed(%sys_time)
      fd.write("#include <sys/time.h>\n")
    }
    IF $isDeclUsed(%termios)
      fd.write("#include <termios.h>\n")
    }
    IF $isDeclUsed(%time_h)
      fd.write("#include <time.h>\n")
    }
    IF $isDeclUsed(%errno)
      fd.write("#include <errno.h>\n")
    }
    IF $isDeclUsed(%sys_wait)
      fd.write("#ifndef __MINGW32__\n")
      fd.write("# define HAVE_FORK\n")  # for SYS.Process
      fd.write("# include <sys/wait.h>\n")
      fd.write("#endif\n")
    }
    IF $isDeclUsed(%windows_h)
      fd.write("#ifdef __MINGW32__\n")
      fd.write("# include <windows.h>\n")
      fd.write("# undef THIS\n")
      fd.write("# undef small\n")
      fd.write("#endif\n")
    }

    IF $isDeclUsed(%socket)
      Config.addSocketLib()  # may add -l argument to the build command

      # On WIN32 (MingW) use winsock.  And remove name space pollution.
      # setsockopt() declaration is not according to POSIX.
      # Define missing socklen_t.
      fd.write(''"
#ifdef WIN32
# include <winsock.h>
# include <winsock2.h>
# undef THIS
# undef small
  typedef int socklen_t;
# if defined _WIN32 || defined __WIN32__
#  define setsockopt(a,b,c,d,e) setsockopt(a,b,c,(const void*)(d),e)
# endif
# define sckt_read(a, b, c) recv(a, b, c, 0)
# define sckt_write(a, b, c) send(a, b, c, 0)
# define sckt_close(a) closesocket(a)
#else
# define sckt_read(a, b, c) read(a, b, c)
# define sckt_write(a, b, c) write(a, b, c)
# define sckt_close(a) close(a)
# include <sys/socket.h>
# include <netinet/in.h>
# include <arpa/inet.h>
#endif
"'')
    }
    IF $isDeclUsed(%hostname)
      fd.write(''"
#include <netdb.h>
"'')
    }

    # Included through IMPORT.CHEADER.
    FOR cheader IN topScope.cheaders
      fd.write("#include " .. cheader .. "\n")
    }

    fd.write("\n")
  }

  # Write all needed typedefs to |fd|.
  PROC $writeTypedefs(IO.File fd)
    # MingW has a different format for "long long".  When producing portable
    # code include an #ifdef, so that it works on most systems.
    IF Config.portableFlag.get() && Config.int64name == "long long"
      fd.write(''"
#ifdef __MINGW32__
# define ZINT_FORMAT "%I64d"
# define ZNAT_FORMAT "%I64u"
# define ZINT_XFORMAT "%I64x"
#else
# define ZINT_FORMAT "%lld"
# define ZNAT_FORMAT "%llu"
# define ZINT_XFORMAT "%llx"
#endif
"'')
    ELSE
      fd.write("#define ZINT_FORMAT \"" .. Config.printIntFormat .. "\"\n")
      fd.write("#define ZNAT_FORMAT \"" .. Config.printNatFormat .. "\"\n")
      fd.write("#define ZINT_XFORMAT \"" .. Config.scanfHexFormat .. "\"\n")
    }
    fd.write("#define ZFLOAT_FORMAT \"%g\"\n")
    fd.write("typedef " .. Config.int64name .. " Ti; /* int */\n")
    fd.write("typedef " .. Config.int16name .. " Ti16; /* int16 */\n")
    fd.write("typedef " .. Config.int32name .. " Ti32; /* int32 */\n")
    fd.write("typedef " .. Config.nat64name .. " Tu; /* nat */\n")
    fd.write("typedef unsigned char Tc; /* byte */\n")
    fd.write("typedef " .. Config.nat16name .. " Tu16; /* nat16 */\n")
    fd.write("typedef " .. Config.nat32name .. " Tu32; /* nat32 */\n")
    fd.write("typedef " .. Config.floatName .. " Tf; /* float */\n")
    fd.write("typedef " .. Config.float32name .. " Tf32; /* float32 */\n")
    fd.write("typedef " .. Config.intPtrName .. " Tip; /* int for pointer */\n")
    fd.write("typedef " .. Config.int64name .. " Tbb; /* big BITS */\n")
    fd.write(''"
typedef int Tbs; /* small BITS */
typedef int Tb; /* bool */
typedef int Ts; /* status */
typedef int Te; /* enum */
typedef struct Zref__S Tr; /* object ref */
typedef struct Zobj__S To; /* object description */
typedef union {
 Ti ival;
 Tf fval;
 void *ptr;
} Tz; /* dyn value */
"'')
    IF $isDeclUsed(Type.aDyn)
      fd.write("typedef struct Zdyn__S Tx; /* dyn */\n")
    }
    fd.write("typedef struct Ztype__S Tt; /* type */\n")
    fd.write("typedef struct Ztypeo__S Tto; /* type with To pointer */\n")
    IF $hasNpField()
      # Header used for objects when using GC.
      # Also used for objects with a Finish method.
      fd.write("typedef struct Zoh__S Zoh; /* allocated memory header */\n")
      fd.write("struct Zoh__S {\n")
      fd.write(linkedDecl)
      fd.write("};\n")
    }
    IF $hasNpField()
      fd.write("#define ZOH_OFF sizeof(Zoh)\n")

      # Marker for items in static memory, not allocated.
      # GC may free items in it, not the item itself.
      fd.write("Zoh Zstatic;\n")

      # Marker for items on the stack, not allocated.
      # GC may free items in it, not the item itself.
      fd.write("Zoh Znoalloc;\n")

      # Marker for last item in the "firstUsed" list.
      fd.write("Zoh Zlast;\n")
      IF $isDeclUsed(Declaration.hasFinish)
        fd.write("#define ZOHF_LAST (Zohf*)&Zlast\n")
      }

      # Zop: object pointer with type.
      fd.write(''"typedef struct {
 void *var;
 Tt   *type;
} Zop;
"'')

      IF $isDeclUsed(Declaration.gcRun)
        # Zgcb: block with objects to be marked
        # It is fixed size to make allocation more efficient, should just fit
        # in a 8 Kbyte page.
        fd.write(''"#define GC_BLOCK_SIZE 1022
typedef struct Zgcb__S Zgcb;
struct Zgcb__S {
 Zgcb *next;
 int used;
 Zop items[GC_BLOCK_SIZE];
};
"'')

        # Zgcs: GC status
        # Zgcs.todo: list of blocks with objects to be marked
        # Zgcs.empty: list of empty blocks
        fd.write(''"typedef struct {
 Zgcb *todo;
 Zgcb *empty;
} Zgcs;
"'')
      }
    ELSE
      fd.write("#define ZOH_OFF 0\n")
    }

    # Zohf: same as Zoh but with the "fok" flag for objects with Finish().
    # And a "to" field to know what object type it is.
    # Also used without GC, when there is a Finish method.
    IF $isDeclUsed(Declaration.hasFinish)
      fd.write("typedef struct Zohf__S Zohf;\n")
      fd.write("struct Zohf__S {\n")
      IF $hasNpField()
        fd.write(linkedDecl)
      }
      fd.write(finishDecl)
      fd.write("};\n")
      fd.write("#define FOK_OK 1\n")
      fd.write("#define FOK_NOX 2\n")
    }

    FOR fragment IN fragments
      IF fragment.typedef != NIL && fragment.isUsed(THIS)
        fd.print(fragment.typedef)
      }
    }

    # Array type
    WriteArrayC.writeTypedefs(THIS, fd)

    # List type
    WriteListC.writeTypedefs(THIS, fd)

    # Dict type
    WriteDictC.writeTypedefs(THIS, fd)

    fd.write("\n")
  }

  # Write struct and function declarations to |fd|.
  # Some function bodies that don't require other types are defined as well.
  PROC $writeDecl(SContext ctx, IO.File fd)
    # Efficient way to define EOF
    fd.write("/* IO.eof */\n")
    fd.write("#define " .. DeclStore.getPName("MIOModule", "Veof") .. " EOF\n")
    fd.write("\n")

    # For the list of code locations.
    fd.write(''"
typedef struct {
 int line;
 int col;
} Tcpos;
typedef struct {
 Ti offset;
 Tc *fileName;
 Tc *methodName;
 Tcpos *table;
} Tcode;
"'')

      # TODO: Za() is nearly always used, but not always
      # emergencyAlloc is used when throwing an out-of-memory exception.
      # Without that it is not possible to allocate the memory for the
      # exception.
      fd.write(''"
void *Za(size_t size);
void *ZaNm(size_t size);
void *ZaNmi(size_t size);
void *Zran(void *op, size_t osize, size_t nsize);
void *ZranNm(void *op, size_t osize, size_t nsize);
void ZthrowOutOfMemory(Ti size);
char *emergencyAlloc = NULL;
size_t emergencyAllocUsed = 0;
void ZthrowDeadly(int nr);
Tc *ZnewString(Tc *p, Ti len);
"'')

    # varByteString implementation:
    # Ty.flags
    # ZbyteStringT_tiny        bytes are in tiny[], up to 3 or 7 bytes and NUL
    # ZbyteStringT_string      const Tc *, ends in NUL
    # ZbyteStringT_piece       Tp; use memory of Tp.data and further
    # ZbyteStringT_pieceval    Tv; data points to byteString or Tp
    # ZbyteStringT_cord        Tcd, use flags in Tcd (doesn't work yet!)
    #
    # ZbyteString_cow          copy on write (not implemented yet)
    #
    # ZbyteStringP_default     optimal for normal use
    # ZbyteStringP_nocord      don't use Tcd
    # ZbyteStringP_minmem      minimize memory use
    # ZbyteStringP_minalloc    minimize number of reallocations
    #
    # Ty.byteSize   actual byte length, excluding extra NUL
    # Ty.charSize   actual utf-8 char count, -1 when not computed
    # Ty.growsize   extra space when growing size
    # Ty.flags      lower 3 bits type, 1 bit COW, upper 3 bits policy
    #
    # Tp.space      length of allocated data in bytes, excluding Tp
    #                   and extra NUL
    # Tp.offset     0 when at the start
    #
    # Tv.space   as Tp.space
    # Tv.offset  as Tp.offset
    # Tv.data    points to immutable data
    #
    # Tcd.next        next Tcd, NULL for the last one
    # Tcd.byteSize    actual byte length of this part, after offset
    # Tcd.charSize    actual number of chars, -1 when not computed
    # Tcd.type        ZbyteStringT_*  (including ZbyteStringT_cord!) and ZbyteString_cow
    # Tcd.space       for ZbyteStringT_piece and ZbyteStringT_pieceval
    # Tcd.offset      0 when at the start
    # Tcd.data        as Ty.data, when ZbyteStringT_piece part of the data
    # Tcd.tiny        as Ty.tiny

    FOR fragment IN fragments
      IF fragment.isUsed(THIS)
        IF fragment.declString != NIL
          fd.print(fragment.declString)
        }
        IF fragment.produceDecl != NIL
          fragment.produceDecl(THIS, fd)
        }
      }
    }

    # An object reference of an interface type.
    # |ptr| points to the actual object.
    # |table| points to the interface member table that belongs to the
    # actual object.
    # |type| is the index of the class of the actual object in the list of
    # possible classes, used for virtual function arguments.
    fd.write(''"
struct Zref__S {
 void *ptr;
 Tc **table;
 int  type;
};
Tr trZero = {NULL,NULL,0};"'')

    # An object description entry.
    # |off|   is an offset inside the object struct.
    # |type|  is the object type at that offset.
    # For the first entry of an array:
    # |off|   is the number of entries.
    # |type|  is unused.
    fd.write(''"
struct Zobj__S {
 int off;
 Tt *type;
};
"'')

    IF $isDeclUsed(Type.aDyn)
      # dyn is a flat type, it's not allocated.  Whether it was set is
      # indicated by "type" not being NULL.
      fd.write(''"
struct Zdyn__S {
 Tt *type;
 Tz u;
};
Tx txZero = {NULL};
"'')
    }

    # TODO: only produce if type is used.
    # Note: these are never allocated.
    # |nr|       identifies the type
    # |name|     is used for enum, module, etc.
    # |ToString| may point to a function that converts to a string
    # |Equal|    may point to an Equal() function
    # |Compare|  may point to a Compare() function
    # |type[]|   are types used by containers.
    fd.write(''"
struct Ztype__S {
 int nr;
 Tc *name;
 void *ToString;
};
struct Ztypeo__S {
 int nr;
 Tc *name;
 void *ToString;"'')
    IF $ttoHasMemberNames()
      fd.write(''"
 char **names;"'')
    }
    IF $ttoHasMethods()
      fd.write(''"
 void *Size;
 void *Finish;
 void *Equal;
 void *Compare;"'')
    }
    fd.write(''"
 To *to;
};
"'')

    $writeToDecls(fd, FALSE)

    $writeMultipleDecls(ctx, fd)

    # Class-like types for allocated variables.
    IF Type.allocTypes != NIL
      FOR t IN Type.allocTypes
        fd.write("typedef struct ")
        fd.write(t.pName)
        fd.write("__S ")
        fd.write(t.pName)
        fd.write("; /* ")
        fd.write(t.name)
        fd.write(" */\n")

        fd.write("struct ")
        fd.write(t.pName)
        fd.write("__S {\n")
        fd.write($getStructHead())
        fd.write(" ")
        fd.write($vartypeString(t.allocDecl.type, TRUE, NIL, NIL))
        fd.write("Vm;\n")
        fd.write("};\n")

        fd.write("To To")
        fd.write(t.pName)
        fd.write("[] = {\n")
        IF t.allocDecl.type.isManaged()
          fd.write(" {1, 0},\n")
          fd.write(" {ZOH_OFF, &")
          fd.write(t.allocDecl.type.getTypeName(ctx))
          fd.write("__T},\n")
        ELSE
          fd.write(" {0, 0},\n")
        }
        fd.write("};\n")

        # Must write to declOut, otherwise static string isn't defined yet.
        string tcName = $writeStaticString(t.name, ctx)
        Output dout = ctx.outs.declOut
        WriteIMT.writeClassType(t, tcName, "To" .. t.pName, dout, ctx)
      }
    }

    # Type names for containers.
    FOR decl IN ContainerType.usedTypes
      IF $isDeclUsed(decl)
        string tcName = $writeStaticString(decl.name, ctx)

        # Must write to declOut, otherwise static string isn't defined yet.
        Output dout = ctx.outs.declOut
        dout.write("Tt " .. decl.pName .. "__T = {")
        SWITCH decl.type.ttype
          CASE Type.Enum.array
            dout.write("300")
          CASE Type.Enum.list
            dout.write("301")
          CASE Type.Enum.dict
            dout.write("302")
        }
        dout.write(", (Tc*)&" .. tcName .. ", 0};\n")
      }
    }

    # Array type
    WriteArrayC.writeDecl(THIS, fd)

    # List type
    WriteListC.writeDecl(THIS, fd)

    # Dict type
    WriteDictC.writeDecl(THIS, fd)

    # Write structs for libraries.
    FOR p IN declWriters
      p(THIS, fd)
    }
  }

  # Return TRUE if Tto includes Equal(), Compare() and other methods.
  FUNC $ttoHasMethods() bool
    RETURN $isDeclUsed(Type.aDyn)
        || $isDeclUsed(Declaration.itemEqual)
        || $isDeclUsed(Declaration.hasFinish)
  }

  # Return TRUE if Tto includes the list of member names.
  FUNC $ttoHasMemberNames() bool
    RETURN $isDeclUsed(Declaration.itemToString)
  }

  list<Declaration> $staticVars
  list<Declaration> $noallocVars

  # Write the To entries for built-in types.
  # This code uses TYPE_NUMBERS, keep in sync!
  PROC $writeToDecls(IO.File fd, bool init)

    IF init
      fd.write("Tt bool__T  = {21, 0, 0};\n")
      fd.write("Tt byte__T  = {11, 0, 0};\n")
      fd.write("Tt byteString__T = {201, 0, 0};\n")
      fd.write("Tt float128__T  = {83, 0, 0};\n")
      fd.write("Tt float32__T  = {81, 0, 0};\n")
      fd.write("Tt float80__T  = {82, 0, 0};\n")
      fd.write("Tt float__T  = {80, 0, 0};\n")
      fd.write("Tt int16__T  = {2, 0, 0};\n")
      fd.write("Tt int32__T  = {3, 0, 0};\n")
      fd.write("Tt int8__T  = {1, 0, 0};\n")
      fd.write("Tt int__T  = {0, 0, 0};\n")
      fd.write("Tt nat16__T  = {12, 0, 0};\n")
      fd.write("Tt nat32__T  = {13, 0, 0};\n")
      fd.write("Tt nat__T  = {10, 0, 0};\n")
      fd.write("Tt status__T  = {22, 0, 0};\n")
      fd.write("Tt string__T = {200, 0, 0};\n")
      fd.write("Tt type__T  = {101, 0, 0};\n")
    ELSE
      fd.write("extern Tt bool__T;\n")
      fd.write("extern Tt byte__T;\n")
      fd.write("extern Tt byteString__T;\n")
      fd.write("extern Tt float128__T;\n")
      fd.write("extern Tt float32__T;\n")
      fd.write("extern Tt float80__T;\n")
      fd.write("extern Tt float__T;\n")
      fd.write("extern Tt int16__T;\n")
      fd.write("extern Tt int32__T;\n")
      fd.write("extern Tt int8__T;\n")
      fd.write("extern Tt int__T;\n")
      fd.write("extern Tt nat16__T;\n")
      fd.write("extern Tt nat32__T;\n")
      fd.write("extern Tt nat__T;\n")
      fd.write("extern Tt status__T;\n")
      fd.write("extern Tt string__T;\n")
      fd.write("extern Tt type__T;\n")
    }
    IF $isDeclUsed(%pthread)
      # thread__T is used for "threads", not for Thread objects
      fd.write(init ? "Tt thread__T = {250, 0, 0};\n"
                                                   : "extern Tt thread__T;\n")
    }
    IF $isDeclUsed(Declaration.array)
      fd.write(init ? "Tt array__T = {300, 0, 0};\n" : "extern Tt array__T;\n")
    }
    IF $isDeclUsed(Declaration.list)
      fd.write(init ? "Tt list__T = {301, 0, 0};\n" : "extern Tt list__T;\n")
      IF $isDeclUsed(Declaration.defer)
        # defer__T means the same as list__T, it is used for "deferList", so
        # that it can be found on the stack frame.
        fd.write(init ? "Tt defer__T = {301, 0, 0};\n"
                                                    : "extern Tt defer__T;\n")
      }
    }
    IF $isDeclUsed(Declaration.dict)
      fd.write(init ? "Tt dict__T = {302, 0, 0};\n" : "extern Tt dict__T;\n")
    }
    IF $isDeclUsed(Declaration.varString) || $isDeclUsed(Declaration.varByteString)
      fd.write(init ? "Tt varString__T = {310, 0, 0};\n"
                                                : "extern Tt varString__T;\n")
      fd.write(init ? "Tt varByteString__T = {311, 0, 0};\n"
                                            : "extern Tt varByteString__T;\n")
    }
    IF $isDeclUsed(Declaration.funcRef) || $isDeclUsed(Declaration.defer)
      fd.write(init ? "Tt cb__T  = {330, 0, 0};\n" : "extern Tt cb__T;\n")
    }
    IF $isDeclUsed(Type.aDyn)
      fd.write(init ? "Tt dyn__T  = {360, 0, 0};\n" : "extern Tt dyn__T;\n")
    }
    fd.write(init ? "Tt iobj__T = {391, 0, 0};\n" : "extern Tt iobj__T;\n")
  }

  PROC $writeMultipleDecls(SContext ctx, IO.File fd)
    FOR t IN MultipleType.typeNames
      fd.write("typedef struct {\n")
      FOR i IN 0 UNTIL t.types.Size()
       fd.write(" ")
       fd.write($vartypeString(t.types[i].type, TRUE, NIL, ctx))
       fd.write(" a" .. i)
       fd.write(";\n")
      }
      fd.write("} ")
      fd.write(t.pName)
      fd.write(";\n")
    }
  }

  # Write the table with static variables.  This is used by the garbage
  # collector to find used memory items.
  PROC $writeStaticTable(IO.File fd, SContext ctx)
    IF $manageMemory()
      fd.write(''"
Zop ZglobalVars[] = {"'')
      $writeOneStaticTable($staticVars, fd, ctx)
      IF $noallocVars != NIL
        fd.write(''"
Zop ZnoallocVars[] = {"'')
        $writeOneStaticTable($noallocVars, fd, ctx)
      }
    }

    $writeToDecls(fd, TRUE)
  }

  PROC $writeOneStaticTable(list<Declaration> vars, IO.File fd, SContext ctx)
    FOR decl IN vars
      fd.write("\n{&")
      fd.write(decl.pName)
      fd.write(",(Tt*)&")
      fd.write(decl.type.getTypeName(ctx))
      fd.write("__T},")
    }
    fd.write("\n{0,0},")
    fd.write("\n};\n\n")
  }

  PROC $writeBodies(IO.File fd)
    # The per-thread environment, containing:
    # - The stack frame pointer, used for backtraces
    # - The jump buffers used for TRY/CATCH
    # - The thrown exceptions
    # Making "Zsf.pos" volatile avoids that the optimizer will simply drop
    # all assignments, it doesn't know about exceptions.
    fd.write(''"
typedef struct Zfo__S {
 int off;
 Tt  *type;
} Zfo;
typedef struct Zsf__S {
 volatile int pos;
 struct Zsf__S *prev;
 Zfo *frof;
} Zsf;
#define POS_MASK 0x3fffffff"'')
    IF $isDeclUsed(Declaration.try)
      fd.write(''"
typedef struct StryCtx__S {
 jmp_buf jmpBuf;
 Zsf *sf;
} Ttc;"'')
    }
    fd.write(''"
typedef struct Senv__S {"'')
    IF $isDeclUsed(Declaration.try)
      fd.write(''"
 Ttc  *tryCtx;
 int  tryCtxSize;
 int  tryCtxUsed;
 Tr   *thrown;
 int  thrownSize;
 int  thrownUsed;"'')
    }
    IF $isDeclUsed(%pthread)
      fd.write(''"
 pthread_t tid;
 int finished;
 int found;
 int timedOut;
 int inZa;
 int ZaEntered;
 Zsf *startFrames;
 Zsf *topFrame;"'')
      IF $manageMemory()
        # List with allocated memory items.
        # This is not one long list to avoid having to find the end of the
        # list, or keeping track of the end.
        fd.write(''"
 Zoh *firstUsed;
 pthread_mutex_t stateMutex;
 pthread_cond_t stateCond;
 int wantGC;
 int inGC;
#define GC_STOPPED 1
#define GC_MARK_DONE 2
 int state;"'')
        IF $isDeclUsed(Declaration.gcRun)
          fd.write(''"
 Zgcs gcStatus;"'')
        }
      }
      IF $isDeclUsed(Declaration.hasFinish)
        # List with allocated objects with a Finish() method.
        # Last item in the list points to &Zlast.
        fd.write(''"
 Zohf *firstUsedF;"'')
      }
    }
    fd.write(''"
 int tosNr;
} Tn; /* per-thread environemnt */
"'')

    IF $manageMemory()
      IF $isDeclUsed(%pthread)
        # List of lists of allocated memory items. These are taken over from
        # threads when GC.run() is invoked or when a thread ends.
        # usedListF is the same for objects with a Finish() method.
        # This is not one long list to avoid having to find the end of the
        # list, or keeping track of it.
        # Protected by usedListMutex.
        fd.write(''"
typedef struct Zohp__S Zohp;
struct Zohp__S {
 Zohp *next;
 Zoh  *firstUsed;
};
Zohp *usedList = NULL;
pthread_mutex_t usedListMutex;
"'')
      ELSE
        # List of allocated memory items.
        # GC status.
        fd.write(''"
Zoh *firstUsed = &Zlast;"'')
        IF $isDeclUsed(Declaration.gcRun)
          fd.write(''"
Zgcs gcStatus;"'')
        }
      }
    }

    IF $isDeclUsed(Declaration.hasFinish)
      IF $isDeclUsed(%pthread)
        # List of lists of allocated memory items with a Finish() method.
        # Note: must be identical to Zohp (except for the types) so that
        # ZgcFreeList() works for both.
        fd.write(''"
typedef struct Zohpf__S Zohpf;
struct Zohpf__S {
 Zohpf *next;
 Zohf  *firstUsedF;
};
Zohpf *usedListF = NULL;"'')
      ELSE
        # List of allocated memory items with a Finish() method.
        fd.write(''"
Zohf *firstUsedF = ZOHF_LAST;"'')
      }
      fd.write(''"
Zohf *toFinish = ZOHF_LAST;"'')
    }

    IF $isDeclUsed(%pthread)
      IF $manageMemory()
        fd.write(''"
pthread_mutex_t gcRunMutex;
int gcMarkPhase = 0;
int gcSTW = 0;
pthread_mutex_t gcMarkPhaseMutex;
pthread_cond_t gcMarkPhaseCond;
"'')
      }

      fd.write(''"
pthread_mutex_t threadsMutex;
Tl *threads;
"'')
      # When the thread dies ZenvFree() is called to clean up.
      # Set inGC to avoid ZthreadGC() doing its work, it may cause a deadlock
      # when ZenvFree() is interruped by a signal.
      # Hand over the list of allocated memory to the global list.
      fd.write(''"
static pthread_key_t ZenvKey;
void ZenvFree(void *ptr) {
 Tn *e = (Tn *)ptr;
 if (e->startFrames) free(e->startFrames);"'')
      IF $manageMemory()
        fd.write(''"
 e->inGC = 1;
 pthread_mutex_lock(&usedListMutex);
 if (e->firstUsed != &Zlast) {
  Zohp *entry = ZaNmi(sizeof(Zohp));
  entry->next = usedList;
  usedList = entry;
  entry->firstUsed = e->firstUsed;
 }"'')
        IF $isDeclUsed(Declaration.hasFinish)
          fd.write(''"
 if (e->firstUsedF != ZOHF_LAST) {
  Zohpf *entry = ZaNmi(sizeof(Zohpf));
  entry->next = usedListF;
  usedListF = entry;
  entry->firstUsedF = e->firstUsedF;
 }"'')
        }
        IF $isDeclUsed(Declaration.try)
          fd.write(''"
 if (e->tryCtx) {
  free(e->tryCtx);
 }"'')
        }
        fd.write(''"
 pthread_mutex_unlock(&usedListMutex);"'')
      }
      fd.write(''"
 pthread_mutex_lock(&threadsMutex);
 ZListRemovePtrItem(threads, ZListFind(threads, (Tz)(void*)e));
 pthread_mutex_unlock(&threadsMutex);
 free(ptr);
}"'')

      fd.write(''"
Tn *ZgetEnv() {
 Tn *e = pthread_getspecific(ZenvKey);
 if (e == NULL) {
  e = ZaNmi(sizeof(Tn));
  e->tid = pthread_self();"'')
      IF $manageMemory()
        fd.write(''"
  e->firstUsed = &Zlast;"'')
        IF $isDeclUsed(Declaration.hasFinish)
          fd.write(''"
  e->firstUsedF = (Zohf*)&Zlast;"'')
        }
      }
      IF $isDeclUsed(%pthread) && $manageMemory()
        fd.write(''"
  pthread_mutex_init(&e->stateMutex, NULL);
  pthread_cond_init(&e->stateCond, NULL);"'')
      }
      fd.write(''"
  pthread_setspecific(ZenvKey, e);
 }
 return e;
}
void ZenvInit() {
 (void)pthread_key_create(&ZenvKey, ZenvFree);
 pthread_setspecific(ZenvKey, NULL);"'')
      IF $manageMemory()
        fd.write(''"
 pthread_mutex_init(&gcRunMutex, NULL);
 pthread_mutex_init(&usedListMutex, NULL);
 pthread_mutex_init(&gcMarkPhaseMutex, NULL);
 pthread_cond_init(&gcMarkPhaseCond, NULL);"'')
      }
      fd.write(''"
 pthread_mutex_init(&threadsMutex, NULL);
 threads = ZnewList(&thread__T, 0);
 ZLa(threads, -1, (Tz)(void*)ZgetEnv());
}
"'')
    ELSE
      fd.write(''"
Zsf *topFrame = NULL;
int inZa = 0;
int ZaEntered = 0;

Tn Zenv = {"'')
      string comma = ""
      IF $isDeclUsed(Declaration.try)
        fd.write(comma)
        fd.write("NULL, 0, 0, NULL, 0, 0")
        comma = ", "
      }
      IF $isDeclUsed(%pthread)
        fd.write(comma)
        fd.write("NULL, NULL")
        comma = ", "
      }
      fd.write(comma)
      fd.write("0};\n")  # tosNr
    }

    IF $manageMemory()
      fd.write(''"
void ZthreadGC();"'')
    }
    IF $isDeclUsed(Declaration.hasFinish)
      fd.write(''"
void ZgcFinishAll(int rsn);"'')
    }
    IF $isDeclUsed(Declaration.gcRun)
      fd.write(''"
void ZgcRun();"'')
    }

    fd.write(''"
void beforeExit() {"'')
    Declaration exit = DeclStore.getDecl("MZModule", "Vexiting")
    IF $isDeclUsed(exit)
      fd.write("\n ")
      fd.write(exit.pName)
      fd.write(" = 1;")
    }

    IF $isDeclUsed(%pthread)
      # Kill all the other threads. This is required for when one thread
      # throws an exception and exits, we don't want other threads to keep
      # running and eventually hang.
      fd.write(''"
 {
  int i;
  Tn *e = ZgetEnv();
  for (i = 0; i < threads->itemCount; ++i) {
   Tn *ie = ZListGetPtr(threads, i);
   if (ie != e && !ie->finished) {
    pthread_cancel(ie->tid);
    ie->finished = 1;
   }
  }
 }"'')
    }

    IF $isDeclUsed(Declaration.hasFinish)
      fd.write(''"
 ZgcFinishAll(1);"'')
    }
    IF ManageMemory.isExitclean()
      IF $isDeclUsed(Declaration.hasFinish) && $noallocVars != NIL
        fd.write(''"
 ZgcFinishAll(5);"'')
      }
      fd.write(''"
 ZgcRun();"'')
      IF $manageMemory()
        # Makes valgrind find all unused memory.
        IF $isDeclUsed(%pthread)
          fd.write(''"
 {
  Zohp *p;
  for (p = usedList; p; p = p->next) p->firstUsed = &Zlast;
 }"'')
        ELSE
          fd.write(''"
 firstUsed = &Zlast;"'')
        }
      }
      IF $isDeclUsed(Declaration.hasFinish) && $manageMemory()
        # Makes valgrind find all unused memory.
        IF $isDeclUsed(%pthread)
          fd.write(''"
 {
  Zohpf *p;
  for (p = usedListF; p; p = p->next) p->firstUsedF = ZOHF_LAST;
 }"'')
        ELSE
          fd.write(''"
 firstUsedF = ZOHF_LAST;"'')
        }
      }
    }
    fd.write(''"
}
"'')

    # These are are also used in lib/GCModule.
    IF $isDeclUsed(Declaration.gcRun)
      fd.write(''"
Ti ZgcUseCount = 0;
Ti ZgcStwTime = 0;
Ti ZgcMarkTime = 0;
Ti ZgcFinishTime = 0;
Ti ZgcFreeTime = 0;
Ti ZgcFreeCount = 0;
"'')
    }

    # Zstr: allocate string from plain C string
    fd.write(''"

Tc *Zstr(char *s) {
 return ZnewString((Tc*)s, strlen(s));
}
"'')

    # Function to set a breakpoint to find missing UNSAFE flags.
    IF ManageMemory.isExitclean()
      fd.write(''"
void ZreportUnsafe() {
 static int rec = 0;
 if (rec == 0) {
  rec = 1;
  ZthrowInternal(Zstr("Allocating memory without UNSAFE set!"));
  rec = 0;
 }
}
"'')
    }

    # Za() and Zran() are always used.
    # When running out of memory throw an exception. When allocating while
    # throwing the exception use the emergencyAlloc.
    # TODO: When managing memory reset "ZaEntered" after handling the
    # exception.
    $writeAllocFunc("Za", FALSE, "firstUsed", fd)

    IF $isDeclUsed(Declaration.hasFinish)
      $writeAllocFunc("ZaF", TRUE, "firstUsedF", fd)
    }

    # Version of Za() and Zran() for callers that are not aware of a header.
    fd.write(''"
/* allocate memory with offset */
#define ZaOff(size) (Za((size) + ZOH_OFF) + ZOH_OFF)
#define ZranOff(ptr, osize, nsize) (Zran((ptr) ? (void*)(ptr) - ZOH_OFF : NULL, (osize) + ZOH_OFF, (nsize) + ZOH_OFF) + ZOH_OFF)
"'')

    # Version of Za() for manually freed memory.
    $writeAllocFunc("ZaNm", FALSE, NIL, fd)

    # Like ZaNm, but no ZgetEnv() or ZthreadGC() call.  Can't use e->inZa,
    # e->ZaEntered or $checkUnsafeFunc(), it requires ZgetEnv().
    fd.write(''"
void *ZaNmi(size_t size) {
 void *p = NULL;"'')
    IF $isDeclUsed(%pthread)
      fd.write(''"
 p = calloc(1, size);
 if (p == NULL) {
  {"'')
    ELSE
      fd.write(''"
 if (!inZa) {
  inZa = 1;
  p = calloc(1, size);
  inZa = 0;
 }
 if (p == NULL) {
  if (inZa || ZaEntered) {"'')
    }
    fd.write(''"
   if ("'' .. emergencyAllocSize .. ''" - emergencyAllocUsed >= size) {
    p = emergencyAlloc + emergencyAllocUsed;
    emergencyAllocUsed += size;
    return p;
   }
   fputs("Out of memory (ZaNmi)\n", stderr);
   fflush(stderr);
   exit(1);
  }"'')
    IF !$isDeclUsed(%pthread)
      fd.write(''"
  ++ZaEntered;"'')
    }
    fd.write(''"
  ZthrowOutOfMemory(size);
 }"'')
    IF !$isDeclUsed(%pthread)
      fd.write(''"
 ZaEntered = 0;"'')
    }
    fd.write(''"
 return p;
}
"'')

    fd.write(''"
/* reallocate memory */
void *Zran(void *op, size_t osize, size_t nsize) {
 void *p = NULL;"'')
      IF $isDeclUsed(%pthread)
      fd.write(''"
 Tn *e = ZgetEnv();"'')
      }
    $checkUnsafeFunc(fd)
    IF !$manageMemory()
      IF $isDeclUsed(%pthread)
        fd.write(''"
 if (!e->inZa && !e->ZaEntered) {
  e->inZa = 1;
  p = realloc(op, nsize);
  e->inZa = 0;
  if (p == NULL) {
    ++e->ZaEntered;
    ZthrowOutOfMemory(nsize);
  }
  e->ZaEntered = 0;"'')
      ELSE
        fd.write(''"
 if (!inZa && !ZaEntered) {
  inZa = 1;
  p = realloc(op, nsize);
  inZa = 0;
  if (p == NULL) {
    ++ZaEntered;
    ZthrowOutOfMemory(nsize);
  }
  ZaEntered = 0;"'')
      }
  fd.write(''"
  if (nsize > osize) memset(p + osize, 0, nsize - osize);
  return p;
 }"'')
    }
    fd.write(''"
 p = Za(nsize);
 if (op)
  memmove(p + ZOH_OFF, op + ZOH_OFF, nsize > osize ? osize - ZOH_OFF : nsize - ZOH_OFF);
 if (nsize > osize) memset(p + osize, 0, nsize - osize);
 return p;
}
"'')

    # Like Zran() but for manually freed memory.
    # MT-GC: This is an unsafe call, because the allocated memory will not be
    # referenced while returning.
    fd.write(''"
void *ZranNm(void *op, size_t osize, size_t nsize) {
 void *p = NULL;"'')
    IF $isDeclUsed(%pthread)
      fd.write(''"
 Tn *e = ZgetEnv();"'')
    }
    $checkUnsafeFunc(fd)
    IF $isDeclUsed(%pthread)
      fd.write(''"
 if (!e->inZa && !e->ZaEntered) {
  e->inZa = 1;
  p = realloc(op, nsize);
  e->inZa = 0;
  if (p == NULL) {
   ++e->ZaEntered;"'')
    ELSE
      fd.write(''"
 if (!inZa && !ZaEntered) {
  inZa = 1;
  p = realloc(op, nsize);
  inZa = 0;
  if (p == NULL) {
   ++ZaEntered;"'')
    }
    fd.write(''"
   ZthrowOutOfMemory(nsize);
  }
  if (nsize > osize) memset(p + osize, 0, nsize - osize);
  return p;
 }
 p = ZaNm(nsize);
 if (op) memmove(p, op, nsize > osize ? osize : nsize);
 if (nsize > osize) memset(p + osize, 0, nsize - osize);
 return p;
}
"'')

    IF $isDeclUsed(%zfree)
      # Free memory and mark it no longer used.
      # MT-GC: The caller will have |p| referenced, thus this is not an unsafe
      # call.  The free() itself is unsafe.
      fd.write(''"
void Zfree(void *p) {"'')
      $writeDeclForUnsafe(fd, TRUE)
      $writeBeforeUnsafe(fd)
      fd.write(''"
 if (p) free(p);"'')
      $writeAfterUnsafe(fd)
      fd.write(''"
}
"'')
    }

    IF $isDeclUsed(Declaration.hasFinish)
      # Call Finish() with it didn't return OK before.
      # Catch exceptions thrown by Finish(). If caught set "fok".
      string ewrite = DeclStore.getPName("MEModule", "FwriteToStderr")
      fd.write(''"
void ZtryDeeper(Tn *e, Zsf *sf);
"'')
      fd.write(''"
void ZcallFinish(Zohf *p, Te rsn) {
 if ((p->fok & FOK_OK) == 0 && (rsn != 1 || (p->fok & FOK_NOX) == 0)) {
  Tn *e = "'' .. $getEnvCode() .. ''";
  int try_index = e->tryCtxUsed;
  Zsf *tf = "'' .. $topFrameName() .. ''";
  ZtryDeeper(e, "'' .. $topFrameName() .. ''");
  if (setjmp(e->tryCtx[try_index].jmpBuf) == 0) {
   p->ff(p, rsn);
  } else {
   "'' .. $topFrameName() .. ''" = tf;
   "'' .. ewrite .. ''"(e->thrown[--e->thrownUsed]);
   p->fok |= FOK_OK;
  }
  e->tryCtxUsed = try_index;
 }
}"'')

      IF ($isDeclUsed(%finishIobj) || $isDeclUsed(%noAllocNilIobj)
                                                        || $noallocVars != NIL)
        fd.write(''"
void ZFinishIobj(Tr *tr, Te rsn) {
 if (tr->ptr != NULL) {
  if (((Tto*)tr->table[0])->Finish != NULL)
   ZcallFinish(tr->ptr, rsn);
   tr->ptr = NULL;
 }
}"'')
      }
    }

    IF $isDeclUsed(Declaration.hasFinish)
      # Call the Finish() methods in toFinish.  Skip it when "fok" is
      # already set (by calling another Finish method).
      # Put the objects back into usedListF.
      fd.write(''"
void ZgcCallFinish(Te rsn) {
 Zohf *p = toFinish;
 Zohf *np;
 toFinish = ZOHF_LAST;
 while (p != ZOHF_LAST) {
  np = (Zohf*)((Tip)(p->np) & ~3);
  ZcallFinish(p, rsn);"'')
      IF $isDeclUsed(%pthread)
        fd.write(''"
  if (usedListF == NULL) {
   usedListF = ZaNmi(sizeof(Zohpf));
   usedListF->firstUsedF = ZOHF_LAST;
  }
  p->np = (Zoh*)usedListF->firstUsedF;
  usedListF->firstUsedF = p;"'')
      ELSE
        fd.write(''"
  p->np = (Zoh*)firstUsedF;
  firstUsedF = p;"'')
      }
      fd.write(''"
  p = np;
 }
}
"'')
    }

    IF $isDeclUsed(Declaration.hasFinish)
      # Called when exiting: Move all objects from usedListF to toFinish
      # and invoke all Finish methods.
      fd.write(''"
void ZgcFinishAll(int rsn) {"'')
      IF $isDeclUsed(%pthread)
        fd.write(''"
 Zohpf *up;
 Zohpf *np;
 for (up = usedListF; up; up = np) {
  if (toFinish == ZOHF_LAST) {
   toFinish = up->firstUsedF;
  } else {
   Zohf *p = toFinish;
   while ((Zohf*)((Tip)p->np & ~3) != ZOHF_LAST) p = (Zohf*)((Tip)p->np & ~3);
   p->np = (Zoh*)up->firstUsedF;
  }
  np = up->next;
  free(up);
 }
 usedListF = NULL;"'')
      ELSE
        fd.write(''"
 if (firstUsedF != ZOHF_LAST) {
  if (toFinish == ZOHF_LAST) {
   toFinish = firstUsedF;
  } else {
   Zohf *p = toFinish;
   while ((Zohf*)((Tip)p->np & ~3) != ZOHF_LAST) p = (Zohf*)((Tip)p->np & ~3);
   p->np = (Zoh*)firstUsedF;
  }
  firstUsedF = ZOHF_LAST;
 }"'')
      }
      fd.write(''"
 ZgcCallFinish(rsn);"'')
      IF $noallocVars != NIL
        fd.write(''"
 {
  int i;
  for (i = 0; ZnoallocVars[i].var != NULL; ++i) {
   void *p = ZnoallocVars[i].var;
   Tt *type = ZnoallocVars[i].type;
   if (type->nr == 391) ZFinishIobj(p, rsn);
   else if (type->nr == 390 && ((Tto*)type)->Finish != NULL && ((Zohf*)p)->ff != NULL) ZcallFinish(p, rsn);
  }
 }"'')
      }
      fd.write(''"
}
"'')
    }

    IF $manageMemory() && $isDeclUsed(Declaration.gcRun)
      fd.write(''"
int newMark = 1;

void ZgcGetBlock(Zgcs *gcs) {
 Zgcb *b = malloc(sizeof(Zgcb));
 if (b == NULL) {
  fputs("Out of memory (ZgcGetBlock)\n", stderr);
  fflush(stderr);
  exit(1);
 }
 b->next = gcs->todo;
 gcs->todo = b;
}

/* Mark used memory on stack frames and try context for one thread.
 * When "doGlobal" is non-zero also mark global items. */
void ZgcMarkItems(Tn *e, int doGlobal, void *pArg, Tt *toArg) {
 Zgcs *gcs = &"'')
          IF $isDeclUsed(%pthread)
            fd.write("e->")
          }
          fd.write(''"gcStatus;
 Zgcb *b = NULL;
 int used = GC_BLOCK_SIZE;
#define ADD_ITEM(ap, atype) \
  { if (ap) { \
   if (used == GC_BLOCK_SIZE) { \
    if (b) b->used = GC_BLOCK_SIZE; \
    ZgcGetBlock(gcs); \
    b = gcs->todo; \
    used = 0; \
   } \
   b->items[used].var = (ap); \
   b->items[used].type = (atype); \
   ++used; \
  }}

 Zsf *frame = "'')
          IF $isDeclUsed(%pthread)
            fd.write("e->")
          }
          fd.write(''"topFrame;
 Zfo *fo = frame == NULL ? NULL : frame->frof;
 int ti = 0;
 int gi = 0;
 int ni = 0;
 void *p = NULL;
 Tt *to;"'')
          # what == 0: mark items on the stack frames
          #            OR: use pArg/toArg and nothting else
          # what == 1: mark items in the try context
          # what == 2: mark items in the exception list
          # what == 3: mark the list of threads
          # what == 4: mark allocated global items
          # what == 5: mark not allocated global items
          fd.write(''"
 int what = 0;
 while (what <= 5) {
  switch (what) {
   case 0:
    if (pArg) {
     what = 99;
     p = pArg;
     to = toArg;
     break;
    }
    if (frame == NULL) ++what;
    else {
     if (!fo) {
      frame = frame->prev;
      if (frame) fo = frame->frof;
     } else {
      if (fo->type == &iobj__T) {
       p = (char *)frame - (fo->off & ~1);
       if (((Tr*)p)->ptr == NULL) p = NULL;
       else to = &iobj__T;"'')
          IF $isDeclUsed(Type.aDyn)
            fd.write(''"
      } else if (fo->type == &dyn__T) {
       p = (char *)frame - fo->off;
       to = &dyn__T;"'')
          }
          fd.write(''"
      } else if (fo->off & 1) {
       p = (char *)frame - (fo->off - 1);
       if (((Zoh*)p)->np == NULL) p = NULL;
       else to = fo->type;
      } else {
       p = *(char **)((char *)frame - fo->off);
       if (p) to = fo->type;
      }
      ++fo;
      if (!fo->off) {
       frame = frame->prev;
       if (frame) fo = frame->frof;
      }
     }
    }
    break;"'')
          IF $isDeclUsed(Declaration.try)
            fd.write(''"
   case 1:
    p = e->tryCtx;
    to = NULL;
    ++what;
    break;
   case 2:
    if (ti >= e->thrownUsed) ++what;
    else {
     p = &e->thrown[ti];
     to = &iobj__T;
     ++ti;
    }
    break;"'')
          ELSE
            fd.write(''"
   case 1: /* no TRY */
    what += 2;
    break;"'')
          }
          fd.write(''"
   case 3:
    if (!doGlobal) what = 99;
    else {"'')
          IF $isDeclUsed(%pthread)
            # The list of thread info is always used. The items themselves are
            # ignored, their type is thread__T.
            fd.write(''"
     p = threads;
     to = &list__T;"'')
          }
          fd.write(''"
     ++what;
    }
    break;
   case 4:
    if (!ZglobalVars[gi].var) {
     ++what;
    } else {
     to = ZglobalVars[gi].type;
     if (to == &iobj__T"'')
          IF $isDeclUsed(Type.aDyn)
            fd.write(" || to == &dyn__T")
          }
          fd.write(''")
      p = ZglobalVars[gi].var;
     else
      p = *((char**)(ZglobalVars[gi].var));
     ++gi;
    }
    break;
   case 5:"'')
          IF $noallocVars == NIL
            fd.write(''"
    ++what;"'')
          ELSE
            fd.write(''"
    if (!ZnoallocVars[ni].var) {
     ++what;
    } else {
     p = (char*)ZnoallocVars[ni].var;
     to = ZnoallocVars[ni].type;
     ++ni;
    }"'')
          }
          fd.write(''"
    break;
  }

  while (p) {
   void *ip = NULL;
   Tt *ito = NULL;
   Zoh *np;
   while (to == &iobj__T) {
    if (((Tr*)p)->ptr == NULL) goto p_is_null;
    to = (Tt*)(((Tr*)p)->table[0]);
    p = ((Tr*)p)->ptr;
   }"'')
          # dyn: get object it refers to.  Can't be an iobject.
          IF $isDeclUsed(Type.aDyn)
            fd.write(''"
   while (to == &dyn__T) {
    to = ((Tx*)p)->type;
    if (to == NULL || to->nr < 200) goto p_is_null;
    p = ((Tx*)p)->u.ptr;
    if (p == NULL) goto p_is_null;
   }"'')
          }
          fd.write(''"
   np = ((Zoh *)p)->np;
   if (((Tip)np & 3) != newMark && np != NULL) {
    ((Zoh *)p)->np = (Zoh *)(((Tip)np & ~3) | newMark);

    if (to != NULL && to->nr >= 300) {
     if (0) ;
     "'')

         # Array: values
         IF $isDeclUsed(Declaration.array)
           fd.write(''" else if (to == &array__T) {
      Ta *head = (Ta*)p;
      if (head->ptr && head->ptr != head + 1) {
       ip = head->ptr - ZOH_OFF;
       /* ito = NULL; */
       if (head->itemType && head->itemType->nr >= 200) {
        Ti i;
        Ti d;
        i = head->size[0];
        for (d = 1; d < head->dim; ++d) i *= head->size[d];
        while (--i >= 0) {
         void *p;
         if (head->itemType == &iobj__T)
          p = (Tr*)head->ptr + i;"'')
          IF $isDeclUsed(Type.aDyn)
            fd.write(''"
         else if (head->itemType == &dyn__T)
          p = (Tx*)head->ptr + i;"'')
          }
          fd.write(''"
         else
          p = ((char **)(head->ptr))[i];
         ADD_ITEM(p, head->itemType)
        }
       }
      }
     }"'')
         }

         # List: values
         IF $isDeclUsed(Declaration.list)
           fd.write(" else if (to == &list__T")
           IF $isDeclUsed(Declaration.defer)
             fd.write(" || to == &defer__T")
           }
           fd.write(''") {
      Tl *head = (Tl*)p;
      if (head->itemType && head->itemType->nr >= 200) {
       if (head->items) {
        Ti n;
        Ti tot = head->empty + head->itemCount;"'')
           IF $isDeclUsed(%pthread)
             fd.write(''"
        if (head->itemType != &thread__T)"'')
           }
           fd.write(''"
         for (n = head->empty; n < tot; ++n) {
          void *p;
         if (head->itemType == &iobj__T)
          p = (Tr*)head->items + n;"'')
           IF $isDeclUsed(Type.aDyn)
             fd.write(''"
         else if (head->itemType == &dyn__T)
          p = (Tx*)head->items + n;"'')
           }
           fd.write(''"
         else
           p = head->items[n];
          ADD_ITEM(p, head->itemType)
         }
       }
      }
      if (head->items && head->items != (void**)(head + 1)) {
       ip = (void*)head->items - ZOH_OFF;
       /* ito = NULL; */
      }
     }"'')
         }

         # Dict: keys and values
         IF $isDeclUsed(Declaration.dict)
           fd.write(''" else if (to == &dict__T) {
      Td *head = (Td*)p;
      int dokey = (head->keyType && head->keyType->nr >= 200);
      int doitem = (head->itemType && head->itemType->nr >= 200);
      if (head->array != head->smallArray && head->array) {
       ip = (void*)head->array - ZOH_OFF;
       /* ito = NULL; */
      }
      if (dokey || doitem) {
       int todo;
       CDictItem *item;
       todo = (int)head->used;
       for (item = head->array; todo > 0; ++item) {
        if (item->flags & CDI_FLAG_USED) {
         if (dokey) {
          if (head->keyType == &iobj__T)
           ADD_ITEM(&item->iokey, &iobj__T)"'')
           IF $isDeclUsed(Type.aDyn)
             fd.write(''"
          else if (head->keyType == &dyn__T)
           ADD_ITEM(&item->dynkey, &dyn__T)"'')
           }
           fd.write(''"
          else
           ADD_ITEM(item->key.ptr, head->keyType)
         }
         if (doitem) {
          if (head->itemType == &iobj__T)
           ADD_ITEM(&item->ioitem, &iobj__T)"'')
           IF $isDeclUsed(Type.aDyn)
             fd.write(''"
          else if (head->itemType == &dyn__T)
           ADD_ITEM(&item->dynitem, &dyn__T)"'')
           }
           fd.write(''"
          else
           ADD_ITEM(item->item.ptr, head->itemType)
         }
         --todo;
        }
       }
      }
     }"'')
         }

         # varByteString has members
         IF $isDeclUsed(Declaration.varString)
                                     || $isDeclUsed(Declaration.varByteString)
           fd.write(''" else if (to == &varString__T || to == &varByteString__T) {
      Ty *r = (Ty*)p;
      if (r->data) {
       ip = r->data;
       /* ito = NULL; */
      }
      /* TODO: more? */
     }"'')
         }

         IF $isDeclUsed(Declaration.funcRef)
           # Callback.
           fd.write(''" else if (to == &cb__T) {
      int i;
      Tcbx *r = (Tcbx*)p;
      if (r->toCount >= 0) {
       ip = r->cb;
       ito = &cb__T;
       for (i = 0; i < r->toCount; ++i) {
        void *pp = *(char**)((char*)r + r->to[i].off);
        ADD_ITEM(pp, r->to[i].type)
       }
      }
     }"'')
         }

         # Normal object: use list of members
         fd.write(''" else {
      int i;
      To *tto = ((Tto*)to)->to;
      for (i = 1; i <= tto->off; ++i) {
       if (tto[i].type == &iobj__T"'')
         IF $isDeclUsed(Type.aDyn)
           fd.write(" || tto[i].type == &dyn__T")
         }
         fd.write(''") {
        void *pp = (char*)p + tto[i].off;
        ADD_ITEM(pp, tto[i].type)
       } else"'')
         IF $isDeclUsed(Declaration.itemToString)
             fd.write(''"
        if (tto[i].type->nr >= 200)"'')
             }
             fd.write(''"
       {
        void *pp = *(char**)((char*)p + tto[i].off);
        ADD_ITEM(pp, tto[i].type)
       }
      }
     }
    }
   }
"'')
          # When "ip" is not NULL: Marking this one item.
          # Otherwise: get an item to mark from "b" or "b->next".
          fd.write(''"
p_is_null:
   if (ip) {
    p = ip;
    to = ito;
   } else if (b && used > 0) {
    --used;
    p = b->items[used].var;
    to = b->items[used].type;
   } else if (b) {
    gcs->todo = b->next;
    b->next = gcs->empty;
    gcs->empty = b;
    b = gcs->todo;
    if (b) {
     used = b->used - 1;
     p = b->items[used].var;
     to = b->items[used].type;
    } else {
     used = GC_BLOCK_SIZE;
     p = NULL;
    }
   } else p = NULL;
  }
 }

 while (gcs->empty) {
  b = gcs->empty->next;
  free(gcs->empty);
  gcs->empty = b;
 }
}
#undef ADD_ITEM"'')

          IF $isDeclUsed(Declaration.hasFinish)
            # Move unmarked items from "p" to "toFinish" if they have an
            # executable Finish() method.
            fd.write(''"
Zohf *ZgcCheckFinish(Zohf *firstUsedF) {
 Zohf *prev = NULL;
 Zohf *p = firstUsedF;
 Zohf *newFirstUsedF = firstUsedF;
 Zoh *np;
 Zohf *rp;
 while (p != ZOHF_LAST) {
  np = p->np;
  rp = (Zohf*)((Tip)np & ~3);
  if (((Tip)np & 3) != newMark && (((Zohf *)p)->fok & FOK_OK) == 0) {
   if (prev) prev->np = (Zoh*)(((Tip)prev->np & 3) | (Tip)rp);
   else newFirstUsedF = rp;
   p->np = (Zoh*)toFinish;
   toFinish = p;
  } else {
   prev = p;
  }
  p = rp;
 }
 return newFirstUsedF;
}
"'')
            # Mark items in toFinish as used, except the item itself.
            fd.write(''"
void ZgcFinishMark(Tn *e) {
 Zohf *p = toFinish;
 while (p != ZOHF_LAST) {
  To *to = p->to;
  int i;
  for (i = 1; i <= to->off; ++i)"'')
            IF $isDeclUsed(Declaration.itemToString)
              fd.write(''"
   if (to[i].type->nr >= 200)"'')
            }
            fd.write(''"
   {
    void *pp = *(char**)((char*)p + to[i].off);
    ZgcMarkItems(e, 0, pp, to[i].type);
   }
  p = (Zohf*)((Tip)(p->np) & ~3);
 }
}
"'')
            # Find an unmarked item in toFinish.  If there is one, move all
            # the marked items back to usedListF/firstUsedF.
            fd.write(''"
void ZgcFinishMoveBack() {
 Zohf *p = toFinish;
 while (p != ZOHF_LAST) {
  if (((Tip)p->np & 3) != newMark) break;
  p = (Zohf*)((Tip)(p->np) & ~3);
 }
 if (p != ZOHF_LAST) {
  Zohf *np;
  Zohf *prev = NULL;
  p = toFinish;
  while (p != ZOHF_LAST) {
   np = (Zohf*)((Tip)(p->np) & ~3);
   if (((Tip)p->np & 3) == newMark) {"'')
             IF $isDeclUsed(%pthread)
               fd.write(''"
    if (usedListF == NULL) {
     usedListF = ZaNmi(sizeof(Zohpf));
     usedListF->firstUsedF = ZOHF_LAST;
    }
    p->np = (Zoh*)((Tip)usedListF->firstUsedF | newMark);
    usedListF->firstUsedF = p;"'')
             ELSE
               fd.write(''"
    p->np = (Zoh*)((Tip)firstUsedF | newMark);
    firstUsedF = p;"'')
             }
             fd.write(''"
    if (prev) {
     prev->np = (Zoh*)((Tip)np | ((Tip)(prev->np) & 3));
    } else {
     toFinish = np;
    }
   } else {
    prev = p;
   }
   p = np;
  }
 }
}
"'')
            # Call ZgcCheckFinishList() for all entries in usedListF.
            # Then mark all entries in toFinish.
            # Then move some entries back from toFinish to usedListF.
            IF $isDeclUsed(%pthread)
              fd.write(''"
void ZgcCheckFinishList(Tn *e) {
 Zohpf *prevUsed = NULL;
 Zohpf *p;
 Zohpf *np;
 for (p = usedListF; p; p = np) {
  p->firstUsedF = ZgcCheckFinish(p->firstUsedF);
  np = p->next;
  if (p->firstUsedF == ZOHF_LAST) {
   if (prevUsed == NULL) {
    usedListF = p->next;
   } else {
    prevUsed->next = p->next;
   }
   free(p);
  } else {
   prevUsed = p;
  }
 }
}
"'')
            }
          }

          fd.write(''"
/* free unmarked memory */
Zoh *ZgcFree(Zoh *firstUsed) {
 Zoh *prev = NULL;
 Zoh *p = firstUsed;
 Zoh *newFirstUsed = firstUsed;
 Zoh *np;
 while (p != &Zlast) {
  np = p->np;
  if (((Tip)np & 3) != newMark) {
   np = (Zoh*)((Tip)np & ~3);
   newFirstUsed = np;
   ++ZgcFreeCount;
   free(p);
   p = np;
  } else {
   prev = p;
   p = (Zoh*)((Tip)np & ~3);
   break;
  }
 }
 while (p != &Zlast) {
  np = p->np;
  if (((Tip)np & 3) != newMark) {
   np = (Zoh*)((Tip)np & ~3);
   prev->np = np;
   ++ZgcFreeCount;
   free(p);
   p = np;
  } else {
   prev = p;
   p = (Zoh*)((Tip)np & ~3);
  }
 }
 return newFirstUsed;
}
"'')

      string current = DeclStore.getPName("MTIMEModule", "Fcurrent")
      IF $isDeclUsed(%pthread)
        fd.write(''"
void ZgcFreeList(Zohp **listp) {
 Zohp *prevUsed = NULL;
 Zohp *p;
 Zohp *np;
 Zohp *first;
 pthread_mutex_lock(&usedListMutex);
 first = *listp;
 *listp = NULL;
 pthread_mutex_unlock(&usedListMutex);
 for (p = first; p; p = np) {
  p->firstUsed = ZgcFree(p->firstUsed);
  np = p->next;
  if (p->firstUsed == &Zlast) {
   if (prevUsed == NULL) {
    first = p->next;
   } else {
    prevUsed->next = p->next;
   }
   free(p);
  } else {
   prevUsed = p;
  }
 }
 pthread_mutex_lock(&usedListMutex);
 if (*listp == NULL) {
  *listp = first;
 } else {
  for (p = *listp; p->next; p = p->next)
   ;
  p->next = first;
 }
 pthread_mutex_unlock(&usedListMutex);
}
"'')
        # The following is tricky, because of the mutexes:
        # - Lock threadsMutex while going through the "threads" list, but
        #   unlock it when waiting.
        # - Threads may exit while waiting. Use pthread_kill() to check if a
        #   thread still exists. Ignore threads with "finished" set.
        # - Threads may be created while waiting.
        #
        # The inGC flags is used to avoid doing this recursively.  Avoids
        # trying to run the GC on exit when the GC caused an exception.
        fd.write(''"
void ZgcLinkedRun() {
 Tn *e = ZgetEnv();
 int i;
 struct timeval tv;
 struct timespec ts;
 Zsf sf;

 if (e->inGC) return;
 e->inGC = 1;"'')
        IF ManageMemory.isExitclean()
          # Set flag that it's OK to allocate memory here.
          fd.write(''"
 sf.frof = NULL;
 sf.prev = e->topFrame;
 sf.pos = 0x40000000;
 e->topFrame = &sf;
"'')
        }
        # 1: Wait for any other GC run to finish.
        fd.write(''"
 pthread_mutex_lock(&gcRunMutex);
"'')
        # 2: Signal threads, get them to GC_STOPPED state: "stop-the-world"
        # start.
        # Note that MingW does not support pthread_kill() with a non-zero
        # signal.
        fd.write(''"
 pthread_mutex_lock(&threadsMutex);
 gcSTW = 1;
 for (i = 0; i < threads->itemCount; ++i) {
  Tn *ie = ZListGetPtr(threads, i);
  if (ie != e && !ie->finished) {
   if (pthread_kill(ie->tid, GC_SIG) == ESRCH) {
    // thread must have died
    ie->finished = 1;
   }
   ie->timedOut = 0;
  }
 }
 pthread_mutex_unlock(&threadsMutex);
"'')
        # 3: Wait for all threads to be in GC_STOPPED state.
        #    After a 10 msec timeout send the signal again to force it calling
        #    ZthreadGC().
        fd.write(''"
 gettimeofday(&tv, NULL);
 ts.tv_sec = tv.tv_sec;
 ts.tv_nsec = tv.tv_usec * 1000 + 10000000; /* 10 msec later */
 if (ts.tv_nsec >= 1000000000L) {
  ts.tv_nsec -= 1000000000L;
  ++ts.tv_sec;
 }
 pthread_mutex_lock(&threadsMutex);
 for (i = 0; i < threads->itemCount; ++i) {
  Tn *ie = ZListGetPtr(threads, i);
  if (ie != e && !ie->finished) {
   pthread_mutex_lock(&ie->stateMutex);
   if (ie->state != GC_STOPPED) {
    if (pthread_kill(ie->tid, 0) == ESRCH) {
     ie->finished = 1;
    } else {
     pthread_mutex_unlock(&threadsMutex);
     i = -1; // start over, "threads" may change
     if (!ie->timedOut) {
      if (pthread_cond_timedwait(&ie->stateCond, &ie->stateMutex, &ts) == ETIMEDOUT) {
       ie->timedOut = 1;
       if (pthread_kill(ie->tid, GC_SIG) == ESRCH) {
        // thread must have died
        ie->finished = 1;
       }
      }
     } else {
      pthread_cond_wait(&ie->stateCond, &ie->stateMutex);
     }
     pthread_mutex_lock(&threadsMutex);
    }
   }
   pthread_mutex_unlock(&ie->stateMutex);
  }
 }
 pthread_mutex_unlock(&threadsMutex);
"'')
        # 4: Start mark phase.
        fd.write(''"
 ZgcMarkTime = "'' .. current .. ''"();
 ZgcStwTime = "'' .. current .. ''"();
 newMark = newMark == 1 ? 2 : 1;
 pthread_mutex_lock(&gcMarkPhaseMutex);
 gcMarkPhase = 1;
 pthread_cond_broadcast(&gcMarkPhaseCond);
 pthread_mutex_unlock(&gcMarkPhaseMutex);
"'')
        # 5: Mark used items in globals and in this thread.
        fd.write(''"
 ZgcMarkItems(e, 1, NULL, NULL);
"'')
        # 6: Wait for all threads to be in GC_MARK_DONE state.
        fd.write(''"
 pthread_mutex_lock(&threadsMutex);
 for (i = 0; i < threads->itemCount; ++i) {
  Tn *ie = ZListGetPtr(threads, i);
  if (ie != e && !ie->finished) {
   pthread_mutex_lock(&ie->stateMutex);
   while (ie->state == GC_STOPPED) pthread_cond_wait(&ie->stateCond, &ie->stateMutex);
   pthread_mutex_unlock(&ie->stateMutex);
  }
 }
 ZgcMarkTime = "'' .. current .. ''"() - ZgcMarkTime;
"'')
        # 7: Move list of used items from all threads to usedList and
        # usedListF.
        fd.write(''"
 for (i = 0; i < threads->itemCount; ++i) {
  Tn *ie = ZListGetPtr(threads, i);
  if (ie->firstUsed != &Zlast) {
   Zohp *entry = ZaNmi(sizeof(Zohp));
   entry->next = usedList;
   usedList = entry;
   entry->firstUsed = ie->firstUsed;
   ie->firstUsed = &Zlast;
  }"'')
        IF $isDeclUsed(Declaration.hasFinish)
          fd.write(''"
  if (ie->firstUsedF != ZOHF_LAST) {
   Zohpf *entry = ZaNmi(sizeof(Zohp));
   entry->next = usedListF;
   usedListF = entry;
   entry->firstUsedF = ie->firstUsedF;
   ie->firstUsedF = ZOHF_LAST;
  }"'')
        }
        fd.write(''"
 }
 pthread_mutex_unlock(&threadsMutex);
"'')

        IF $isDeclUsed(Declaration.hasFinish)
          # 8: Find Finish methods that need to be called.
          fd.write(''"
 ZgcCheckFinishList(e);
 ZgcFinishMark(e);
 ZgcFinishMoveBack();
"'')
        }

        # 9: End mark phase, tell all threads to continue: "stop-the-world"
        # ends.
        fd.write(''"
 pthread_mutex_lock(&gcMarkPhaseMutex);
 gcMarkPhase = 0;
 gcSTW = 0;
 pthread_cond_broadcast(&gcMarkPhaseCond);
 pthread_mutex_unlock(&gcMarkPhaseMutex);
 ZgcStwTime = "'' .. current .. ''"() - ZgcStwTime;
"'')
        # 10: Free unused items from "usedList" and "usedListF".
        fd.write(''"
 ZgcFreeCount = 0;
 ZgcFreeTime = "'' .. current .. ''"();
 ZgcFreeList(&usedList);"'')
        IF $isDeclUsed(Declaration.hasFinish)
          fd.write(''"
 ZgcFreeList((Zohp**)&usedListF);"'')
        }
        fd.write(''"
 ZgcFreeTime = "'' .. current .. ''"() - ZgcFreeTime;
 ZgcUseCount -= ZgcFreeCount;"'')

        IF $isDeclUsed(Declaration.hasFinish)
          # 11: Invoke Finish methods.
          fd.write(''"
 ZgcFinishTime = "'' .. current .. ''"();
 ZgcCallFinish(0);
 ZgcFinishTime = "'' .. current .. ''"() - ZgcFinishTime;"'')
        }

        # 12: Done.
        IF ManageMemory.isExitclean()
          fd.write(''"
 e->topFrame = sf.prev;"'')
        }
        fd.write(''"
 pthread_mutex_unlock(&gcRunMutex);
 e->inGC = 0;
}
"'')

      ELSE
        # When not using threads.
        fd.write(''"
void ZgcLinkedRun() {
 ZgcMarkTime = "'' .. current .. ''"();
 newMark = newMark == 1 ? 2 : 1;
 ZgcMarkItems(&Zenv, 1, NULL, NULL);"'')
        IF $isDeclUsed(Declaration.hasFinish)
          fd.write(''"
 firstUsedF = ZgcCheckFinish(firstUsedF);
 ZgcFinishMark(&Zenv);
 ZgcFinishMoveBack();"'')
        }
        fd.write(''"
 ZgcMarkTime = "'' .. current .. ''"() - ZgcMarkTime;
"'')
        # Free unused items from "firstUsed" and "firstUsedF".
        fd.write(''"
 ZgcFreeCount = 0;
 ZgcFreeTime = "'' .. current .. ''"();
 firstUsed = ZgcFree(firstUsed);"'')
        IF $isDeclUsed(Declaration.hasFinish)
          fd.write(''"
 firstUsedF = (Zohf*)ZgcFree((Zoh*)firstUsedF);"'')
        }
        fd.write(''"
 ZgcFreeTime = "'' .. current .. ''"() - ZgcFreeTime;
 ZgcUseCount -= ZgcFreeCount;
 ZgcStwTime = ZgcMarkTime + ZgcFreeTime;"'')
        IF $isDeclUsed(Declaration.hasFinish)
          # Invoke Finish methods.
          fd.write(''"
 ZgcFinishTime = "'' .. current .. ''"();
 ZgcCallFinish(0);
 ZgcFinishTime = "'' .. current .. ''"() - ZgcFinishTime;"'')
        }
        fd.write(''"
}
"'')
      }
    }

    # Create a new string or byteString for "len" bytes and return it.
    # Store the length in varint encoding and point "*pp" to just after it.
    fd.write(''"
Tc *ZnewStringInit(Ti len, Tc **pp) {
 Ti rlen = len;
 int i;
 int n = ZOH_OFF;
 Tc buf[20];
 Tc *res;
 buf[0] = (rlen & 127);
 rlen >>= 7;
 for (i = 1; rlen > 0; ++i)
 {
  buf[i] = (rlen & 127) + 128;
  rlen >>= 7;
 }
 res = Za(ZOH_OFF + len + i + 1);
 while (i > 0) res[n++] = buf[--i];
 *pp = res + n;
 return res;
}
"'')

    # Create a new string or byteString and copy p[len] into it.
    # Always needed, used for argv[0].
    fd.write(''"
Tc *ZnewString(Tc *p, Ti len) {
 Tc *pp;
 Tc *res = ZnewStringInit(len, &pp);
 memmove(pp, p, len);
 return res;
}
"'')

    # Make a list of file names and methods, so that we need to specify each
    # one only once.
    FOR fname IN CodeTable.files.keys().sort()
      fd.write("Tc " .. CodeTable.files[fname]
                                      .. "[]=\"" .. fname.escape() .. "\";\n")
    }
    FOR text IN CodeTable.methods.keys().sort()
      FOR method IN CodeTable.methods[text]
        fd.write("Tc " .. method.id .. "[]=\"" .. text.escape() .. "\";\n")
        FOR offset IN method.entries.keys().sort()
          fd.write("Tcpos ZcTbl" .. offset)
          fd.write("[]={\n")
          int off
          FOR pos IN method.entries[offset]
            IF pos == NIL
              fd.write("{NULL," .. method.id .. ",0,0},\n")
            ELSE
              IF off == 0
                fd.write("{" .. pos.lnum)
                off = pos.lnum
              ELSE
                fd.write("{" .. pos.lnum - off)
              }
              fd.write("," .. pos.col)
              fd.write("},\n")
            }
          }
          fd.write("};\n")
        }
      }
    }

    fd.write("Tcode ZcodeTable[]={\n")
    FOR offset IN CodeTable.usedOffsets.keys().sort()
      CodeTable.Method method = CodeTable.usedOffsets[offset]
      fd.write("{" .. offset)
      fd.write(",")
      fd.write(method.fileId)
      fd.write(",")
      fd.write(method.id)
      fd.write(",ZcTbl" .. offset)
      fd.write("},\n")
    }
    fd.write("};\n")

    fd.write(''"
#ifdef SIGSEGV
void Zdeadly(int nr) {
 ZthrowDeadly(nr);
}
#endif
"'')

    IF $isDeclUsed(%pthread) && $manageMemory()
                                             && $isDeclUsed(Declaration.gcRun)
      # Upon receiving the GC_SIG signal ZwantGC is called. At a safe point
      # ZthreadGC() will be called.  When a second signal arrives, call
      # ZthreadGC() right away (assume the code is in a busy loop).
      #
      # The safe point is when the stack frame position does not have the
      # "UNSAFE" bit set: 0x40000000. This bit is set just before calling an
      # unsafe function.  The called function will then check the wantGC flag
      # after it resets the "UNSAFE" bit. This is when it is sure its stack
      # frame and all arguments are referenced.
      #
      # The UNSAFE bit in "pos" must be set before entering unsafe code,
      # otherwise a deadlock may result.  E.g.:
      # 1. thread is inside malloc(), holding lock to global memory pool
      # 2. signal arrives, starts GC
      # 3. GC methods allocate memory, call malloc(), obtaining global memory
      #    pool lock results in deadlock.
      # To set the UNSAFE bit call $writeBeforeUnsafe() and call
      # $writeAfterUnsafe() afterwards.
      #
      # MT-GC: stands for Multi Threaded Garbage Collection
      #
      # Unsafe code and functions is where executing the GC may cause used
      # memory to be freed and/or a deadlock may occur.  This is when:
      # - Allocating of freeing memory (malloc() and free()), these may use
      #   locks and must not be interrupted with any other code that allocates
      #   or frees memory.
      # - Where pointers are not referenced. This can be the function
      #   arguments and the function return value.
      # User functions are always assumed to be unsafe.
      # For internal functions a comment with "MT-GC" is added.
      # When --exitclean is specified many of the unsafe functions will throw
      # an exception if called without the UNSAFE bit set.
      fd.write(''"
void ZwantGC(int nr) {
 Tn *e = ZgetEnv();
 if (e->wantGC || e->finished || e->topFrame == NULL || (e->topFrame->pos & 0x40000000) == 0) ZthreadGC();
 else e->wantGC = 1;
}
void ZthreadGC() {
 Tn *e = ZgetEnv();
 if (e->inGC) return;
 e->inGC = 1;
 e->wantGC = 0;

 // Let GC thread know we are waiting.
 pthread_mutex_lock(&e->stateMutex);
 e->state = GC_STOPPED;
 pthread_cond_broadcast(&e->stateCond);
 pthread_mutex_unlock(&e->stateMutex);

 // Wait for mark phase to start.
 pthread_mutex_lock(&gcMarkPhaseMutex);
 while (!gcMarkPhase) pthread_cond_wait(&gcMarkPhaseCond, &gcMarkPhaseMutex);
 pthread_mutex_unlock(&gcMarkPhaseMutex);

 // Mark items on the stack.
 ZgcMarkItems(e, 0, NULL, NULL);

 // Let GC thread know we are done.
 pthread_mutex_lock(&e->stateMutex);
 e->state = GC_MARK_DONE;
 pthread_cond_broadcast(&e->stateCond);
 pthread_mutex_unlock(&e->stateMutex);

 // Wait for end of mark phase.
 pthread_mutex_lock(&gcMarkPhaseMutex);
 while (gcMarkPhase) pthread_cond_wait(&gcMarkPhaseCond, &gcMarkPhaseMutex);
 pthread_mutex_unlock(&gcMarkPhaseMutex);

 e->inGC = 0;
}
"'')
    ELSE
      # Dummy function for when GC.run() is not used.  Needed because
      # lib/THREADModule.zu uses it without an #ifdef.
      fd.write(''"
void ZthreadGC() {
}"'')
    }

    # This is always generated, it's used in IO.write()
    # Return size in bytes of |s| and set |dp| to first value byte.
    fd.write(''"
Ti ZstringSizePtr(Tc *s, Tc **dp) {
 Tc *p;
 Ti len;
 p = s + ZOH_OFF;
 if ((*p & 0x80) == 0) {  /* be quick for short string */
  *dp = p + 1;
  return *p;
 }
 len = *p & 0x7f;
 ++p;
 while ((*p & 0x80) != 0) {
  len = (len << 7) + (*p & 0x7f);
  ++p;
 }
 *dp = p + 1;
 return (len << 7) + *p;
}
"'')

    # Write code fragments that were marked as used.
    FOR fragment IN fragments
      IF fragment.produce != NIL && fragment.isUsed(THIS)
        fragment.produce(THIS, fd)
      }
    }

    # Array type
    WriteArrayC.writeBody(THIS, fd)

    # List type
    WriteListC.writeBody(THIS, fd)

    # Dict type
    WriteDictC.writeBody(THIS, fd)

    IF $isDeclUsed(Declaration.typeToString)
      # This code uses TYPE_NUMBERS, keep in sync!
      # TODO: class name, container item/key and typedef items.
      fd.write(''"
Tc *Ztype2string(Tt *type) {
 char *s;
 if (type == NULL) s = "[unknown]";
 else switch (type->nr) {
  case 0: s = "int"; break;
  case 1: s = "int8"; break;
  case 2: s = "int16"; break;
  case 3: s = "int32"; break;
  case 10: s = "nat"; break;
  case 11: s = "byte"; break;
  case 12: s = "nat16"; break;
  case 13: s = "nat32"; break;

  case 21: s = "bool"; break;
  case 22: s = "status"; break;
  case 23: return ZcS(Zstr("enum "), type->name);
  case 24: return ZcS(Zstr("module "), type->name);
  case 25: return ZcS(Zstr("bits "), type->name);

  case 80: s = "float"; break;
  case 81: s = "float32"; break;
  case 82: s = "float80"; break;
  case 83: s = "float128"; break;

  case 101: s = "type"; break;

  case 200: s = "string"; break;
  case 201: s = "byteString"; break;

  case 300: return type->name;
  case 301: return type->name;
  case 302: return type->name;

  case 310: s = "varString"; break;
  case 311: s = "varByteString"; break;

  case 320: return type->name;

  case 330: s = "proc/func"; break;

  case 360: s = "dyn"; break;

  case 390: return ZcS(Zstr("object of "), type->name);
  case 391: s = "iobject"; break;

  default: s = "[unknown]";
 }
 return Zstr(s);
}
"'')
    }

    IF $isDeclUsed(Declaration.typeNameFunc)
      # TODO: class name, container item/key and typedef items.
      fd.write(''"
Tc *ZtypeName(Tt *type) {
 if (type == NULL) return Zstr("NIL");
 return type->name;
}
"'')
    }

    # Write bodies for libraries.
    FOR p IN bodyWriters
      p(THIS, fd)
    }
  }

  # When compiling with --exitclean verify that an unsafe function is called
  # with the UNSAFE bit set.  If not then cause a SIGSEGV.
  PROC $checkUnsafeFunc(IO.File fd)
    IF ManageMemory.isExitclean() && $manageMemory()
      IF $isDeclUsed(%pthread)
        fd.write(''"
 if (ZgetEnv()->topFrame != NULL && (ZgetEnv()->topFrame->pos & 0x40000000) == 0)"'')
      ELSE
        fd.write(''"
 if (topFrame != NULL && (topFrame->pos & 0x40000000) == 0)"'')
      }
      fd.write(''"
  ZreportUnsafe();"'')
    }
  }

  # Function to write a memory allocation function |name|.
  # |linkName| is the list where the allocated block should be linked in.
  # When NIL it is not put in any list.
  # MT-GC: This is an unsafe call, because the allocated memory will not be
  # referenced while returning.
  PROC $writeAllocFunc(string name, bool hasFinish, string linkName, IO.File fd)
    fd.write(''"
/* allocate memory */
void *"'')
    fd.write(name)
    fd.write("(size_t size")
    IF hasFinish
      fd.write(", To *to, Ts (*ff)(void *, Te), int nox")
    }
    fd.write(''") {
 void *p = NULL;"'')
    IF $isDeclUsed(%pthread)
      fd.write(''"
 Tn *e = "'' .. $getEnvCode() .. ''";"'')
    }
    $checkUnsafeFunc(fd)
    # There could be a crash inside calloc(), in which case we get back here
    # when throwing the exception and run into a deadlock.  Better use the
    # emergency alloc then.
    IF $isDeclUsed(%pthread)
      fd.write(''"
 if (!e->inZa) {
  e->inZa = 1;
  p = calloc(1, size);
  e->inZa = 0;
 }
 if (p == NULL) {
  if (e->inZa || e->ZaEntered) {"'')
    ELSE
      fd.write(''"
 if (!inZa) {
  inZa = 1;
  p = calloc(1, size);
  inZa = 0;
 }
 if (p == NULL) {
  if (inZa || ZaEntered) {"'')
    }
    fd.write(''"
   if ("'' .. emergencyAllocSize .. ''" - emergencyAllocUsed >= size) {
    p = emergencyAlloc + emergencyAllocUsed;
    emergencyAllocUsed += size;
    return p;
   }
   fputs("Out of memory ("'' .. name .. ''")\n", stderr);
   fflush(stderr);
   exit(1);
  }"'')
    IF $isDeclUsed(%pthread)
      fd.write(''"
  ++e->ZaEntered;
  ZthrowOutOfMemory(size);
 }
 e->ZaEntered = 0;"'')
    ELSE
      fd.write(''"
  ++ZaEntered;
  ZthrowOutOfMemory(size);
 }
 ZaEntered = 0;"'')
    }
    IF linkName != NIL && (hasFinish ? $hasNpField() : $manageMemory())
      fd.write(''"
 ((Zoh *)p)->np = (Zoh*)"'')
      IF $isDeclUsed(%pthread)
        fd.write("e->")
      }
      fd.write(linkName)
      fd.write(''";
 "'')
      IF $isDeclUsed(%pthread)
        fd.write("e->")
      }
      fd.write(linkName)
      fd.write(''" = p;"'')
      IF $manageMemory() && $isDeclUsed(Declaration.gcRun)
        fd.write(''"
 ++ZgcUseCount;"'')
      }
    }
    IF hasFinish
      fd.write(''"
 ((Zohf *)p)->to = to;
 ((Zohf *)p)->ff = ff;
 if (nox) ((Zohf *)p)->fok = FOK_NOX;"'')
    }
    fd.write(''"
 return p;
}
"'')
  }


  # Write declaration used by $writeBeforeUnsafe().
  PROC $writeDeclForUnsafe(IO.File fd, bool envToo)
    IF $isDeclUsed(%pthread) && $manageMemory()
                                             && $isDeclUsed(Declaration.gcRun)
      IF (envToo)
        fd.write(''"
 Tn *e = ZgetEnv();"'')
      }
      fd.write(''"
 int sp;"'')
    }
  }

  # Write code before doing an operation that can't be interrupted by
  # the garbage collector in a signal handler.
  PROC $writeBeforeUnsafe(IO.File fd)
    IF $isDeclUsed(%pthread) && $manageMemory()
                                             && $isDeclUsed(Declaration.gcRun)
      fd.write(''"
 if (e->topFrame != NULL) {
  sp = e->topFrame->pos;
  e->topFrame->pos = 0x40000000;
 }"'')
    }
  }

  # Write code after doing an operation that writeBeforeUnsafe() was called
  # for.
  PROC $writeAfterUnsafe(IO.File fd)
    IF $isDeclUsed(%pthread) && $manageMemory()
                                             && $isDeclUsed(Declaration.gcRun)
      fd.write(''"
 if (e->topFrame != NULL) {
  e->topFrame->pos = sp;
  if (e->wantGC && (e->topFrame->pos & 0x40000000) == 0) ZthreadGC();
 }"'')
    }
  }

  # Write the preperation of the stack frame for a built-in function.
  PROC $stackFrameLead(IO.File fd)
    fd.write(''"
 Zsf sf;
 static int sfF = 0;
 if (!sfF) {
  sfF = 1;"'')
  }

  # Write the preperation of the stack frame for a built-in function.
  PROC $stackFrameFoot(string foName, IO.File fd)
    fd.write(''"
 }
 sf.frof = "'' .. foName .. ''";
 sf.prev = "'' .. $topFrameName() .. ''";
 sf.pos = 0x40000000;
 "'' .. $topFrameName() .. ''" = &sf;"'')
  }

  # Write the restore of the stack frame for a built-in function.
  PROC $stackFrameEnd(IO.File fd)
    fd.write("\n ")
    fd.write($topFrameName())
    fd.write(" = sf.prev;")
  }

  FUNC $topFrameName() string
    IF $isDeclUsed(%pthread)
      RETURN "e->topFrame"
    }
    RETURN "topFrame"
  }


  SHARED

    # Offset to the position index to indicate a function call will follow.
    int pauseGCOffset = 0x4000'0000  # 0x40000000

    FUNC Init() status
      initFragments()
      RETURN OK
    }

    string linkedDecl = " Zoh *np;\n"
    string finishDecl = " int fok;\n To* to;\n Ts (*ff)(void *, Te);\n"

    # Enough space for a stack trace of 30 entries (hopefully).
    int emergencyAllocSize = 16384

    # Conditional dependency: Only when $cond is used the $dep is marked as
    # used.  The $stringDep pair can be used to find a Declaration after the
    # first pass.
    CLASS CondDepend
      Declaration      $cond
      Declaration      $dep
      list<string>     $stringDep     # To be assigned to $dep with
                                      # DeclStore.getDecl()
    }

    # A fragment of code to be produced when $decl is marked as used.
    CLASS CodeFragment
      Declaration.C       $decl         # produce when this is marked as used.
      list<Declaration>   $dependencies # optional: what the fragment depends on
      list<list<string>>  $stringDeps   # To be added to $dependencies with
                                       # DeclStore.getDecl()
      list<CondDepend>   $condDeps     # Conditional dependencies
      proc<WriteC, IO.File>  $produce  # method to write the fragment
      string            $typedef       # optional: typedef
      string            $declString    # optional: function or structure
                                       # definition
      proc<WriteC, IO.File>  $produceDecl  # method to write the declaration
      list<func< => bool>> $condFuncs   # functions that must return TRUE for
                                       # the fragment to be produced.

      NEW(Declaration.C decl, proc<WriteC, IO.File> proc)
        $decl = decl
        $produce = proc
      }

      # TODO: remove once no longer used.
      FUNC $setDependencies(list<Declaration.C> dependencies) CodeFragment
        # TODO: can we avoid making a copy?
        $dependencies = NEW()
        FOR d IN dependencies
          $dependencies.add(d)
        }
        RETURN THIS
      }

      FUNC $setDependencies(list<Declaration> dependencies) CodeFragment
        $dependencies = dependencies
        RETURN THIS
      }

      FUNC $setDependencies(list<list<string>> stringDeps) CodeFragment
        $stringDeps = stringDeps
        RETURN THIS
      }

      FUNC $addCondDepends(Declaration cond, list<string> dep) CodeFragment
        IF $condDeps == NIL
          $condDeps = NEW()
        }
        CondDepend cd = NEW()
        cd.cond = cond
        cd.stringDep = dep  # cd.dep will be set later
        $condDeps.add(cd)
        RETURN THIS
      }

      FUNC $addCondDepends(Declaration cond, Declaration dep) CodeFragment
        IF $condDeps == NIL
          $condDeps = NEW()
        }
        CondDepend cd = NEW()
        cd.cond = cond
        cd.dep = dep
        $condDeps.add(cd)
        RETURN THIS
      }

      FUNC $addCondFunc(func< => bool> f) CodeFragment
        IF $condFuncs == NIL
          $condFuncs = NEW()
        }
        $condFuncs.add(f)
        RETURN THIS
      }

      FUNC $setTypedef(string typedef) CodeFragment
        $typedef = typedef
        RETURN THIS
      }

      FUNC $setDecl(string decl) CodeFragment
        $declString = decl
        RETURN THIS
      }

      FUNC $setProduceDecl(proc<WriteC, IO.File> proc) CodeFragment
        $produceDecl = proc
        RETURN THIS
      }

      FUNC $isUsed(WriteC gen) bool
        IF !gen.isDeclUsed($decl)
          RETURN FALSE
        }
        FOR f IN $condFuncs
          IF !f()
            RETURN FALSE
          }
        }
        RETURN TRUE
      }

    }

    list<CodeFragment> fragments = NEW()

    PROC initFragments()
      # Initialize |fragments| with all the code fragments we can produce.
      # This keeps all the dependencies, typedefs and structure declarations
      # in one place.
      # Order matters: functions which are written without a declaration need
      # to be written before they are used.

      PROC writeGcRun(WriteC gen, IO.File fd)
        fd.write(''"
void ZgcRun() {"'')
        IF gen.manageMemory()
          fd.write(''"
 ZgcLinkedRun();"'')
        }
        fd.write(''"
}
"'')
      }
      fragments.add(NEW(Declaration.gcRun, writeGcRun))

      PROC writeThrowPos(WriteC gen, IO.File fd)
        string zcPosName = DeclStore.getPName("MZModule", "CPos")
        string throwExcept = DeclStore.getPName("MEModule", "FthrowException")
        fd.write(''"
void ZthrowPos(Ti pos, Tc *text) {
 "'' .. throwExcept .. ''"(pos, text);
}
"'')
      }
      fragments.add(NEW(Declaration.throwPos, writeThrowPos)
          .setDependencies([["MEModule", "FthrowException"],
                            ["MZModule", "CPos"]]))

      PROC writeThrowCstringNil(WriteC gen, IO.File fd)
        string throwNil = DeclStore.getPName("MEModule", "FthrowNil")
        fd.write(''"
void ZthrowCstringNil(char *text) {
 "'' .. throwNil .. ''"(NULL, Zstr(text));
}
"'')
      }
      fragments.add(NEW(Declaration.throwCstringNil, writeThrowCstringNil)
          .setDependencies([["MEModule", "FthrowNil"]])
          .setDecl("void ZthrowCstringNil(char *text);"))


      PROC writeThrowThisNil(WriteC gen, IO.File fd)
        string throwNil = DeclStore.getPName("MEModule", "FthrowNil")
        fd.write(''"
void ZthrowThisNil() {
 "'' .. throwNil .. ''"(NULL, Zstr("THIS is NIL"));
}
"'')
      }
      fragments.add(NEW(Declaration.throwThisNil, writeThrowThisNil)
          .setDependencies([["MEModule", "FthrowNil"]]))


      PROC writeThrowCstringInit(WriteC gen, IO.File fd)
        string throwInit = DeclStore.getPName("MEModule", "FthrowInit")
        fd.write(''"
void ZthrowCstringInit(char *text) {
 "'' .. throwInit .. ''"(Zstr(text));
}
"'')
      }
      fragments.add(NEW(Declaration.throwCstringInit, writeThrowCstringInit)
          .setDependencies([["MEModule", "FthrowInit"]]))

      PROC writeThrowOutOfMemory(WriteC gen, IO.File fd)
        string throwOutOfMem =
                       DeclStore.getPName("MEModule", "FthrowOutOfMemorySize")
        fd.write(''"
void ZthrowOutOfMemory(Ti size) {
 "'' .. throwOutOfMem .. ''"(size);
}
"'')
      }
      fragments.add(NEW(Declaration.throwOutOfMemory, writeThrowOutOfMemory)
          .setDependencies([["MEModule", "FthrowOutOfMemorySize"]]))

      PROC writeThrowCstringOutOfRange(WriteC gen, IO.File fd)
        string throwOutOfRange =
                            DeclStore.getPName("MEModule", "FthrowOutOfRange")
        fd.write(''"
void ZthrowCstringOutOfRange(Ti i, char *text) {
 "'' .. throwOutOfRange .. ''"(i, Zstr(text));
}
"'')
      }
      fragments.add(NEW(Declaration.throwCstringOutOfRange,
                                                  writeThrowCstringOutOfRange)
          .setDependencies([["MEModule", "FthrowOutOfRange"]]))

      PROC writeThrowCstringBadValue(WriteC gen, IO.File fd)
        string throwBadValue = DeclStore.getPName("MEModule", "FthrowBadValue")
        fd.write(''"
void ZthrowCstringBadValue(char *msg) {
 "'' .. throwBadValue .. ''"(Zstr(msg));
}
"'')
      }
      fragments.add(NEW(Declaration.throwCstringBadValue,
                                                    writeThrowCstringBadValue)
          .setDependencies([["MEModule", "FthrowBadValue"]])
          .setDecl("void ZthrowCstringBadValue(char *msg);"))


      PROC writeThrowDeadly(WriteC gen, IO.File fd)
        string throwDeadly = DeclStore.getPName("MEModule", "FthrowDeadly")
        fd.write(''"
void ZthrowDeadly(int nr) {
 "'' .. throwDeadly .. ''"((Ti)nr);
}
"'')
      }
      fragments.add(NEW(Declaration.throwDeadly, writeThrowDeadly)
          .setDependencies([["MEModule", "FthrowDeadly"]]))

      PROC writeThrowThread(WriteC gen, IO.File fd)
        string eThrowThread = DeclStore.getPName("MEModule", "FthrowThread")
        fd.write(''"
void ZthrowThread(Tc *text) {
 "'' .. eThrowThread .. ''"(NULL, text);
}
"'')
      }
      fragments.add(NEW(Declaration.throwThread, writeThrowThread)
          .setDependencies([["MEModule", "FthrowThread"]]))

      PROC writeThrowDyn(WriteC gen, IO.File fd)
        string eThrowDyn = DeclStore.getPName("MEModule", "FthrowDyn")
        fd.write(''"
void ZthrowDyn(Tc *text) {
 "'' .. eThrowDyn .. ''"(text);
}
"'')
      }
      fragments.add(NEW(Declaration.throwDyn, writeThrowDyn)
          .setDependencies([["MEModule", "FthrowDyn"]])
          .setDecl("void ZthrowDyn(Tc *text);"))

      PROC writeThrowInternal(WriteC gen, IO.File fd)
        string eThrowInternal = DeclStore.getPName("MEModule", "FthrowInternal")
        fd.write(''"
void ZthrowInternal(Tc *text) {
 "'' .. eThrowInternal .. ''"(NULL, text);
}
"'')
      }
      fragments.add(NEW(Declaration.throwInternal, writeThrowInternal)
          .setDependencies([["MEModule", "FthrowInternal"]])
          .setDecl("void ZthrowInternal(Tc *t);"))

      PROC writeCstring(WriteC gen, IO.File fd)
        # Return the C string for a Zimbu string.
        fd.write(''"
Tc *ZcString(Tc *s) {
 Tc *p;
 if (s == NULL) return NULL;
 ZstringSizePtr(s, &p);
 return p;
}
"'')
      }
      fragments.add(NEW(%cstring, writeCstring))

      PROC writeBytesPtr(WriteC gen, IO.File fd)
        # Get the "Tc *" pointer to the start of the data from a Ty.
        fd.write(''"
Tc *ZvarByteStringPtr(Ty *b) {
 switch (b->flags & ZbyteStringT_mask) {
  case ZbyteStringT_tiny:
   return b->tiny;
  case ZbyteStringT_string:
   {
    Tc *p;
    ZstringSizePtr(b->data, &p);
    return p;
   }
  case ZbyteStringT_piece:
   return (Tc*)b->data + sizeof(Tp) + ((Tp *)(b->data))->offset;
  case ZbyteStringT_pieceval:
   {
    Tv *pv = (Tv *)b->data;
    return(Tc*)pv->data + pv->offset;
   }
 }
 fprintf(stderr, "Not implemented: ZvarByteStringPtr()\n");
 return NULL;
}
"'')
      }
      fragments.add(NEW(%byteStringPtr, writeBytesPtr)
          .setDependencies([%varByteStringType, %piecevalType, %pieceType]))

      PROC writeTypeInRange(WriteC gen, IO.File fd)
        fd.write(''"
int ZTypeInRange(int type, int low, int high) {
 return type >= low && type <= high;
}
"'')
      }
      fragments.add(NEW(%typeInRange, writeTypeInRange))

      PROC writeIntAsString(WriteC gen, IO.File fd)
        fd.write(''"
Tc *ZintAsString(Ti n) {
 if (n < 0 || n > 0x10fffff)
  ZthrowCstringBadValue("asString(): Character must be in range 0 - 0x10ffff");
 if (n <= 0x7f) {
  Tc *p = Za(ZOH_OFF + 3);
  p[ZOH_OFF] = 1;
  p[ZOH_OFF + 1] = n;
  p[ZOH_OFF + 2] = 0;
  return p;
 }
 if (n <= 0x7ff) {
  Tc *p = Za(ZOH_OFF + 4);
  p[ZOH_OFF] = 2;
  p[ZOH_OFF + 1] = 0xc0 + ((unsigned)n >> 6);
  p[ZOH_OFF + 2] = 0x80 + (n & 0x3f);
  p[ZOH_OFF + 3] = 0;
  return p;
 }
 if (n <= 0xffff) {
  Tc *p = Za(ZOH_OFF + 5);
  p[ZOH_OFF] = 3;
  p[ZOH_OFF + 1] = 0xe0 + ((unsigned)n >> 12);
  p[ZOH_OFF + 2] = 0x80 + (((unsigned)n >> 6) & 0x3f);
  p[ZOH_OFF + 3] = 0x80 + (n & 0x3f);
  p[ZOH_OFF + 4] = 0;
  return p;
 }
 Tc *p = Za(ZOH_OFF + 6);
 p[ZOH_OFF] = 4;
 p[ZOH_OFF + 1] = 0xf0 + ((unsigned)n >> 18);
 p[ZOH_OFF + 2] = 0x80 + (((unsigned)n >> 12) & 0x3f);
 p[ZOH_OFF + 3] = 0x80 + (((unsigned)n >> 6) & 0x3f);
 p[ZOH_OFF + 4] = 0x80 + (n & 0xef);
 p[ZOH_OFF + 5] = 0;
 return p;
}
"'')
      }
      fragments.add(NEW(Declaration.asString, writeIntAsString)
          .setDependencies([Declaration.throwCstringBadValue]))

      PROC writeToCharBuf(WriteC gen, IO.File fd)
        fd.write(''"
int Zchar2stringBuf(Ti n, Tc *buf) {
 if (n < 0 || n > 0x10fffff)
  ZthrowCstringBadValue("asString(): Character must be in range 0 - 0x10ffff");
 if (n <= 0x7f) {
  buf[0] = n;
  buf[1] = 0;
  return 1;
 }
 if (n <= 0x7ff) {
  buf[0] = 0xc0 + ((unsigned)n >> 6);
  buf[1] = 0x80 + (n & 0x3f);
  buf[2] = 0;
  return 2;
 }
 if (n <= 0xffff) {
  buf[0] = 0xe0 + ((unsigned)n >> 12);
  buf[1] = 0x80 + (((unsigned)n >> 6) & 0x3f);
  buf[2] = 0x80 + (n & 0x3f);
  buf[3] = 0;
  return 3;
 }
 buf[0] = 0xf0 + ((unsigned)n >> 18);
 buf[1] = 0x80 + (((unsigned)n >> 12) & 0x3f);
 buf[2] = 0x80 + (((unsigned)n >> 6) & 0x3f);
 buf[3] = 0x80 + (n & 0xef);
 buf[4] = 0;
 return 4;
}
"'')
      }
      fragments.add(NEW(%toCharBuf, writeToCharBuf)
          .setDependencies([Declaration.throwCstringBadValue]))

      PROC writeIntAsBytes(WriteC gen, IO.File fd)
        fd.write(''"
Tc *ZintAsByteString(Ti n) {
 Tc *p = Za(ZOH_OFF + 3);
 p[ZOH_OFF] = 1;
 p[ZOH_OFF + 1] = n;
 p[ZOH_OFF + 2] = 0;
 return p;
}
"'')
      }
      fragments.add(NEW(%intAsByteString, writeIntAsBytes)
          .setDependencies([Declaration.alloc]))

      PROC writeBytesCheckUtf8(WriteC gen, IO.File fd)
        fd.write(''"
Tc *ZbyteStringCheckUtf8(Tc *p) {
 /* TODO */
 return p;
}
"'')
      }
      fragments.add(NEW(%byteStringCheckUtf8, writeBytesCheckUtf8))

      PROC writeFixSign(WriteC gen, IO.File fd)
        # Used for converting intN to int.  "mask" has all bits set, except the
        # lower ones that contain a positive value.  For int5 it is ~15.
        # When the topmost valid bit in "n" is set the value is negative and
        # needs to have all "mask" bits set.
        # TODO: support for 32 and 64 bit separately for efficiency
        fd.write(''"
Ti ZFixSign(Ti n, Ti mask) {
 if (n & mask)
  return n | mask;
 return n;
}
"'')
      }
      fragments.add(NEW(WriteCommon.fixSign, writeFixSign))

      PROC writeStringConcat(WriteC gen, IO.File fd)
        fd.write(''"
/* concat string */
Tc *ZcS(Tc *l, Tc *ri) {
 Tc *l_p;
 Ti l_len;
 Tc *r_p;
 Ti r_len;
 Ti len;
 Tc *pp;
 Tc *r;
 if (l == NULL) {l_len = 3; l_p = (Tc*)"NIL";}
 else l_len = ZstringSizePtr(l, &l_p);
 if (ri == NULL) {r_len = 3; r_p = (Tc*)"NIL";}
 else r_len = ZstringSizePtr(ri, &r_p);
 len = l_len + r_len;
 r = ZnewStringInit(len, &pp);
 memmove(pp, l_p, l_len);
 memmove(pp + l_len, r_p, r_len);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringConcat, writeStringConcat)
          .setDependencies([Declaration.alloc, %string_h, %ctype_h,
                            Declaration.throwCstringNil]))

      PROC writeStringConcat3(WriteC gen, IO.File fd)
        fd.write(''"
/* concat string */
Tc *ZcS3(Tc *s1, Tc *s2, Tc *s3) {
 Tc *p1;
 Ti len1;
 Tc *p2;
 Ti len2;
 Tc *p3;
 Ti len3;
 Ti len;
 Tc *pp;
 Tc *r;
 if (s1 == NULL) {len1 = 3; p1 = (Tc*)"NIL";}
 else len1 = ZstringSizePtr(s1, &p1);
 if (s2 == NULL) {len2 = 3; p2 = (Tc*)"NIL";}
 else len2 = ZstringSizePtr(s2, &p2);
 if (s3 == NULL) {len3 = 3; p3 = (Tc*)"NIL";}
 else len3 = ZstringSizePtr(s3, &p3);
 len = len1 + len2 + len3;
 r = ZnewStringInit(len, &pp);
 memmove(pp, p1, len1);
 memmove(pp + len1, p2, len2);
 memmove(pp + len1 + len2, p3, len3);
 return r;
}
"'')
      }
      fragments.add(NEW(%concat3, writeStringConcat3)
          .setDependencies([Declaration.alloc, %string_h, %ctype_h,
                            Declaration.throwCstringNil]))


      PROC writeStringConcat5(WriteC gen, IO.File fd)
        fd.write(''"
/* concat string */
Tc *ZcS5(Tc *s1, Tc *s2, Tc *s3, Tc *s4, Tc *s5) {
 Tc *p1;
 Ti len1;
 Tc *p2;
 Ti len2;
 Tc *p3;
 Ti len3;
 Tc *p4;
 Ti len4;
 Tc *p5;
 Ti len5;
 Ti len;
 Tc *pp;
 Tc *r;
 if (s1 == NULL) {len1 = 3; p1 = (Tc*)"NIL";}
 else len1 = ZstringSizePtr(s1, &p1);
 if (s2 == NULL) {len2 = 3; p2 = (Tc*)"NIL";}
 else len2 = ZstringSizePtr(s2, &p2);
 if (s3 == NULL) {len3 = 3; p3 = (Tc*)"NIL";}
 else len3 = ZstringSizePtr(s3, &p3);
 if (s4 == NULL) {len4 = 3; p4 = (Tc*)"NIL";}
 else len4 = ZstringSizePtr(s4, &p4);
 if (s5 == (Tc*)1) len5 = 0;
 else if (s5 == NULL) {len5 = 3; p5 = (Tc*)"NIL";}
 else len5 = ZstringSizePtr(s5, &p5);
 len = len1 + len2 + len3 + len4 + len5;
 r = ZnewStringInit(len, &pp);
 memmove(pp, p1, len1);
 memmove(pp + len1, p2, len2);
 memmove(pp + len1 + len2, p3, len3);
 memmove(pp + len1 + len2 + len3, p4, len4);
 if (s5 != (Tc*)1) memmove(pp + len1 + len2 + len3 + len4, p5, len5);
 return r;
}
"'')
      }
      fragments.add(NEW(%concat5, writeStringConcat5)
          .setDependencies([Declaration.alloc, %string_h, %ctype_h,
                            Declaration.throwCstringNil]))

      PROC writeStringConcat8(WriteC gen, IO.File fd)
        fd.write(''"
/* concat string */
Tc *ZcS8(Tc *s1, Tc *s2, Tc *s3, Tc *s4, Tc *s5, Tc *s6, Tc *s7, Tc *s8) {
 Tc *p[8];
 Ti len[8];
 Ti totlen = 0;
 Tc *pp;
 Tc *r;
 int i;
 if (s1 == NULL) {len[0] = 3; p[0] = (Tc*)"NIL";}
 else len[0] = ZstringSizePtr(s1, &p[0]);
 if (s2 == NULL) {len[1] = 3; p[1] = (Tc*)"NIL";}
 else len[1] = ZstringSizePtr(s2, &p[1]);
 if (s3 == NULL) {len[2] = 3; p[2] = (Tc*)"NIL";}
 else len[2] = ZstringSizePtr(s3, &p[2]);
 if (s4 == NULL) {len[3] = 3; p[3] = (Tc*)"NIL";}
 else len[3] = ZstringSizePtr(s4, &p[3]);
 if (s5 == NULL) {len[4] = 3; p[4] = (Tc*)"NIL";}
 else len[4] = ZstringSizePtr(s5, &p[4]);
 if (s6 == NULL) {len[5] = 3; p[5] = (Tc*)"NIL";}
 else len[5] = ZstringSizePtr(s6, &p[5]);
 if (s7 == (Tc*)1) len[6] = 0;
 else if (s7 == NULL) {len[6] = 3; p[6] = (Tc*)"NIL";}
 else len[6] = ZstringSizePtr(s7, &p[6]);
 if (s8 == (Tc*)1) len[7] = 0;
 else if (s8 == NULL) {len[7] = 3; p[7] = (Tc*)"NIL";}
 else len[7] = ZstringSizePtr(s8, &p[7]);
 for (i = 0; i < 8; ++i) totlen += len[i];
 r = ZnewStringInit(totlen, &pp);
 totlen = 0;
 for (i = 0; i < 8; ++i) {
  memmove(pp + totlen, p[i], len[i]);
  totlen += len[i];
 }
 return r;
}
"'')
      }
      fragments.add(NEW(%concat8, writeStringConcat8)
          .setDependencies([Declaration.alloc, %string_h, %ctype_h,
                            Declaration.throwCstringNil]))

      PROC writeStringConcat12(WriteC gen, IO.File fd)
        fd.write(''"
/* concat string */
Tc *ZcS12(Tc *s1, Tc *s2, Tc *s3, Tc *s4, Tc *s5, Tc *s6, Tc *s7, Tc *s8, Tc *s9, Tc *s10, Tc *s11, Tc *s12) {
 Tc *p[12];
 Ti len[12];
 Ti totlen = 0;
 Tc *pp;
 Tc *r;
 int i;
 if (s1 == NULL) {len[0] = 3; p[0] = (Tc*)"NIL";}
 else len[0] = ZstringSizePtr(s1, &p[0]);
 if (s2 == NULL) {len[1] = 3; p[1] = (Tc*)"NIL";}
 else len[1] = ZstringSizePtr(s2, &p[1]);
 if (s3 == NULL) {len[2] = 3; p[2] = (Tc*)"NIL";}
 else len[2] = ZstringSizePtr(s3, &p[2]);
 if (s4 == NULL) {len[3] = 3; p[3] = (Tc*)"NIL";}
 else len[3] = ZstringSizePtr(s4, &p[3]);
 if (s5 == NULL) {len[4] = 3; p[4] = (Tc*)"NIL";}
 else len[4] = ZstringSizePtr(s5, &p[4]);
 if (s6 == NULL) {len[5] = 3; p[5] = (Tc*)"NIL";}
 else len[5] = ZstringSizePtr(s6, &p[5]);
 if (s7 == NULL) {len[6] = 3; p[6] = (Tc*)"NIL";}
 else len[6] = ZstringSizePtr(s7, &p[6]);
 if (s8 == NULL) {len[7] = 3; p[7] = (Tc*)"NIL";}
 else len[7] = ZstringSizePtr(s8, &p[7]);
 if (s9 == NULL) {len[8] = 3; p[8] = (Tc*)"NIL";}
 else len[8] = ZstringSizePtr(s9, &p[8]);
 if (s10 == (Tc*)1) len[9] = 0;
 else if (s10 == NULL) {len[9] = 3; p[9] = (Tc*)"NIL";}
 else len[9] = ZstringSizePtr(s10, &p[9]);
 if (s11 == (Tc*)1) len[10] = 0;
 else if (s11 == NULL) {len[10] = 3; p[10] = (Tc*)"NIL";}
 else len[10] = ZstringSizePtr(s11, &p[10]);
 if (s12 == (Tc*)1) len[11] = 0;
 else if (s12 == NULL) {len[11] = 3; p[11] = (Tc*)"NIL";}
 else len[11] = ZstringSizePtr(s12, &p[11]);
 for (i = 0; i < 12; ++i) totlen += len[i];
 r = ZnewStringInit(totlen, &pp);
 totlen = 0;
 for (i = 0; i < 12; ++i) {
  memmove(pp + totlen, p[i], len[i]);
  totlen += len[i];
 }
 return r;
}
"'')
      }
      fragments.add(NEW(%concat12, writeStringConcat12)
          .setDependencies([Declaration.alloc, %string_h, %ctype_h,
                            Declaration.throwCstringNil]))

      PROC writeAllocObjectRef(WriteC gen, IO.File fd)
        fd.write(''"
Tr Zao(void *ptr, Tc **table, Ti type) {
 Tr tr;
 tr.ptr = ptr;
 tr.table = table;
 tr.type = type;
 return tr;
}
"'')
      }
      fragments.add(NEW(%allocObjectRef, writeAllocObjectRef))

      PROC writeNoAllocObjectRef(WriteC gen, IO.File fd)
        fd.write(''"
/* fill not-allocated object reference */
Tr *Znao(Tr *p, void *ptr, Tc **table, Ti type) {
 p->ptr = ptr;
 p->table = table;
 p->type = type;
 return p;
}
"'')
      }
      fragments.add(NEW(%noAllocObjectRef, writeNoAllocObjectRef))

      PROC writeIobject2Noalloc(WriteC gen, IO.File fd)
        fd.write(''"
/* fill not-allocated object reference */
Tr *Znaio(Tr *p, void *ptr) {
 p->ptr = ((Tr*)ptr)->ptr;
 p->table = ((Tr*)ptr)->table;
 p->type = ((Tr*)ptr)->type;
 return p;
}
"'')
      }
      fragments.add(NEW(%iobject2noalloc, writeIobject2Noalloc))

      PROC writeZaoDyn(WriteC gen, IO.File fd)
        string throwType = DeclStore.getPName("MEModule", "FthrowWrongTypeEx")
        fd.write(''"
Tr ZaoDyn(Tx src, Tc ***table, size_t len, Tt *type, Ti pos) {
 int i;
 for (i = 0; i < len; ++i) {
  if (table[i] && (Tt*)table[i][0] == src.type) {
   Tr tr;
   tr.ptr = src.u.ptr;
   tr.table = (Tc **)table[i];
   tr.type = i;
   return tr;
  }
 }
 "'' .. throwType .. ''"(pos, type, src.type);
 return trZero;
}
"'')
      }
      fragments.add(NEW(Declaration.convertDynToIobject, writeZaoDyn))

      PROC writeDerefFunc(WriteC gen, IO.File fd)
        fd.write(''"
void *Zderef(Tr *obj) {
 if (obj == NULL) return NULL;
 return obj->ptr;
}
"'')
      }
      fragments.add(NEW(%deref, writeDerefFunc))

      PROC writeObjectMember(WriteC gen, IO.File fd)
        fd.write(''"
void *ZoM(Tr tr, Ti index) {
 return tr.ptr + (size_t)tr.table[index];
}
"'')
      }
      fragments.add(NEW(Declaration.objectMember, writeObjectMember))

      PROC writeObjectMemberDotnil(WriteC gen, IO.File fd)
        # Like ZoM() but return a pointer to NULL when "p" is NULL.
        fd.write(''"
/* object reference ?.member */
void *ZoD(Tr tr, Ti index) {
 static Ti nil = 0;
 if (tr.ptr == NULL) return &nil;
 return tr.ptr + (size_t)tr.table[index];
}
"'')
      }
      fragments.add(NEW(Declaration.objectMemberDotnil,
                                                     writeObjectMemberDotnil))

      PROC writeConvert2dyn(WriteC gen, IO.File fd)
        string zcPosName = DeclStore.getPName("MZModule", "CPos")
        fd.write(''"
Tx ZVtoDyn(Ti src, Tt *type) {
 Tx p;
 p.u.ival = src;
 p.type = type;
 return p;
}
Tx ZFtoDyn(Tf src, Tt *type) {
 Tx p;
 p.u.fval = src;
 p.type = type;
 return p;
}
Tx ZPtoDyn(void *src, Tt *type) {
 Tx p;
 if (type == &iobj__T) {
  p.u.ptr = ((Tr*)src)->ptr;
  p.type = (Tt*)((Tr*)src)->table[0];
 } else {
  p.u.ptr = src;
  p.type = type;
 }
 return p;
}
Tx ZIobjtoDyn(Tr src, Tt *type) {
 Tx p;
 p.u.ptr = src.ptr;
 p.type = (Tt*)src.table[0];
 return p;
}
"'')
      }
      fragments.add(NEW(Declaration.convert2dyn, writeConvert2dyn)
          .setDependencies([Declaration.alloc,
                            Declaration.throwCstringNil]))

      PROC writeConvertFromDyn(WriteC gen, IO.File fd)
        string zcPosName = DeclStore.getPName("MZModule", "CPos")
        string throwType = DeclStore.getPName("MEModule", "FthrowWrongTypeEx")
        fd.write(''"
Ti ZDynToV(Tx src, Tt *type, Ti pos) {
 if (src.type != type
   && !(src.type == &byte__T && (type == &nat16__T || type == &nat32__T || type == &nat__T || type == &int16__T || type == &int32__T || type == &int__T))
   && !(src.type == &nat16__T && (type == &nat32__T || type == &nat__T || type == &int32__T || type == &int__T))
   && !(src.type == &nat32__T && (type == &nat__T || type == &int__T))
   && !(src.type == &int8__T && (type == &int16__T || type == &int32__T || type == &int__T))
   && !(src.type == &int16__T && (type == &int32__T || type == &int__T))
   && !(src.type == &int32__T && type == &int__T)) "'' .. throwType .. ''"(pos, type, src.type);
 return src.u.ival;
}
Tf ZDynToF(Tx src, Tt *type, Ti pos) {
 if (src.type != type) "'' .. throwType .. ''"(pos, type, src.type);
 return src.u.fval;
}
void *ZDynToP(Tx src, Tt *type, Ti pos) {
 if (src.type != type) "'' .. throwType .. ''"(pos, type, src.type);
 return src.u.ptr;
}
"'')
      }
      fragments.add(NEW(Declaration.convertFromDyn, writeConvertFromDyn)
          .setDependencies([Declaration.throwCstringNil])
          .setDependencies([["MEModule", "FthrowWrongTypeEx"]]))

      PROC writeConvertZoref(WriteC gen, IO.File fd)
        string throwNil = DeclStore.getPName("MEModule", "FthrowNil")
        string zcPosName = DeclStore.getPName("MZModule", "CPos")
        string throwType = DeclStore.getPName("MEModule", "FthrowWrongType")
        fd.write(''"
Tr ZconvertZioref(Tr orig, Tc ***table, int type, int maxType, Ti pos) {
 Tr p;
 if (orig.ptr == NULL) p.ptr = NULL;
 else {
  if (orig.type < type || orig.type >= maxType) "'' .. throwType .. ''"(pos);
  p.ptr = orig.ptr;
  p.type = orig.type - type;
  p.table = table[p.type];
 }
 return p;
}
"'')
      }
      fragments.add(NEW(Declaration.convertZoref, writeConvertZoref)
          .setDependencies([Declaration.alloc])
          .setDependencies([["MEModule", "FthrowWrongType"]]))

      PROC writeIobject2object(WriteC gen, IO.File fd)
        string zcPosName = DeclStore.getPName("MZModule", "CPos")
        string throwType = DeclStore.getPName("MEModule", "FthrowWrongType")
        fd.write(''"
void *Zio(int type, Ti pos, Tr *p) {
 void *r;
 if (p == NULL || p->ptr == NULL) r = NULL;
 else {
  if (p->type != type) "'' .. throwType .. ''"(pos);
  r = p->ptr;
 }
 return r;
}
"'')
        fd.write(''"
void *Znio(int type, Ti pos, Tr tr) {
 void *r;
 if (tr.ptr == NULL) r = NULL;
 else {
  if (tr.type != type) "'' .. throwType .. ''"(pos);
  r = tr.ptr;
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.iobject2object, writeIobject2object)
          .setDependencies([["MEModule", "FthrowWrongType"],
                            ["MZModule__CPos", "MNEW__1"]]))

      PROC writeExit(WriteC gen, IO.File fd)
        string zcPosName = DeclStore.getPName("MZModule", "CPos")
        IF gen.isDeclUsed(Declaration.try)
          # When inside try/catch there may be a finally, so jump there.
          string throwExit = DeclStore.getPName("MEModule", "FthrowExit")
          fd.write(''"
void Zexit("'' .. zcPosName .. ''" *pos, Ti val) {
 "'' .. throwExit .. ''"(pos, val);
}
"'')
        ELSE
          # Simple: call exit().
          fd.write(''"
void Zexit("'' .. zcPosName .. ''" *pos, Ti val) {
 beforeExit();
 exit((int)val);
}
"'')
        }
      }
      fragments.add(NEW(Declaration.exit, writeExit)
          .addCondDepends(Declaration.try, ["MEModule", "FthrowExit"]))

      PROC writeIobjType(WriteC gen, IO.File fd)
        fd.write(''"
Tt *ZiobjType(Tr *p) {
 if (p == NULL) ZthrowCstringNil("using Type() on NIL");
 return (Tt *)(p->table[0]);
}
"'')
      }
      fragments.add(NEW(%iobjType, writeIobjType))

      # ZnoAllocClear: used to initialize an object on the stack.
      # Set np to Znoalloc, GC now needs to look inside the object.
      PROC writeNoAllocClear(WriteC gen, IO.File fd)
        fd.write(''"
void *ZnoAllocClear(size_t len, void *p"'')
        IF gen.isDeclUsed(Declaration.hasFinish)
          fd.write(", Ts (*finish)(void*, Te)")
        }
        fd.write(''", void *(*init)(void*)) {"'')
        IF gen.hasNpField() && gen.isDeclUsed(Declaration.hasFinish)
          fd.write(''"
 if (finish && ((Zoh*)p)->np != NULL) ZcallFinish(p, 3);"'')
        }
        fd.write(''"
 memset(p, 0, len);"'')
        IF gen.hasNpField()
          fd.write(''"
 ((Zoh*)p)->np = &Znoalloc;"'')
        }
        IF gen.isDeclUsed(Declaration.hasFinish)
          fd.write(''"
 if (finish) ((Zohf*)p)->ff = finish;"'')
        }
        fd.write(''"
 if (init) init(p);
 return p;
}
"'')
      }
      fragments.add(NEW(%noAllocClear, writeNoAllocClear))

      # ZnoAllocNil: used to set an object on the stack to NIL.
      # Set np to NULL, GC must not look inside the object.
      PROC writeNoAllocNil(WriteC gen, IO.File fd)
        fd.write(''"
void ZnoAllocNil(void *p, int hasFinish) {"'')
        IF gen.hasNpField()
          IF gen.isDeclUsed(Declaration.hasFinish)
            fd.write(''"
 if (hasFinish && ((Zoh*)p)->np != NULL) ZcallFinish(p, 3);"'')
          }
          fd.write(''"
 ((Zoh*)p)->np = NULL;"'')
        }
        fd.write(''"
}
"'')
      }
      fragments.add(NEW(%noAllocNil, writeNoAllocNil))

      # ZnoAllocNilIobj: used to call Finish() on an iobject.
      PROC writeNoAllocNilIobj(WriteC gen, IO.File fd)
        fd.write(''"
Tr ZnoAllocNilIobj(Tr *p) {
 ZFinishIobj(p, 3);
 return trZero;
}
"'')
      }
      fragments.add(NEW(%noAllocNilIobj, writeNoAllocNilIobj))

      PROC writeChar2ByteIdx(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZChar2ByteIdx(Tc *p, Ti len, Ti charIdx) {
 Ti idx = 0;
 Ti count = 0;
 while (count < charIdx) {
  if (idx == len) break;
  ++idx;
  if ((p[idx - 1] & 0x80) != 0) {
    while ((p[idx] & 0xc0) == 0x80)
      ++idx;
  }
  ++count;
 }
 return idx;
}
"'')
      }
      fragments.add(NEW(%char2byteIdx, writeChar2ByteIdx))

      PROC writeFromChar(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZfromChar(Tc *p) {
 if (*p <= 0x7f)
  return *p;
 if ((*p & 0xe0) == 0xc0)
  return ((p[0] & 0x1f) << 6) + (p[1] & 0x3f);
 if  ((*p & 0xf0) == 0xe0)
  return ((p[0] & 0x0f) << 12) + ((p[1] & 0x3f) << 6) + (p[2] & 0x3f);
 return ((p[0] & 0x07) << 18) + ((p[1] & 0x3f) << 12) + ((p[2] & 0x3f) << 6) + (p[3] & 0x3f);
}
"'')
      }
      fragments.add(NEW(%fromChar, writeFromChar))

      PROC writeStringGetChar(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringGetChar(Tc *sv, Ti idx) {
 Ti i;
 Tc *p;
 Ti len;
 Ti r;
 if (sv == NULL) ZthrowCstringNil("using [] on NIL");
 if (idx < 0) ZthrowCstringOutOfRange(idx, "using negative index");
 len = ZstringSizePtr(sv, &p);
 i = ZChar2ByteIdx(p, len, idx);
 if (i >= len) ZthrowCstringOutOfRange(idx, "index too big");
 r = ZfromChar(p + i);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringGetChar, writeStringGetChar)
          .setDependencies([%char2byteIdx, %fromChar,
                            Declaration.throwCstringNil,
                            Declaration.throwCstringOutOfRange]))

      PROC writeBytesGetByte(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZbyteStringGetByte(Tc *sv, Ti idx, int dn) {
 Tc *p;
 Ti len;
 Ti r;
 if (sv == NULL) {
  if (dn) return 0;
  ZthrowCstringNil("getting byte from NIL");
 }
 if (idx < 0) ZthrowCstringOutOfRange(idx, "using negative index");
 len = ZstringSizePtr(sv, &p);
 if (idx >= len) ZthrowCstringOutOfRange(idx, "index too big");
 r = p[idx];
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.byteStringGetByte, writeBytesGetByte)
          .setDependencies([Declaration.throwCstringNil,
                            Declaration.throwCstringOutOfRange]))

      PROC writeBytesGetChar(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZbyteStringGetChar(Tc *sv, Ti idx, int dn) {
 Tc *p;
 Ti len;
 Ti r;
 if (sv == NULL) {
  if (dn) return 0;
  ZthrowCstringNil("using getChar() on NIL");
 }
 if (idx < 0) ZthrowCstringOutOfRange(idx, "using negative index");
 len = ZstringSizePtr(sv, &p);
 if (idx >= len) ZthrowCstringOutOfRange(idx, "index too big");
 p += idx;
 r = *p;
 if (r > 0x7f) {
  if ((r & 0xe0) == 0xc0) {
   if (idx + 1 >= len)
    r = -1;
   else
    r = ((r & 0x1f) << 6) + (p[1] & 0x3f);
  } else if  ((*p & 0xf0) == 0xe0) {
   if (idx + 2 >= len)
    r = -1;
   else
    r = ((r & 0x0f) << 12) + ((p[1] & 0x3f) << 6) + (p[2] & 0x3f);
  } else if  ((*p & 0xf8) == 0xf0) {
   if (idx + 3 >= len)
    r = -1;
   else
    r = ((r & 0x07) << 18) + ((p[1] & 0x3f) << 12) + ((p[2] & 0x3f) << 6) + (p[4] & 0x3f);
  } else {
   r = -1;
  }
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.byteStringGetChar, writeBytesGetChar)
          .setDependencies([Declaration.throwCstringNil,
                            Declaration.throwCstringOutOfRange]))

      PROC writeBytesGetCharSize(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZbyteStringGetCharSize(Tc *sv, Ti idx, int dn) {
 Tc *p;
 Ti len;
 Ti c;
 Ti r;
 if (sv == NULL) {
  if (dn) return 0;
  ZthrowCstringNil("using getChar() on NIL");
 }
 if (idx < 0) ZthrowCstringOutOfRange(idx, "using negative index");
 len = ZstringSizePtr(sv, &p);
 if (idx >= len) ZthrowCstringOutOfRange(idx, "index too big");
 c  = p[idx];
 if (c <= 0x7f) {
  r = 1;
 } else if ((c & 0xe0) == 0xc0) {
  if (idx + 1 >= len)
   r = -1;
  else
   r = 2;
 } else if ((c & 0xf0) == 0xe0) {
  if (idx + 2 >= len)
   r = -1;
  else
   r = 3;
 } else if ((c & 0xf8) == 0xf0) {
  if (idx + 3 >= len)
   r = -1;
  else
   r = 4;
 } else {
  r = -1;
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.byteStringGetCharSize, writeBytesGetCharSize)
          .setDependencies([Declaration.throwCstringNil,
                            Declaration.throwCstringOutOfRange]))

      PROC writeBool2string(WriteC gen, IO.File fd)
        fd.write(''"
Tc *Zbool2string(Tb n) {
 return Zstr(n == 0 ? "FALSE" : "TRUE");
}
"'')
      }
      fragments.add(NEW(%bool2string, writeBool2string))

      PROC writeStatus2string(WriteC gen, IO.File fd)
        fd.write(''"
Tc *Zstatus2string(Ts n) {
 return Zstr(n == 0 ? "FAIL" : "OK");
}
"'')
      }
      fragments.add(NEW(%status2string, writeStatus2string))

      # string-like Size()
      PROC writeUtf8size(WriteC gen, IO.File fd)
        # This assumes "sp[len]" is valid UTF-8.
        fd.write(''"
Ti Zutf8size(Tc *sp, Ti len) {
 Tc *p = (Tc*)sp;
 Tc *pend = p + len;
 Ti clen = 0;
 while (p < pend) {
  if ((*p & 0xc0) != 0x80) ++clen;
  ++p;
 }
 return clen;
}
"'')
      }
      fragments.add(NEW(%utf8size, writeUtf8size))

      PROC writeStringSize(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringSize(Tc *s) {
 Tc *p;
 Ti r;
 Ti len;
 if (s == NULL) return 0;
 len = ZstringSizePtr(s, &p);
 r = Zutf8size(p, len);
 return r;
}
"'')
      }
      fragments.add(NEW(%stringSize, writeStringSize)
          .setDependencies([%utf8size]))

      PROC writeVarStringSize(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarStringSize(Ty *b) {
 Ti clen;
 if (b == NULL) clen = 0;
 else if (b->charSize >= 0) clen = b->charSize;
 else if (b->byteSize == 0) clen = 0;
 else {
  clen = Zutf8size(ZvarByteStringPtr(b), b->byteSize);
  b->charSize = clen;
 }
 return clen;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringSize, writeVarStringSize)
          .setDependencies([%utf8size, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writeBytesSize(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZbyteStringSize(Tc *s) {
 Tc *p;
 Ti len;
 if (s == NULL) return 0;
 p = s + ZOH_OFF;
 if ((*p & 0x80) == 0) {
  return *p;  /* be quick for short string */
 }
 len = *p & 0x7f;
 ++p;
 while ((*p & 0x80) != 0) {
  len = (len << 7) + (*p & 0x7f);
  ++p;
 }
 return (len << 7) + *p;
}
"'')
      }
      fragments.add(NEW(Declaration.byteStringSize, writeBytesSize))

      PROC writeVarByteStringSize(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarByteStringSize(Ty *b) {
 if (b == NULL) return 0;
 return b->byteSize;
}
"'')
      }
      fragments.add(NEW(Declaration.varByteStringSize, writeVarByteStringSize)
          .setDependencies([%varByteStringType]))

      PROC writeInt2string(WriteC gen, IO.File fd)
        fd.write(''"
Tc *Zint2string(Ti n) {
 char buf[30];
 char *p;
 int len;
 sprintf(buf, ZINT_FORMAT, n);
 len = (int)strlen(buf);
 p = Za(ZOH_OFF + len + 2);
 p[ZOH_OFF] = len;
 strcpy(p + ZOH_OFF + 1, buf);
 return (Tc*)p;
}
"'')
      }
      fragments.add(NEW(%int2string, writeInt2string)
          .setDependencies([%string_h]))

      PROC writeStringFormat(WriteC gen, IO.File fd)
        fd.write(''"
Tc *ZStringFormat(Tc *str, Tc *fmt) {
 Tc *strp;
 Ti strlen;
 Ti charlen;
 Tc *fmtp;
 Tc *p;
 Ti fmtlen;
 Ti minlen = -1;
 int maxType = 0;
 int ellipses = 0;
 Tc *ellipp;
 Ti maxlen = -1;
 Ti firstByte = 0;
 Ti lastByte;
 Ti fill = 0;
 Ti filloff;
 int twoparts = 0;
 Ti len;
 Tc *pp;
 Tc *res;
 if (str == NULL || fmt == NULL) return str;
 fmtlen = ZstringSizePtr(fmt, &fmtp);
 if (fmtp[fmtlen - 1] != 's') {
  ZthrowCstringBadValue("ToString(): format must end in 's'");
 }
 strlen = ZstringSizePtr(str, &strp);
 charlen = Zutf8size(strp, strlen);
 lastByte = strlen;
 p = fmtp;
 if (*p == '-') ++p;
 if (isdigit(*p)) {
  sscanf((char *)p, ZINT_FORMAT, &minlen);
  while (isdigit(*p)) ++p;
 }
 if (*p == '.') {
  ellipp = p;
  ++p;
  if (*p == '.') { ellipses += 2; ++p; }
  if (*p == '.') { ++ellipses; ++p; }
  if (*p == '-' || *p == '+') maxType = *p++;
  if (isdigit(*p)) {
   sscanf((char *)p, ZINT_FORMAT, &maxlen);
   if (charlen > maxlen) {
    if (maxType == '-') firstByte = ZChar2ByteIdx(strp, strlen, charlen - maxlen);
    else if (maxType == '+' || ellipses == 0) lastByte = ZChar2ByteIdx(strp, strlen, maxlen);
    else {
     twoparts = 1;
     lastByte = ZChar2ByteIdx(strp, strlen, maxlen / 2);
     firstByte = ZChar2ByteIdx(strp, strlen, charlen - maxlen / 2);
    }
    if (minlen >= 0) fill = minlen - maxlen;
   }
  }
 } else {
  fill = minlen - charlen;
 }
 fill = fill < 0 ? 0 : fill;
 filloff = *fmtp == '-' ? 0 : fill;
 if (twoparts) {
  len = lastByte + (strlen - firstByte) + fill;
  res = ZnewStringInit(len, &pp);
  memmove(pp + filloff, strp, lastByte);
  memmove(pp + filloff + lastByte, strp + firstByte, strlen - firstByte);
 } else {
  len = lastByte - firstByte + fill;
  res = ZnewStringInit(len, &pp);
  memmove(pp + filloff, strp + firstByte, lastByte - firstByte);
 }
 if (ellipses) memmove(pp + (maxType == '-' ? 0 : maxType == '+' ? len - ellipses : (len - ellipses) / 2), ellipp, ellipses);
 if (fill > 0) {
  if (*fmtp == '-') pp += len - fill;
  while (--fill >= 0) *pp++ = ' ';
 }
 return res;
}
"'')
      }
      fragments.add(NEW(%stringFormat, writeStringFormat)
          .setDependencies([%string_h,
                            Declaration.throwCstringBadValue,
                            %utf8size,
                            %char2byteIdx]))

      PROC writeIntFormat(WriteC gen, IO.File fd)
        # TODO: check for "d" type, check format.
        fd.write(''"
Tc *ZintFormat(Tc *fmt, Ti n) {
 char fmtbuf[100];
 char buf[100];
 char *p;
 int len;
 int c;
 Tc *fmtp;
 if (fmt == NULL) ZthrowCstringNil("ToString(): format is NIL");
 if (ZstringSizePtr(fmt, &fmtp) > 90) {
  ZthrowCstringBadValue("ToString(): format too long");
 }
 c = fmtp[strlen((char*)fmtp) - 1];
 if (c != 'd' && c != 'x') {
  ZthrowCstringBadValue("ToString(): format must end in 'd' or 'x'");
 }
 sprintf(fmtbuf, "%%%s", fmtp);
 strcpy(fmtbuf + strlen(fmtbuf) - 1, (c == 'd' ? ZINT_FORMAT : ZINT_XFORMAT) + 1);
 sprintf(buf, fmtbuf, n);
 len = (int)strlen(buf);
 p = Za(ZOH_OFF + len + 2);
 p[ZOH_OFF] = len;
 strcpy(p + ZOH_OFF + 1, buf);
 return (Tc*)p;
}
"'')
      }
      fragments.add(NEW(%intFormat, writeIntFormat)
          .setDependencies([%string_h,
                            Declaration.throwCstringNil,
                            Declaration.throwCstringBadValue]))

      PROC writeNat2string(WriteC gen, IO.File fd)
        fd.write(''"
Tc *Znat2string(Tu n) {
 char buf[30];
 char *p;
 int len;
 sprintf(buf, ZNAT_FORMAT, n);
 len = (int)strlen(buf);
 p = Za(ZOH_OFF + len + 2);
 p[ZOH_OFF] = len;
 strcpy(p + ZOH_OFF + 1, buf);
 return (Tc*)p;
}
"'')
      }
      fragments.add(NEW(%nat2string, writeNat2string)
          .setDependencies([%string_h]))

      PROC writeNatFormat(WriteC gen, IO.File fd)
        fd.write(''"
Tc *ZnatFormat(Tc *fmt, Tu n) {
 char fmtbuf[100];
 char buf[30];
 char *p;
 int len;
 int c;
 Tc *fmtp;
 if (fmt == NULL) ZthrowCstringNil("ToString(): format is NIL");
 if (ZstringSizePtr(fmt, &fmtp) > 90) {
  ZthrowCstringBadValue("ToString(): format too long");
 }
 c = fmtp[strlen((char*)fmtp) - 1];
 if (c != 'd' && c != 'x') {
  ZthrowCstringBadValue("ToString(): format must end in 'd' or 'x'");
 }
 sprintf(fmtbuf, "%%%s", fmtp);
 strcpy(fmtbuf + strlen(fmtbuf) - 1, (c == 'd' ? ZNAT_FORMAT : ZINT_XFORMAT) + 1);
 sprintf(buf, fmtbuf, n);
 len = (int)strlen(buf);
 p = Za(ZOH_OFF + len + 2);
 p[ZOH_OFF] = len;
 strcpy(p + ZOH_OFF + 1, buf);
 return (Tc*)p;
}
"'')
      }
      fragments.add(NEW(%natFormat, writeNatFormat)
          .setDependencies([%string_h,
                            Declaration.throwCstringNil,
                            Declaration.throwCstringBadValue]))

      PROC writeCorrectFloatString(WriteC gen, IO.File fd)
        # Corrections for MingW:
        # - Exponent is always three digits, should be two when possible.
        #   If field width specified and the result is shorter, insert a space.
        # - INF and NAN have a wrong format.
        # TODO: Implement a printf that works properly.
        fd.write(''"
#ifdef __MINGW32__
void ZcorrFloatStr(char *buf, char *fmt) {
 size_t len = strlen(buf);
 if (len > 5 && buf[len - 3] == '0' && (buf[len - 5] == 'e' || buf[len - 5] == 'E')) {
  if (fmt != NULL && isdigit(fmt[1]) && strchr(fmt, '.') > 0 && atoi(fmt + 1) >= strlen(buf)) {
   memcpy(buf + 1, buf, len - 2);
   buf[0] = ' ';
  } else {
   buf[len - 3] = buf[len - 2];
   buf[len - 2] = buf[len - 1];
   buf[len - 1] = 0;
  }
 } else if (strcmp(buf, "1.#INF") == 0) {
  strcpy(buf, "inf");
 } else if (strcmp(buf, "-1.#INF") == 0) {
  strcpy(buf, "-inf");
 } else if (strcmp(buf, "1.#QNAN") == 0) {
  strcpy(buf, "nan");
 }
}
#endif
"'')
      }
      fragments.add(NEW(%corrFloatStr, writeCorrectFloatString))

      PROC writeFloat2string(WriteC gen, IO.File fd)
        # MingW uses three digits for the exponent: 1.23e+003.
        # Inside the #ifdef this is corrected.
        fd.write(''"
Tc *Zfloat2string(Tf n) {
 char buf[30];
 char *p;
 int len;
 sprintf(buf, ZFLOAT_FORMAT, n);"'')
        IF Config.isMingw || Config.portable
          fd.write(''"
#ifdef __MINGW32__
 ZcorrFloatStr(buf, NULL);
#endif"'')
        }
        fd.write(''"
 len = (int)strlen(buf);
 p = Za(ZOH_OFF + len + 2);
 p[ZOH_OFF] = len;
 strcpy(p + ZOH_OFF + 1, buf);
 return (Tc*)p;
}
"'')
      }
      fragments.add(NEW(%float2string, writeFloat2string)
          .setDependencies([%string_h, %corrFloatStr]))

      PROC writeFloatFormat(WriteC gen, IO.File fd)
        # TODO: check the format.
        fd.write(''"
Tc *ZfloatFormat(Tc *fmt, Tf n) {
 char fmtbuf[100];
 char buf[100];
 char *p;
 int len;
 Tc *fmtp;
 if (fmt == NULL) ZthrowCstringNil("ToString(): format is NIL");
 if (ZstringSizePtr(fmt, &fmtp) > 90) {
  ZthrowCstringBadValue("ToString(): format too long");
 }
 sprintf(fmtbuf, "%%%s", fmtp);"'')
        IF Config.isMingw || Config.portable
          # MingW doesn't support %F, change to %f.
          fd.write(''"
#ifdef __MINGW32__
 len = (int)strlen(fmtbuf);
 if (fmtbuf[len - 1] == 'F')
  fmtbuf[len - 1] = 'f';
#endif"'')
        }
        fd.write(''"
 sprintf(buf, fmtbuf, n);"'')
        IF Config.isMingw || Config.portable
          fd.write(''"
#ifdef __MINGW32__
 ZcorrFloatStr(buf, fmtbuf);
#endif"'')
        }
        fd.write(''"
 len = (int)strlen(buf);
 p = Za(ZOH_OFF + len + 2);
 p[ZOH_OFF] = len;
 strcpy(p + ZOH_OFF + 1, buf);
 return (Tc*)p;
}
"'')
      }
      fragments.add(NEW(%floatFormat, writeFloatFormat)
          .setDependencies([%string_h,
                            %corrFloatStr,
                            Declaration.throwCstringNil,
                            Declaration.throwCstringBadValue]))

      PROC writeDynType(WriteC gen, IO.File fd)
        fd.write(''"
Tt *ZdynType(Tx arg) {
 return arg.type;
}
"'')
      }
      fragments.add(NEW(%dynType, writeDynType))

      PROC writeEnum2string(WriteC gen, IO.File fd)
        fd.write(''"
Tc *Zenum2string(char **names, Te n) {
 return Zstr((n < 0 || n >= (Te)(size_t)names[0]) ? "INVALID" : names[n + 1]);
}
"'')
      }
      fragments.add(NEW(%enum2string, writeEnum2string)
          .setDecl("Tc *Zenum2string(char **names, Te n);\n"))

      PROC writeEnumFromString(WriteC gen, IO.File fd)
        fd.write(''"
int ZenumFromString(char **names, Tc *s) {
 int i;
 Tc *p;
 ZstringSizePtr(s, &p);
 for (i = 1; i <= (Te)(size_t)names[0]; ++i)
  if (strcmp((char *)p, names[i]) == 0)
   return i - 1;
 return 0;
}
"'')
      }
      fragments.add(NEW(%enumFromString, writeEnumFromString))

      PROC writeBool2varString(WriteC gen, IO.File fd)
        fd.write(''"
Ty *Zbool2varString(Tb n) {
 return Zstring2varString(Zbool2string(n));
}
"'')
      }
      fragments.add(NEW(%bool2varString, writeBool2varString)
          .setDependencies([%string2varString, %bool2string, %varByteStringType]))

      PROC writeStatus2varString(WriteC gen, IO.File fd)
        fd.write(''"
Ty *Zstatus2varString(Ts n) {
 return Zstring2varString(Zstatus2string(n));
}
"'')
      }
      fragments.add(NEW(%status2varString, writeStatus2varString)
          .setDependencies([%string2varString, %status2string, %varByteStringType]))

      PROC writeInt2varString(WriteC gen, IO.File fd)
        fd.write(''"
Ty *Zint2varString(Ti n) {
 char p[30];
 sprintf(p + ZOH_OFF, ZINT_FORMAT, n);
 return Zstring2varString(Zstr(p));
}
"'')
      }
      fragments.add(NEW(%int2varString, writeInt2varString)
          .setDependencies([%string2varString, %varByteStringType]))

      PROC writeBytesWriteTo(WriteC gen, IO.File fd)
        # Write |len| bytes from bytes |b| to |p|, using offset |off|.
        fd.write(''"
void ZbyteStringWriteTo(Ty *b, Tc *p, Ti off, Ti len) {
 switch (b->flags & ZbyteStringT_mask) {
  case ZbyteStringT_tiny:
   memmove(p, b->tiny + off, len);
   break;
  case ZbyteStringT_string:
   {
    Tc *s;
    ZstringSizePtr(b->data, &s);
    memmove(p, s + off, len);
    break;
   }
  case ZbyteStringT_piece:
   memmove(p, (Tc*)b->data + sizeof(Tp) + off, len);
   break;
  case ZbyteStringT_pieceval:
   {
    Tv *pv = (Tv *)b->data;
    memmove(p, (Tc*)pv->data + pv->offset + off, len);
   }
   break;
  case ZbyteStringT_cord:
   {
    Tc *dest = p;
    Tc *src;
    Tcd *cord;
    Ti skip = off;
    Ti todo = len;
    Ti n;
    for (cord = b->data; cord != NULL && todo > 0; cord = cord->next) {
     if (cord->byteSize <= skip) {
      skip -= cord->byteSize;
     } else {
      switch (cord->type) {
       case ZbyteStringT_tiny: src = cord->tiny; break;
       case ZbyteStringT_string: src = (Tc*)cord->data; break;
       case ZbyteStringT_piece: src = (Tc*)cord->data + sizeof(Tp); break;
       default:
        fprintf(stderr, "Not implemented yet: ZbyteStringWriteTo(cord)\n");
        src = (Tc*)"";
      }
      if (cord->byteSize < todo)
       n = cord->byteSize;
      else
       n = todo;
      if (skip > 0) {
       memmove(dest, src + skip, n);
       skip = 0;
      } else {
       memmove(dest, src, n);
      }
      todo -= n;
      dest += n;
     }
    }
   }
   break;
  default:
   fprintf(stderr, "Not implemented yet: ZbyteStringWriteTo(?)\n");
   break;
 }
}
"'')
      }
      fragments.add(NEW(%byteStringWriteTo, writeBytesWriteTo)
          .setDependencies([%string_h, %cordType, %varByteStringType,
                            %piecevalType, %pieceType]))

      PROC writeVarString2string(WriteC gen, IO.File fd)
        fd.write(''"
Tc *ZvarString2string(Ty *b) {
 Ti len;
 int  n = 1;
 Tc *r;
 if (b == NULL) return NULL;
 len = b->byteSize;
 while (len > 127) {
  ++n;
  len = len >> 7;
 }
 r = Za(ZOH_OFF + n + b->byteSize + 1) + ZOH_OFF;
 ZbyteStringWriteTo(b, r + n, 0, b->byteSize);
 r[n + b->byteSize] = 0;
 len = b->byteSize;
 r[--n] = len & 127;
 while (len > 127) {
  len = len >> 7;
  r[--n] = (len & 127) + 128;
 }
 return r - ZOH_OFF;
}
"'')
      }
      fragments.add(NEW(%varString2string, writeVarString2string)
          .setDependencies([%string_h, %varByteStringType, %byteStringWriteTo]))

      PROC writeGetCstring(WriteC gen, IO.File fd)
        # In a string or byteString get a pointer to the text string.  Used for C
        # code.
        fd.write(''"
char *ZgetCstring(Tc *s) {
 Tc *p;
 if (s == NULL) return NULL;
 p = s + ZOH_OFF;
 while ((*p & 0x80) != 0) ++p;
 return (char *)p + 1;
}
"'')
      }
      fragments.add(NEW(%getCstring, writeGetCstring)
          .setDecl("char *ZgetCstring(Tc *s);"))

      PROC writeString2varString(WriteC gen, IO.File fd)
        fd.write(''"
Ty *Zstring2varString(Tc *s) {
 Tc *p;
 Ty *r;
 if (s == NULL) return NULL;
 r = (Ty *)Za(sizeof(Ty));
 r->flags = ZbyteStringT_string;
 r->byteSize = ZstringSizePtr(s, &p);
 r->charSize = -1;
 r->data = s;
 return r;
}
"'')
      }
      fragments.add(NEW(%string2varString, writeString2varString)
          .setDependencies([Declaration.alloc, %varByteStringType])
          .setDecl("Ty *Zstring2varString(Tc *s);"))

      PROC writeVarStringSet(WriteC gen, IO.File fd)
        fd.write(''"
Ty *ZvarByteStringSet(Ty *r, Tc *s) {
 Tc *p;
 if (s == NULL) return NULL;
 memset(r, 0, sizeof(Ty));"'')
        IF gen.hasNpField()
          fd.write(''"
 r->np = &Znoalloc;"'')
        }
        fd.write(''"
 r->flags = ZbyteStringT_string;
 r->byteSize = ZstringSizePtr(s, &p);
 r->charSize = -1;
 r->data = s;
 return r;
}
"'')
      }
      fragments.add(NEW(%varByteStringSet, writeVarStringSet)
          .setDependencies([%varByteStringType])
          .setDecl("Ty *ZvarByteStringSet(Ty*r, Tc *s);"))

      PROC writeVarByteStringCheckUtf8(WriteC gen, IO.File fd)
        fd.write(''"
Ty *ZvarByteStringCheckUtf8(Ty *b) {
 /* TODO */
 return b;
}
"'')
      }
      fragments.add(NEW(%varByteStringCheckUtf8, writeVarByteStringCheckUtf8)
          .setDependencies([%varByteStringType]))

      PROC writeVarStringAddVal(WriteC gen, IO.File fd)
        fd.write(''"
Ty *ZvarStringAddVal(Ty *b, Tc *s) {
 Tc *p;
 Ti len;
 if (b == NULL) ZthrowCstringNil("using add() on NIL");
 if (s == NULL) ZthrowCstringNil("add() argument is NIL");
 len = ZstringSizePtr(s, &p);
 if (b->byteSize == 0) {
  b->flags = ZbyteStringT_string;
  b->byteSize = len;
  b->data = s;
 } else if (b->byteSize + len < sizeof(void*)) {
  /* put data in tiny[] */
  if ((b->flags & ZbyteStringT_mask) != ZbyteStringT_tiny) {
   Tc buf[sizeof(void*)];
   ZbyteStringWriteTo(b, buf, 0, b->byteSize);"'')
        IF !gen.manageMemory()
          fd.write(''"
   ZclearVarByteString(b);"'')
        }
        fd.write(''"
   memmove(b->tiny, buf, b->byteSize);"'')
        IF gen.manageMemory()
          fd.write(''"
  }"'')
        ELSE
          fd.write(''"
  } else ZclearVarByteString(b);"'')
        }
        fd.write(''"
  memmove(b->tiny + b->byteSize, p, len);
  b->byteSize += len;
  b->tiny[b->byteSize] = 0;
  b->flags = ZbyteStringT_tiny;
 } else {
  /* put data in Tp */
  int zlen = b->byteSize + len + 10;
  Tp *piece = Za(sizeof(Tp) + zlen);
  Tc *zp = (Tc*)piece + sizeof(Tp);
  piece->space = zlen - 1;
  piece->offset = 0;
  ZbyteStringWriteTo(b, zp, 0, b->byteSize);"'')
        IF !gen.manageMemory()
          fd.write(''"
  ZclearVarByteString(b);"'')
        }
        fd.write(''"
  memmove(zp + b->byteSize, p, len);
  b->byteSize += len;
  zp[b->byteSize] = 0;
  b->flags = ZbyteStringT_piece;
  b->data = piece;
 }
 b->charSize = -1;
 return b;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringAddVal, writeVarStringAddVal)
          .setDependencies([%string_h, %varByteStringType, %pieceType, %byteStringWriteTo,
                            Declaration.throwCstringNil]))

      PROC writeVarByteStringCopyMutable(WriteC gen, IO.File fd)
        # Make a mutable copy of a varByteString.
        # Returned byteString has type ZbyteStringT_tiny or ZbyteStringT_piece.
        fd.write(''"
Ty *ZvarByteStringCopyMutable(Ty *b) {
 Ty *r = (Ty *)Za(sizeof(Ty));
 Ti len = b->byteSize;
 if (len < sizeof(void*)) {
  ZbyteStringWriteTo(b, r->tiny, 0, len);
  r->tiny[len] = 0;
  r->flags = ZbyteStringT_tiny;
 } else {
  Tp *piece = Za(sizeof(Tp) + len + 1);
  Tc *zp = (Tc*)piece + sizeof(Tp);
  piece->space = len;
  piece->offset = 0;
  ZbyteStringWriteTo(b, zp, 0, len);
  zp[len] = 0;
  r->data = piece;
  r->flags = ZbyteStringT_piece;
 }
 r->byteSize = len;
 return r;
}
"'')
      }
      fragments.add(NEW(%byteStringCopyMutable, writeVarByteStringCopyMutable)
          .setDependencies([Declaration.alloc, %string_h,
                            %varByteStringType, %pieceType, %byteStringWriteTo]))

      PROC writeVarStringToLowerAscii(WriteC gen, IO.File fd)
        fd.write(''"
Ty *ZvarStringToLowerAscii(Ty *b) {
 Ty *r;
 if (b == NULL) return NULL;
 r = ZvarByteStringCopyMutable(b);
 if (b->byteSize > 0) {
  Tc *p;
  Ti i;
  if ((b->flags & ZbyteStringT_mask) == ZbyteStringT_tiny) {
   p = (Tc*)r->tiny;
  } else {
   p = (Tc*)r->data + sizeof(Tp);
  }
  for (i = b->byteSize; --i >= 0; ) {
   *p = tolower(*p);
   ++p;
  }
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringToLowerAscii,
                                                   writeVarStringToLowerAscii)
          .setDependencies([%string_h, %varByteStringType, %pieceType, %byteStringCopyMutable,
                            Declaration.throwCstringNil]))

      PROC writeVarStringToLower(WriteC gen, IO.File fd)
        # TODO: handle utf-8
        fd.write(''"
Ty *ZvarStringToLower(Ty *b) {
 return ZvarStringToLowerAscii(b);
}
"'')
      }
      fragments.add(NEW(%varStringToLower, writeVarStringToLower)
          .setDependencies([Declaration.varStringToLowerAscii, %varByteStringType]))

      PROC writeVarStringToUpperAscii(WriteC gen, IO.File fd)
        fd.write(''"
Ty *ZvarStringToUpperAscii(Ty *b) {
 Ty *r;
 if (b == NULL) return NULL;
 r = ZvarByteStringCopyMutable(b);
 if (b->byteSize > 0) {
  Tc *p;
  Ti i;
  if ((b->flags & ZbyteStringT_mask) == ZbyteStringT_tiny) {
   p = (Tc*)r->tiny;
  } else {
   p = (Tc*)r->data + sizeof(Tp);
  }
  for (i = b->byteSize; --i >= 0; ) {
   *p = toupper(*p);
   ++p;
  }
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringToUpperAscii,
                                                   writeVarStringToUpperAscii)
          .setDependencies([%string_h, %varByteStringType, %pieceType, %byteStringCopyMutable,
                            Declaration.throwCstringNil]))

      PROC writeVarStringToUpper(WriteC gen, IO.File fd)
        # TODO: handle utf-8
        fd.write(''"
Ty *ZvarStringToUpper(Ty *b) {
 return ZvarStringToUpperAscii(b);
}
"'')
      }
      fragments.add(NEW(%varStringToUpper, writeVarStringToUpper)
          .setDependencies([Declaration.varStringToUpperAscii, %varByteStringType]))

      PROC writeStringToLowerAscii(WriteC gen, IO.File fd)
        fd.write(''"
Tc *ZstringToLowerAscii(Tc *ss) {
 Tc *r;
 Tc *d;
 Tc *s;
 Ti len;
 if (ss == NULL) return NULL;
 len = ZstringSizePtr(ss, &s);
 r = ZnewString(s, len);
 d = r + (s - (Tc*)ss);
 while (*s != 0)
  *d++ = tolower(*s++);
 *d = 0;
 return (Tc*)r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringToLowerAscii, writeStringToLowerAscii)
          .setDependencies([%string_h,
                            Declaration.throwCstringNil]))

      PROC writeStringToArray(WriteC gen, IO.File fd)
        # TODO: Set locale to fix format
        string throwIllegalByte =
                           DeclStore.getPName("MEModule", "FthrowIllegalByte")
        fd.write(''"
Ta *ZStringToArray(Tc *ss) {
 Ti blen;
 Ti clen;
 Ti i;
 Tc *s;
 Tc *end;
 Ta *r;
 Tu32 c;
 if (ss == NULL) return NULL;
 blen = ZstringSizePtr(ss, &s);
 end = s + blen;
 clen = Zutf8size(s, blen);
 r = ZnewArray(&nat32__T, sizeof(Tu32), clen);
 for (i = 0; i < clen; ++i) {
  if (*s <= 0x7f) {
   c = *s;
   ++s;
  } else if ((*s & 0xe0) == 0xc0) {
   if (s + 1 >= end) "'' .. throwIllegalByte .. ''"();
   c = ((s[0] & 0x1f) << 6) + (s[1] & 0x3f);
   s += 2;
  } else if ((*s & 0xf0) == 0xe0) {
   if (s + 2 >= end) "'' .. throwIllegalByte .. ''"();
   c = ((s[0] & 0x0f) << 12) + ((s[1] & 0x3f) << 6) + (s[2] & 0x3f);
   s += 3;
  } else if ((*s & 0xf8) == 0xf0) {
   if (s + 3 >= end) "'' .. throwIllegalByte .. ''"();
   c = ((s[0] & 0x07) << 18) + ((s[1] & 0x3f) << 12) + ((s[2] & 0x3f) << 6) + (s[3] & 0x3f);
   s += 4;
  } else "'' .. throwIllegalByte .. ''"();
  ((Tu32*)r->ptr)[i] = c;
 }
 return r;
}
"'')
      }
      fragments.add(NEW(%stringToArray, writeStringToArray)
          .setDependencies([["MEModule", "FthrowIllegalByte"]])
          .setDependencies([Declaration.newArray, %utf8size]))

      PROC writeStringFromArray(WriteC gen, IO.File fd)
        fd.write(''"
Tc *ZStringFromArray(Ta *head, Ti si, Ti ei) {
 Tc *r;
 Tc *p;
 int loop;
 Ti idx;
 Ti len = 0;
 Ti end = head->size[0] - 1;
 if (ei >= 0 && ei < end) end = ei;
 for (loop = 0; loop <= 1; ++loop) {
  for (idx = si; idx <= end; ++idx) {
   int c;
   switch (head->itemType->nr) {
    case 0: c = ((Ti*)head->ptr)[idx]; break;
    case 10: c = ((Tu*)head->ptr)[idx]; break;
    case 1: c = ((char*)head->ptr)[idx]; break;
    case 11: c = ((Tc*)head->ptr)[idx]; break;
    case 2: c = ((Ti16*)head->ptr)[idx]; break;
    case 12: c = ((Tu16*)head->ptr)[idx]; break;
    case 3: c = ((Ti32*)head->ptr)[idx]; break;
    case 13: c = ((Tu32*)head->ptr)[idx]; break;
    default:
     ZthrowCstringBadValue("array must contain int or nat numbers");
   }
   if (loop == 1) {
    int clen = Zchar2stringBuf(c, p);
    p += clen;
   } else {
    if (c <= 0x7f) len += 1;
    else if (c <= 0x7ff) len += 2;
    else if (c <= 0xffff) len += 3;
    else len += 4;
   }
  }
  if (loop == 0) r = ZnewStringInit(len, &p);
 }
 return r;
}
"'')
      }
      fragments.add(NEW(%stringFromArray, writeStringFromArray)
          .setDependencies([Declaration.throwCstringBadValue,
                            %toCharBuf]))

      PROC writeStringToFloat(WriteC gen, IO.File fd)
        # TODO: Set locale to fix format
        fd.write(''"
Tf Zstring2float(Tc *ss, Ti *dn) {
 Tc *s;
 char *e;
 Ti len;
 if (ss == NULL) {
  ZthrowCstringNil("using toFloat() on NIL");
 }
 len = ZstringSizePtr(ss, &s);
 Tf r = strtod((char *)s, &e);
 if (dn) *dn = (Tc*)e - s;
 return r;
}
"'')
      }
      fragments.add(NEW(%stringToFloat, writeStringToFloat)
          .setDependencies([Declaration.throwCstringNil]))

      PROC writeStringToLower(WriteC gen, IO.File fd)
        # TODO: handle utf-8
        fd.write(''"
Tc *ZstringToLower(Tc *ss) {
 return ZstringToLowerAscii(ss);
}
"'')
      }
      fragments.add(NEW(%stringToLower, writeStringToLower)
          .setDependencies([Declaration.stringToLowerAscii]))

      PROC writeStringToUpperAscii(WriteC gen, IO.File fd)
        fd.write(''"
Tc *ZstringToUpperAscii(Tc *ss) {
 Tc *r;
 Tc *d;
 Tc *s;
 Ti len;
 if (ss == NULL) return NULL;
 len = ZstringSizePtr(ss, &s);
 r = ZnewString(s, len);
 d = r + (s - (Tc*)ss);
 while (*s != 0)
  *d++ = toupper(*s++);
 *d = 0;
 return (Tc*)r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringToUpperAscii, writeStringToUpperAscii)
          .setDependencies([%string_h, Declaration.throwCstringNil]))

      PROC writeStringToUpper(WriteC gen, IO.File fd)
        # TODO: handle utf-8
        fd.write(''"
Tc *ZstringToUpper(Tc *ss) {
 return ZstringToUpperAscii(ss);
}
"'')
      }
      fragments.add(NEW(%stringToUpper, writeStringToUpper)
          .setDependencies([Declaration.stringToUpperAscii]))

      PROC writeCordType(WriteC gen, IO.File fd)
        # It's all in the declaration.
      }
      PROC writeCordTypeDecl(WriteC gen, IO.File fd)
        fd.write("struct Zcord__S {\n"
              .. (gen.hasNpField() ? linkedDecl : "")
              .. " Tcd *next;\n"
              .. " Ti byteSize;\n"
              .. " Ti charSize;\n"
              .. " Tc type;\n"
              .. " Ti space;\n"
              .. " Ti offset;\n"
              .. " union {\n"
              .. "  void *data;\n"
              .. "  Tc tiny[sizeof(void*)];\n"
              .. " };\n"
              .. "};\n")
      }
      fragments.add(NEW(%cordType, writeCordType)
          .setTypedef("typedef struct Zcord__S Tcd; /* cord */")
          .setProduceDecl(writeCordTypeDecl))

      PROC writeVarByteStringType(WriteC gen, IO.File fd)
        IF !gen.manageMemory()
          fd.write(''"
void ZfreeVarByteString(Ty *p) {
 ZclearVarByteString(p);
 Zfree(p);
}
void ZclearVarByteString(Ty *p) {
 if (p->flags == ZbyteStringT_pieceval) {
  // TODO
  // Zfree(((Tv*)p->data)->data);
  Zfree(p->data);
 } else if (p->flags == ZbyteStringT_piece) {
  Zfree(p->data);
#if 0
 } else if (p->flags == ZbyteStringT_cord) {
  Zfree(((Tcd*)p->data)->data);
  Zfree(p->data);
#endif
 } else if (p->flags == ZbyteStringT_string) {
  // may be a static string
  // Zfree(p->data);
 }
}
"'')
        }
      }
      PROC writeVarByteStringTypeDecl(WriteC gen, IO.File fd)
        fd.write("struct ZvarByteString__S {\n"
              .. (gen.hasNpField() ? linkedDecl : "")
              .. " union {\n"
              .. "  void *data;\n"
              .. "  Tc tiny[sizeof(void*)];\n"
              .. " };\n"
              .. " Ti byteSize;\n"
              .. " Ti charSize;\n"
              .. " /* short growsize; not used yet */\n"
              .. " Tc flags;\n"
              .. "};\n"
              .. "#define ZbyteStringT_mask     0x07\n"
              .. "#define ZbyteStringT_tiny     0\n"
              .. "#define ZbyteStringT_string   1\n"
              .. "#define ZbyteStringT_piece    2\n"
              .. "#define ZbyteStringT_pieceval 3\n"
              .. "#define ZbyteStringT_cord     4\n"
              # .. "\n"
              # .. "#define ZbyteString_cow       0x08\n"
              # .. "\n"
              # .. "#define ZbyteStringP_mask     0xe0\n"
              # .. "#define ZbyteStringP_default  0x00\n"
              # .. "#define ZbyteStringP_nocord   0x20\n"
              # .. "#define ZbyteStringP_minmem   0x40\n"
              # .. "#define ZbyteStringP_minalloc 0x80\n"
              .. (gen.manageMemory() ? "" : "void ZfreeVarByteString(Ty *p);\n")
              .. (gen.manageMemory() ? "" : "void ZclearVarByteString(Ty *p);\n")
              )
      }
      CodeFragment varByteStringFrag = NEW(%varByteStringType, writeVarByteStringType)
          .setTypedef("typedef struct ZvarByteString__S Ty;")
          .setProduceDecl(writeVarByteStringTypeDecl)
      # TODO: only when memory is not managed
      varByteStringFrag.setDependencies([%zfree])
      fragments.add(varByteStringFrag)

      PROC writePiecevalType(WriteC gen, IO.File fd)
        # It's all in the declaration.
      }
      PROC writePiecevalTypeDecl(WriteC gen, IO.File fd)
        fd.write("struct Zpieceval__S {\n"
              .. (gen.hasNpField() ? linkedDecl : "")
              .. " Ti space;\n"
              .. " Ti offset;\n"
              .. " void *data;\n"
              .. "};\n")
      }
      fragments.add(NEW(%piecevalType, writePiecevalType)
          .setTypedef("typedef struct Zpieceval__S Tv;")
          .setProduceDecl(writePiecevalTypeDecl))

      PROC writePieceType(WriteC gen, IO.File fd)
        # It's all in the declaration.
      }
      PROC writePieceTypeDecl(WriteC gen, IO.File fd)
        fd.write("struct Zpiece__S {\n"
              .. (gen.hasNpField() ? linkedDecl : "")
              .. " Ti space;\n"
              .. " Ti offset;\n"
              .. "};\n")
      }
      fragments.add(NEW(%pieceType, writePieceType)
          .setTypedef("typedef struct Zpiece__S Tp;")
          .setProduceDecl(writePieceTypeDecl))

      # FOR x IN string
      PROC writeForStringNew(WriteC gen, IO.File fd)
        fd.write(''"
void ZforStringNew(Tc *p, Tfs *s) {
 s->len = p == NULL ? 0 : ZstringSizePtr(p, &(s->ptr));
 s->idx = 0;
}
void ZforStringGetInt(Tfs *s, Ti *p) {
 if (s->idx >= s->len) *p = 0;
 else *p = ZfromChar(s->ptr + s->idx);
}
int ZforStringContInt(Tfs *s) {
return s->idx < s->len;
}
void ZforStringNextInt(Tfs *s, Ti *p) {
 if (s->idx < s->len) {
  ++(s->idx);
  while ((s->ptr[s->idx] & 0xc0) == 0x80) ++(s->idx);
 }
 ZforStringGetInt(s, p);
}
"'')
      }
      fragments.add(NEW(Declaration.forString, writeForStringNew)
          .setDependencies([Declaration.alloc, %fromChar,
                                                Declaration.throwCstringNil]))

      # FOR x IN byteString
      PROC writeForBytesNew(WriteC gen, IO.File fd)
        fd.write(''"
void ZforBytestringNew(void *p, Tfs *fs) {
 fs->len = p == NULL ? 0 : ZstringSizePtr(p, &(fs->ptr));
 fs->idx = 0;
}
void ZforBytestringGetInt(Tfs *fs, Ti *p) {
 if (fs->idx >= fs->len) *p = 0;
 else *p = fs->ptr[fs->idx];
}
int ZforBytestringContInt(Tfs *fs) {
 return fs->idx < fs->len;
}
void ZforBytestringNextInt(Tfs *fs, Ti *p) {
 if (fs->idx < fs->len) ++(fs->idx);
 ZforBytestringGetInt(fs, p);
}
"'')
      }
      fragments.add(NEW(Declaration.forBytestring, writeForBytesNew)
          .setDependencies([Declaration.alloc, Declaration.throwCstringNil]))

      PROC writeForStringStruct(WriteC gen, IO.File fd)
        fd.write("struct ZforString__S {\n"
              .. (gen.hasNpField() ? " Zoh *np;\n" : "")
              .. " Tc *ptr;\n"  # pointer to the first byte
              .. " Ti idx;\n"
              .. " Ti len;\n"
              .. "};\n")
      }
      fragments.add(NEW(%forStringStruct, NIL)
          .setTypedef("typedef struct ZforString__S Tfs; /* FOR in string */")
          .setProduceDecl(writeForStringStruct))

      PROC writeForArrayStruct(WriteC gen, IO.File fd)
        fd.write("struct ZforArray__S {\n"
              .. (gen.hasNpField() ? " Zoh *np;\n" : "")
              .. " Ta *a;\n"
              .. " Ti i;\n"
              .. " Ti *keyp;\n"
              .. " void *valp;\n"
              .. "};\n")
      }
      fragments.add(NEW(%forArray, NIL)
          .setTypedef("typedef struct ZforArray__S Tfa; /* FOR in array */")
          .setProduceDecl(writeForArrayStruct))

      PROC writeForListStruct(WriteC gen, IO.File fd)
        fd.write("struct ZforList__S {\n"
              .. (gen.hasNpField() ? " Zoh *np;\n" : "")
              .. " Tl *l;\n"
              .. " Ti i;\n"
              .. " Ti *keyp;\n"
              .. " void *valp;\n"
              .. "};\n")
      }
      fragments.add(NEW(%forList, NIL)
          .setTypedef("typedef struct ZforList__S Tfl; /* FOR in list */")
          .setProduceDecl(writeForListStruct))

      PROC writeForDictStruct(WriteC gen, IO.File fd)
        fd.write("struct ZforDict__S {\n"
              .. (gen.hasNpField() ? " Zoh *np;\n" : "")
              .. " Td *d;\n"
              .. " CDictItem *di;\n"
              .. " Ti todo;\n"
              .. " void *keyp;\n"
              .. " void *valp;\n"
              .. "};\n")
      }
      fragments.add(NEW(%forDict, NIL)
          .setTypedef("typedef struct ZforDict__S Tfd; /* FOR in dict */")
          .setProduceDecl(writeForDictStruct))

      # FOR x IN start TO end [STEP step]
      PROC writeForRange(WriteC gen, IO.File fd)
        fd.write(''"
void ZforRangeNew(Ti start, Ti last, int until, Ti step, Tfr *s) {
 s->idx = start;
 if (until)
  s->last = last - (step > 0 ? 1 : -1);
 else
  s->last = last;
 s->step = step;
}
void ZforRangeGetInt(Tfr *s, Ti *p) {
 *p = s->idx;
}
int ZforRangeContInt(Tfr *s) {
 return s->step > 0 ? (s->idx <= s->last) : (s->idx >= s->last);
}
void ZforRangeNextInt(Tfr *s, Ti *p) {
 s->idx += s->step;
 ZforRangeGetInt(s, p);
}
"'')
      }
      fragments.add(NEW(%forRange, writeForRange)
          .setDependencies([Declaration.alloc])
          .setTypedef("typedef struct ZforRange__S Tfr; /* FOR in range */")
          .setDecl("struct ZforRange__S {\n"
                .. " Ti idx;\n"
                .. " Ti step;\n"
                .. " Ti last;\n"
                .. "};\n"))

      # FOR x IN enum
      PROC writeForEnum(WriteC gen, IO.File fd)
        fd.write(''"
void ZforEnumGetEnum(Tfe *fe, Te *p) {
 *p = fe->idx;
}
int ZforEnumContEnum(Tfe *fe) {
 return fe->idx < fe->count;
}
void ZforEnumNextEnum(Tfe *fe, Te *p) {
 if (fe->idx < fe->count)
  ++(fe->idx);
 *p = fe->idx;
}
"'')
      }
      fragments.add(NEW(%forEnum, writeForEnum)
          .setDependencies([Declaration.alloc])
          .setTypedef("typedef struct ZforEnum__S Tfe; /* FOR in enum */")
          .setDecl("struct ZforEnum__S {\n"
                .. " int count;\n"
                .. " int idx;\n"
                .. "};"))

      # The stack of TRY/CATCH and thrown exceptions.
      PROC writeTryCatch(WriteC gen, IO.File fd)
        fd.write(''"
void ZtryDeeper(Tn *e, Zsf *sf) {
 if (e->tryCtx == NULL) {
  e->tryCtxSize = 20;
  e->tryCtx = ZaNm(sizeof(Ttc) * e->tryCtxSize);
  e->tryCtxUsed = 1;
 } else if (++e->tryCtxUsed > e->tryCtxSize) {
  e->tryCtxSize += 20;
  e->tryCtx = ZranNm(e->tryCtx, sizeof(Ttc) * (e->tryCtxSize - 20), sizeof(Ttc) * e->tryCtxSize);
 }
 e->tryCtx[e->tryCtxUsed - 1].sf = sf;
}
void Zrethrow() {
 Tn *e = "'' .. gen.getEnvCode() .. ''";
   ZthrowIobject(e->thrown[--e->thrownUsed]);
}
"'')
      }
      fragments.add(NEW(Declaration.try, writeTryCatch)
          .setDependencies([Declaration.alloc, Declaration.throwObject]))

      PROC writeThrowObject(WriteC gen, IO.File fd)
        string unhandled = DeclStore.getPName("MEModule", "FunhandledException")

        # ZthrowIobject handles the exception and jumps back to the CATCH.
        # If there is no TRY/CATCH call E.unhandledException().
        fd.write(''"
void ZthrowIobject(Tr eo) {"'')

        # If there is any TRY jump there.  Put the exception on the stack.
        # Call Finish() for objects on the stack in frames that are going to
        # be dropped.
        IF gen.isDeclUsed(Declaration.try)
          fd.write(''"
 Tn *e = "'' .. gen.getEnvCode() .. ''";
 Ttc *ctx = &e->tryCtx[e->tryCtxUsed - 1];"'')
          IF (gen.isDeclUsed(Declaration.hasFinish)
                                         || gen.isDeclUsed(Declaration.defer))
              && gen.hasNpField()
            fd.write(''"
 int i;
 Zsf *stop = NULL;
 if (e->tryCtxUsed > 0) stop = ctx->sf;
 while ("'' .. gen.topFrameName() .. ''" != stop) {
  Zfo *fo = "'' .. gen.topFrameName() .. ''"->frof;
  if (fo != NULL) {
   for (i = 0; fo[i].off != 0; ++i) {
    Tto *tto = (Tto*)fo[i].type;"'')
            IF gen.isDeclUsed(Declaration.hasFinish)
              fd.write(''"
    if (tto->nr == 390 && tto->Finish != NULL && (fo[i].off & 1)) {
     Zohf *p = (Zohf*)((char *)"'' .. gen.topFrameName() .. ''" - (fo[i].off - 1));
     if (p->np != NULL) {
      ZcallFinish(p, 2);
      p->np = NULL;
     }
    } else if (tto->nr == 391 && (fo[i].off & 1)) {
     ZFinishIobj((Tr*)((char *)"'' .. gen.topFrameName() .. ''" - (fo[i].off - 1)), 2);"'')
            }
            IF gen.isDeclUsed(Declaration.defer)
              fd.write(''"
    } else if ((Tt*)tto == &defer__T) {
     ZdeferCall((Tl*)((char *)"'' .. gen.topFrameName() .. ''" - (fo[i].off - 1)));"'')
            }
            fd.write(''"
    }
   }
  }
  if ("'' .. gen.topFrameName() .. ''"->prev == NULL) break;
  "'' .. gen.topFrameName() .. ''" = "'' .. gen.topFrameName() .. ''"->prev;
 }"'')
          }
          fd.write(''"
 if (e->tryCtxUsed > 0) {
  if (e->thrown == NULL) {
   e->thrownSize = 10;
   e->thrown = ZaNmi(sizeof(Tr) * e->thrownSize);
   e->thrownUsed = 1;
  } else if (++e->thrownUsed > e->thrownSize) {
   e->thrownSize += 20;
   e->thrown = ZranNm(e->thrown, sizeof(Tr) * (e->thrownSize - 20), sizeof(Tr *) * e->thrownSize);
  }
  e->thrown[e->thrownUsed - 1] = eo;
  longjmp(ctx->jmpBuf, 42);
 } else"'')
        }
        # If there is no TRY print the exception and exit.
        fd.write("\n " .. unhandled .. ''"(eo);
}"'')
      }
      fragments.add(NEW(Declaration.throwObject, writeThrowObject)
          .setDependencies([Declaration.alloc])
          .setDependencies([["MEModule", "FunhandledException"]])
          .addCondDepends(Declaration.hasFinish, %finishIobj)
          .setDecl("void ZthrowObject(Tr *eo);\nvoid ZthrowIobject(Tr eo);"))

      PROC writeGaAppend(WriteC gen, IO.File fd)
        fd.write(''"
void ga_append(Tg *ga, char *str) {
 int len = (int)strlen(str);
 if (ga->data == NULL || ga->used + len >= ga->len) {
  int newLen = ga->used + len + 200;
  Tc *newData = ZaOff(newLen);
  if (ga->data != NULL) {
    memmove(newData, ga->data, ga->used);"'')
        IF !gen.manageMemory()
          fd.write(''"
    Zfree(ga->data - ZOH_OFF);"'')
        }
        fd.write(''"
  }
  ga->data = newData;
  ga->len = newLen;
 }
 strcpy((char *)ga->data + ga->used, str);
 ga->used += len;
}
"'')
      }
      CodeFragment garrayFrag = NEW(%garray, writeGaAppend)
          .setTypedef("typedef struct garray__S Tg; /* grow array */")
          .setDecl("struct garray__S {\n"
                .. " Tc *data;\n"
                .. " int used;\n"
                .. " int len;\n"
                .. "};")
      # TODO: zfree only when not managing memory
      garrayFrag.setDependencies([%string_h, %zfree])
      fragments.add(garrayFrag)

      PROC writeBytesHash(WriteC gen, IO.File fd)
        fd.write(''"
Tu ZbyteStringHash(Tc *s) {
 Tc *p;
 Ti l;
 Tu hash;
 if (s == NULL) return 0;
 l = ZstringSizePtr(s, &p);
 if (l == 0) return 0;
 hash = *p;
 while (--l > 0) {
  hash = hash * 101 + *++p;
 }
 return hash;
}
"'')
      }
      fragments.add(NEW(Declaration.byteStringHash, writeBytesHash))

      PROC writeVarByteStringHash(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarByteStringHash(Ty *b) {
 if (b == NULL) return 0;
 return b->byteHash;
}
"'')
      }
      fragments.add(NEW(Declaration.varByteStringHash, writeVarByteStringHash)
          .setDependencies([%varByteStringType]))


      # Note: only returns 0 or 1, cannot be used for sorting.
      PROC writeStringCmp(WriteC gen, IO.File fd)
        fd.write(''"
int ZstringCmp(Tc *s1, Tc *s2) {
 Tc *p1;
 Tc *p2;
 Ti len1;
 Ti len2;
 int r;
 if (s1 == NULL || s2 == NULL) {
  if (s1 == NULL && s2 == NULL) r = 0;
  else r = 1;
  goto end;
 }
 if (s1[ZOH_OFF] != s2[ZOH_OFF]) {
  r = 1;
  goto end;
 }
 len1 = ZstringSizePtr(s1, &p1);
 len2 = ZstringSizePtr(s2, &p2);
 if (len1 == len2) {
  r = memcmp(p1, p2, len1);
  goto end;
 }
 r = 1;
end:
 return r;
}
"'')
      }
      fragments.add(NEW(%stringCmp, writeStringCmp)
          .setDependencies([%string_h]))

      # TODO: varByteStringCmp

      PROC writeChar2byteIdxEnd(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZChar2ByteIdxEnd(Tc *p, Ti len, Ti charIdx) {
 Ti idx = len;
 Ti count = 0;
 while (count < charIdx) {
  if (idx == 0) return -1;
  --idx;
  while (idx > 0 && (p[idx] & 0xc0) == 0x80)
    --idx;
  ++count;
 }
 return idx;
}
"'')
      }
      fragments.add(NEW(%char2byteIdxEnd, writeChar2byteIdxEnd))

      PROC writeStringFindLen(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringFindLen(Tc *big, Ti biglen, Tc *small, Ti smalllen) {
 Ti i;
 Ti ci = 0;
 for (i = 0; i <= biglen - smalllen; ++ci) {
  if (memcmp(big + i, small, smalllen) == 0)
   return ci;
  ++i;
  while ((big[i] & 0xc0) == 0x80 && i < biglen)
   ++i;
 }
 return -1;
}
"'')
      }
      fragments.add(NEW(%stringFindLen, writeStringFindLen)
          .setDependencies([%string_h]))

      PROC writeStringCompare(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringCompare(Tc *one, Tc *two, int dn) {
 Tc *onep;
 Tc *twop;
 Ti onelen;
 Ti twolen;
 Ti r;
 size_t len;
 if (one == NULL) {
  if (!dn) ZthrowCstringNil("using Compare() on NIL");
  if (two == NULL) r = 0;
  else r = -1;
 } else {
  if (two == NULL) ZthrowCstringNil("using Compare() with NIL argument");
  onelen = ZstringSizePtr(one, &onep);
  twolen = ZstringSizePtr(two, &twop);
  len = onelen < twolen ? onelen : twolen;
  r = memcmp(onep, twop, len);
  if (r == 0) r = onelen - twolen;
  if (r < 0) r = -1;
  else if (r > 0) r = 1;
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringCompare, writeStringCompare)
          .setDependencies([Declaration.throwCstringNil]))

      PROC writeStringEqual(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringEqual(Tc *one, Tc *two, int dn) {
 Tc *onep;
 Tc *twop;
 Ti onelen;
 Ti twolen;
 Ti r;
 if (one == NULL) {
  if (!dn) ZthrowCstringNil("using Equal() on NIL");
  r = (two == NULL);
 } else {
  if (two == NULL) return 0;
  onelen = ZstringSizePtr(one, &onep);
  twolen = ZstringSizePtr(two, &twop);
  r = onelen == twolen && memcmp(onep, twop, onelen) == 0;
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringEqual, writeStringEqual)
          .setDependencies([Declaration.throwCstringNil]))

      PROC writeStringFind(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringFind(Tc *big, Tc *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti biglen;
 Ti smalllen;
 Ti r;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using find() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using find() with NIL argument");
  biglen = ZstringSizePtr(big, &bigp);
  smalllen = ZstringSizePtr(small, &smallp);
  r = ZstringFindLen(bigp, biglen, smallp, smalllen);
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringFind, writeStringFind)
          .setDependencies([%stringFindLen, Declaration.throwCstringNil]))

      PROC writeStringFind2(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringFind2(Tc *big, Tc *small, long start, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti biglen;
 Ti smalllen;
 Ti r;
 Ti i = start;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using find() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using find() with NIL argument");
  biglen = ZstringSizePtr(big, &bigp);
  while (biglen > 0 && i > 0) {
   --i;
   while (biglen > 1 && (*bigp & 0xc0) == 0x80) {
    ++bigp;
    --biglen;
   }
   ++bigp;
   --biglen;
  }
  if (i == 0) {
   smalllen = ZstringSizePtr(small, &smallp);
   r = ZstringFindLen(bigp, biglen, smallp, smalllen);
   if (r >= 0) r += start;
  } else {
   r = -1;
  }
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringFind2, writeStringFind2)
          .setDependencies([%stringFindLen, Declaration.throwCstringNil]))

      PROC writeStringFindLastLen(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringFindLastLen(Tc *big, Ti biglen, Tc *small, Ti smalllen) {
 Ti i;
 Ti ci = 0;
 Ti best = -1;
 for (i = 0; i <= biglen - smalllen; ++ci) {
  if (memcmp(big + i, small, smalllen) == 0)
   best = ci;
  ++i;
  while ((big[i] & 0xc0) == 0x80 && i < biglen)
   ++i;
 }
 return best;
}
"'')
      }
      fragments.add(NEW(%stringFindLastLen, writeStringFindLastLen)
          .setDependencies([%string_h]))

      PROC writeStringFindLast(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringFindLast(Tc *big, Tc *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti biglen;
 Ti smalllen;
 Ti r;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using findLast() with NIL argument");
  biglen = ZstringSizePtr(big, &bigp);
  smalllen = ZstringSizePtr(small, &smallp);
  r = ZstringFindLastLen(bigp, biglen, smallp, smalllen);
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringFindLast, writeStringFindLast)
          .setDependencies([%stringFindLastLen, Declaration.throwCstringNil]))

      PROC writeVarStringFind(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarStringFind(Ty *big, Ty *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti r;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using find() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using find() with NIL argument");
  bigp = ZvarByteStringPtr(big);
  smallp = ZvarByteStringPtr(small);
  r = ZstringFindLen(bigp, big->byteSize, smallp, small->byteSize);
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringFind, writeVarStringFind)
          .setDependencies([%stringFindLen, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writeVarStringFindLast(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarStringFindLast(Ty *big, Ty *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti r;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using findLast() with NIL argument");
  bigp = ZvarByteStringPtr(big);
  smallp = ZvarByteStringPtr(small);
  r = ZstringFindLastLen(bigp, big->byteSize, smallp, small->byteSize);
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringFindLast, writeVarStringFindLast)
          .setDependencies([%stringFindLastLen, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writeBytesFindC(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZbyteStringFindC(Tc *big, Ti biglen, Tc *small, Ti smalllen) {
 Ti i;
 for (i = 0; i <= biglen - smalllen; ++i) {
  if (memcmp(big + i, small, smalllen) == 0)
   return i;
 }
 return -1;
}
"'')
      }
      fragments.add(NEW(%byteStringFindC, writeBytesFindC)
          .setDependencies([%string_h]))

      PROC writeBytesFindLastC(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZbyteStringFindLastC(Tc *big, Ti biglen, Tc *small, Ti smalllen) {
 Ti i;
 for (i = biglen - smalllen; i >= 0; --i) {
  if (memcmp(big + i, small, smalllen) == 0)
   return i;
 }
 return -1;
}
"'')
      }
      fragments.add(NEW(%byteStringFindLastC, writeBytesFindLastC)
          .setDependencies([%string_h]))

      PROC writeBytesFind(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZbyteStringFind(Tc *big, Tc *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti biglen;
 Ti smalllen;
 Ti r;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using find() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using find() with NIL argument");
  biglen = ZstringSizePtr(big, &bigp);
  smalllen = ZstringSizePtr(small, &smallp);
  r = ZbyteStringFindC(bigp, biglen, smallp, smalllen);
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.byteStringFind, writeBytesFind)
          .setDependencies([%byteStringFindC, Declaration.throwCstringNil]))

      PROC writeBytesFindLast(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZbyteStringFindLast(Tc *big, Tc *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti biglen;
 Ti smalllen;
 Ti r;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using findLast() with NIL argument");
  biglen = ZstringSizePtr(big, &bigp);
  smalllen = ZstringSizePtr(small, &smallp);
  r = ZbyteStringFindLastC(bigp, biglen, smallp, smalllen);
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.byteStringFindLast, writeBytesFindLast)
          .setDependencies([%byteStringFindLastC, Declaration.throwCstringNil]))

      PROC writeVarByteStringFind(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarByteStringFind(Ty *big, Ty *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti r;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using find() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using find() with NIL argument");
  bigp = ZvarByteStringPtr(big);
  smallp = ZvarByteStringPtr(small);
  r = ZbyteStringFindC(bigp, big->byteSize, smallp, small->byteSize);
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varByteStringFind, writeVarByteStringFind)
          .setDependencies([%byteStringFindC, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writeVarByteStringFindLast(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarByteStringFindLast(Ty *big, Ty *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti r;
 if (big == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
  r = -1;
 } else {
  if (small == NULL) ZthrowCstringNil("using findLast() with NIL argument");
  bigp = ZvarByteStringPtr(big);
  smallp = ZvarByteStringPtr(small);
  r = ZbyteStringFindLastC(bigp, big->byteSize, smallp, small->byteSize);
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varByteStringFindLast, writeVarByteStringFindLast)
          .setDependencies([%byteStringFindLastC, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writePtrFindChar2(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZptrFindChar2(Tc *s, Ti slen, Ti c, Ti low) {
 Tc *p = s;
 Ti idx = 0;
 Ti len;
 Tc buf[5];
 int charlen;
 int clen = Zchar2stringBuf(c, buf);
 for (len = slen; len > 0; len -= charlen) {
  for (charlen = 1; (p[charlen] & 0xc0) == 0x80; ++charlen)
   ;
  if (charlen == clen && memcmp(buf, p, charlen) == 0 && idx >= low) {
   return idx;
  }
  p += charlen;
  ++idx;
 }
 return -1;
}
"'')
      }
      fragments.add(NEW(%ptrFindChar2, writePtrFindChar2)
          .setDependencies([%string_h, %toCharBuf]))

      PROC writeStringFindChar2(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringFindChar2(Tc *s, Ti c, Ti low, int dn) {
 Tc *p;
 int len;
 Ti r;
 if (s == NULL) {
  if (!dn) ZthrowCstringNil("using find() on NIL");
  r = -1;
 } else {
  len = ZstringSizePtr(s, &p);
  r = ZptrFindChar2(p, len, c, low);
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringFindChar2, writeStringFindChar2)
          .setDependencies([%ptrFindChar2, Declaration.throwCstringNil]))

      PROC writeStringFindChar(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringFindChar(Tc *s, Ti c, int dn) {
 return ZstringFindChar2(s, c, 0, dn);
}
"'')
      }
      fragments.add(NEW(Declaration.stringFindChar, writeStringFindChar)
          .setDependencies([Declaration.stringFindChar2]))

      PROC writeVarStringFindChar2(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarStringFindChar2(Ty *b, Ti c, Ti low, int dn) {
 Ti r;
 if (b == NULL) {
  if (dn) return -1;
  ZthrowCstringNil("using find() on NIL");
 }
 r = ZptrFindChar2(ZvarByteStringPtr(b), b->byteSize, c, low);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringFindChar2, writeVarStringFindChar2)
          .setDependencies([%ptrFindChar2, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writeVarStringFindChar(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarStringFindChar(Ty *b, Ti c, int dn) {
 return ZvarStringFindChar2(b, c, 0, dn);
}
"'')
      }
      fragments.add(NEW(Declaration.varStringFindChar, writeVarStringFindChar)
          .setDependencies([Declaration.varStringFindChar2, %varByteStringType]))

      PROC writeStringStartsWith(WriteC gen, IO.File fd)
        fd.write(''"
Tb ZstringStartsWith(Tc *big, Tc *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti biglen;
 Ti smalllen;
 Tb r = 0;
 if (big == NULL) {
  if (dn) goto end;
  ZthrowCstringNil("using startsWith() on NIL");
 }
 if (small == NULL) ZthrowCstringNil("using startsWith() with NIL argument");
 biglen = ZstringSizePtr(big, &bigp);
 smalllen = ZstringSizePtr(small, &smallp);
 if (smalllen <= biglen) r = memcmp(bigp, smallp, smalllen) == 0;
end:
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringStartsWith, writeStringStartsWith)
          .setDependencies([%string_h, Declaration.throwCstringNil]))

      PROC writeStringEndsWith(WriteC gen, IO.File fd)
        fd.write(''"
Tb ZstringEndsWith(Tc *big, Tc *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Ti biglen;
 Ti smalllen;
 Tb r = 0;
 if (big == NULL) {
  if (dn) goto end;
  ZthrowCstringNil("using endsWith() on NIL");
 }
 if (small == NULL) ZthrowCstringNil("using endsWith() with NIL argument");
 biglen = ZstringSizePtr(big, &bigp);
 smalllen = ZstringSizePtr(small, &smallp);
 if (smalllen <= biglen) r = memcmp(bigp + biglen - smalllen, smallp, smalllen) == 0;
end:
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringEndsWith, writeStringEndsWith)
          .setDependencies([%string_h, Declaration.throwCstringNil]))

      PROC writeVarStringStartsWith(WriteC gen, IO.File fd)
        fd.write(''"
Tb ZvarStringStartsWith(Ty *big, Ty *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Tb r = 0;
 if (big == NULL) {
  if (dn) goto end;
  ZthrowCstringNil("using startsWith() on NIL");
 }
 if (small == NULL) ZthrowCstringNil("using startsWith() with NIL argument");
 if (small->byteSize <= big->byteSize) {
  bigp = ZvarByteStringPtr(big);
  smallp = ZvarByteStringPtr(small);
  r = memcmp(bigp, smallp, small->byteSize) == 0;
 }
end:
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringStartsWith,
                                                     writeVarStringStartsWith)
          .setDependencies([%string_h, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writeVarStringEndsWith(WriteC gen, IO.File fd)
        fd.write(''"
Tb ZvarStringEndsWith(Ty *big, Ty *small, int dn) {
 Tc *bigp;
 Tc *smallp;
 Tb r = 0;
 if (big == NULL) {
  if (dn) goto end;
  ZthrowCstringNil("using endsWith() on NIL");
 }
 if (small == NULL) ZthrowCstringNil("using endsWith() with NIL argument");
 if (small->byteSize <= big->byteSize) {
  bigp = ZvarByteStringPtr(big);
  smallp = ZvarByteStringPtr(small);
  r = memcmp(bigp + big->byteSize - small->byteSize, smallp, small->byteSize) == 0;
 }
end:
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringEndsWith, writeVarStringEndsWith)
          .setDependencies([%string_h, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writePtrFindLastChar2(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZptrFindLastChar2(Tc *s, Ti slen, Ti c, Ti high) {
 Tc *p = s;
 Ti idx = 0;
 Ti best = -1;
 Ti len;
 Tc buf[5];
 int charlen;
 int clen = Zchar2stringBuf(c, buf);
 for (len = slen; len > 0 && idx <= high; len -= charlen) {
  for (charlen = 1; (p[charlen] & 0xc0) == 0x80; ++charlen)
   ;
  if (charlen == clen && memcmp(buf, p, charlen) == 0)
   best = idx;
  p += charlen;
  ++idx;
 }
 return best;
}
"'')
      }
      fragments.add(NEW(%ptrFindLastChar2, writePtrFindLastChar2)
          .setDependencies([%string_h, %toCharBuf]))

      PROC writeStringFindLastChar2(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringFindLastChar2(Tc *s, Ti c, Ti high, int dn) {
 Tc *p;
 int len;
 Ti r;
 if (s == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
  r = -1;
 } else {
  len = ZstringSizePtr(s, &p);
  r = ZptrFindLastChar2(p, len, c, high);
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringFindLastChar2,
                                                     writeStringFindLastChar2)
          .setDependencies([%ptrFindLastChar2,
                            Declaration.throwCstringNil]))

      PROC writeStringFindLastChar(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringFindLastChar(Tc *s, Ti c, int dn) {
 Tc *p;
 int len;
 Ti r;
 if (s == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
  r = -1;
 } else {
  len = ZstringSizePtr(s, &p);
  r = ZptrFindLastChar2(p, len, c, len);
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringFindLastChar, writeStringFindLastChar)
          .setDependencies([%ptrFindLastChar2, Declaration.throwCstringNil]))

      PROC writeVarStringFindLastChar2(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarStringFindLastChar2(Ty *b, Ti c, Ti high, int dn) {
 Ti r;
 if (b == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
  r = -1;
 } else r = ZptrFindLastChar2(ZvarByteStringPtr(b), b->byteSize, c, high);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringFindLastChar2,
                                                  writeVarStringFindLastChar2)
          .setDependencies([%ptrFindLastChar2, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writeVarStringFindLastChar(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarStringFindLastChar(Ty *b, Ti c, int dn) {
 return ZvarStringFindLastChar2(b, c, b ? b->byteSize : 0, dn);
}
"'')
      }
      fragments.add(NEW(Declaration.varStringFindLastChar,
                                                   writeVarStringFindLastChar)
          .setDependencies([Declaration.varStringFindLastChar2, %varByteStringType]))

      PROC writeBytesFindByte2(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZbyteStringFindByte2(Tc *s, Ti c, Ti low, int dn) {
 Ti len;
 Tc *p;
 Ti i;
 Ti r = -1;
 if (s == NULL) {
  if (!dn) ZthrowCstringNil("using find() on NIL");
 } else {
  if (c < 0 || c > 0xff) ZthrowCstringBadValue("find() argument out of range");
  len = ZstringSizePtr(s, &p);
  for (i = low; i < len; ++i) {
   if (p[i] == c) {
    r = i;
    break;
   }
  }
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.byteStringFindByte2, writeBytesFindByte2)
          .setDependencies([Declaration.throwCstringNil,
                            Declaration.throwCstringBadValue]))

      PROC writeBytesFindByte(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZbyteStringFindByte(Tc *s, Ti c, int dn) {
 return ZbyteStringFindByte2(s, c, 0, dn);
}
"'')
      }
      fragments.add(NEW(Declaration.byteStringFindByte, writeBytesFindByte)
          .setDependencies([Declaration.byteStringFindByte2]))

      PROC writeBytesFindLastByte2(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZbyteStringFindLastByte2(Tc *s, Ti c, Ti high, int dn) {
 Ti len;
 Tc *p;
 Ti i;
 Ti r = -1;
 if (s == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
 } else {
  if (c < 0 || c > 0xff) ZthrowCstringBadValue("findLast() argument out of range");
  len = ZstringSizePtr(s, &p);
  for (i = high >= len ? len - 1 : high; i >= 0; --i) {
   if (p[i] == c) {
    r = i;
    break;
   }
  }
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.byteStringFindLastByte2, writeBytesFindLastByte2)
          .setDependencies([Declaration.throwCstringNil,
                            Declaration.throwCstringBadValue]))

      PROC writeBytesFindLastByte(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZbyteStringFindLastByte(Tc *s, Ti c, int dn) {
 Ti len;
 Tc *p;
 Ti i;
 Ti r = -1;
 if (s == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
 } else {
  if (c < 0 || c > 0xff) ZthrowCstringBadValue("findLast() argument out of range");
  len = ZstringSizePtr(s, &p);
  for (i = len - 1; i >= 0; --i) {
   if (p[i] == c) {
    r = i;
    break;
   }
  }
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.byteStringFindLastByte, writeBytesFindLastByte)
          .setDependencies([Declaration.throwCstringNil,
                            Declaration.throwCstringBadValue]))

      PROC writeVarByteStringFindByte2(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarByteStringFindByte2(Ty *b, Ti c, Ti low, int dn) {
 Tc *p;
 Ti i;
 Ti r = -1;
 if (b == NULL) {
  if (!dn) ZthrowCstringNil("using find() on NIL");
 } else {
  if (c < 0 || c > 0xff) ZthrowCstringBadValue("find() argument out of range");
  p = ZvarByteStringPtr(b);
  for (i = low; i < b->byteSize; ++i) {
   if (p[i] == c) {
    r = i;
    break;
   }
  }
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varByteStringFindByte2, writeVarByteStringFindByte2)
          .setDependencies([%byteStringPtr, Declaration.throwCstringNil,
                            Declaration.throwCstringBadValue]))

      PROC writeVarByteStringFindByte(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarByteStringFindByte(Ty *b, Ti c, int dn) {
 return ZvarByteStringFindByte2(b, c, 0, dn);
}
"'')
      }
      fragments.add(NEW(Declaration.varByteStringFindByte, writeVarByteStringFindByte)
          .setDependencies([Declaration.varByteStringFindByte2, %varByteStringType]))

      PROC writeVarByteStringFindLastByte2(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarByteStringFindLastByte2(Ty *b, Ti c, Ti high, int dn) {
 Tc *p;
 Ti i;
 Ti r = -1;
 if (b == NULL) {
  if (!dn) ZthrowCstringNil("using findLast() on NIL");
 } else {
  if (c < 0 || c > 0xff) ZthrowCstringBadValue("findLast() argument out of range");
  p = ZvarByteStringPtr(b);
  for (i = (high >= b->byteSize) ? b->byteSize - 1 : high; i >= 0; --i) {
   if (p[i] == c) {
    r = i;
    break;
   }
  }
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varByteStringFindLastByte2,
                                              writeVarByteStringFindLastByte2)
          .setDependencies([%byteStringPtr, Declaration.throwCstringNil,
                            Declaration.throwCstringBadValue]))

      PROC writeVarByteStringFindLastByte(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarByteStringFindLastByte(Ty *b, Ti c, int dn) {
 return ZvarByteStringFindLastByte2(b, c, b ? b->byteSize : 0, dn);
}
"'')
      }
      fragments.add(NEW(Declaration.varByteStringFindLastByte,
                                               writeVarByteStringFindLastByte)
          .setDependencies([Declaration.varByteStringFindLastByte2, %varByteStringType]))

      PROC writeStringSplitLen(WriteC gen, IO.File fd)
        fd.write(''"
Tl *ZstringSplitLen(Tc *pss, Ti len, Tc *m) {
 Tl *head = ZnewList(&string__T, 0);
 if (len > 0) {
  Tc *mp;
  Ti mlen = ZstringSizePtr(m, &mp);
  Tc *ps;
  Tc *pe;

  for (ps = pss; ; ps = pe + mlen) {
   int nlen;
   /* TODO: handle NULL byteString */
   pe = (Tc*)strstr((char *)ps, (char *)mp);
   if (pe == NULL) {
    nlen = len - (ps - pss);
   } else {
    nlen = pe - ps;
   }
   ZLa(head, -1, (Tz)(void*)ZnewString(ps, nlen));
   if (pe == NULL) break;
  }
 }
 return head;
}
"'')
      }
      fragments.add(NEW(%stringSplitLen, writeStringSplitLen)
          .setDependencies([%string_h, Declaration.alloc]))

      PROC writeStringSplit(WriteC gen, IO.File fd)
        fd.write(''"
Tl *ZstringSplit(Tc *b, Tc *m, int dn) {
 Tc *p;
 Ti len;
 Tl *r;
 if (b == NULL) {
  if (!dn) ZthrowCstringNil("using split() on NIL");
  r = NULL;
 } else {
  if (m == NULL) ZthrowCstringNil("split() argument is NIL");
  len = ZstringSizePtr(b, &p);
  r = ZstringSplitLen(p, len, m);
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringSplit, writeStringSplit)
          .setDependencies([%stringSplitLen, Declaration.throwCstringNil]))

      PROC writeVarStringSplit(WriteC gen, IO.File fd)
        fd.write(''"
Tl *ZvarStringSplit(Ty *b, Tc *m, int dn) {
 Tl *r;
 if (b == NULL) {
  if (!dn) ZthrowCstringNil("using split() on NIL");
  r = NULL;
 } else {
  if (m == NULL) ZthrowCstringNil("split() argument is NIL");
  r = ZstringSplitLen(ZvarByteStringPtr(b), b->byteSize, m);
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringSplit, writeVarStringSplit)
          .setDependencies([%stringSplitLen, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writeBytesSplit(WriteC gen, IO.File fd)
        fd.write(''"
Tl *ZbyteStringSplit(Tc *b, Tc *m, int dn) {
 return ZstringSplit(b, m, dn);
}
"'')
      }
      fragments.add(NEW(Declaration.byteStringSplit, writeBytesSplit)
          .setDependencies([Declaration.stringSplit]))

      PROC writeVarByteStringSplit(WriteC gen, IO.File fd)
        fd.write(''"
Tl *ZvarByteStringSplit(Ty *b, Tc *m, int dn) {
 Tl *r;
 if (b == NULL) {
  if (!dn) ZthrowCstringNil("using split() on NIL");
  r = NULL;
 } else {
  if (m == NULL) ZthrowCstringNil("split() argument is NIL");
  r = ZstringSplitLen(ZvarByteStringPtr(b), b->byteSize, m);
 }
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varByteStringSplit, writeVarByteStringSplit)
          .setDependencies([%stringSplitLen, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writeStringSlice(WriteC gen, IO.File fd)
        fd.write(''"
Tc *ZstringSlice(Tc *sv, Ti start, Ti end, int dn) {
 Ti is;
 Ti ie;
 Tc *p;
 Ti len;
 Tc *r;
 if (sv == NULL) {
  if (dn) return NULL;
  ZthrowCstringNil("using slice() on NIL");
 }
 len = ZstringSizePtr(sv, &p);
 is = start < 0 ? ZChar2ByteIdxEnd(p, len, -start) : ZChar2ByteIdx(p, len, start);
 ie = end < 0 ? ZChar2ByteIdxEnd(p, len, -end - 1) - 1 : ZChar2ByteIdx(p, len, end + 1) - 1;
 if (is < 0)
  is = 0;
 if (ie < 0 || ie < is) r = ZnewString((Tc*)"", 0);
 else r = ZnewString(p + is,  ie - is + 1);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringSlice, writeStringSlice)
          .setDependencies([%string_h, Declaration.throwCstringNil,
                            %char2byteIdx, %char2byteIdxEnd]))

      # Note: varStringSlice depends on varByteStringSlice thus varByteStringSlice must
      # come first.
      PROC writeVarByteStringSlice(WriteC gen, IO.File fd)
        fd.write(''"
Ty *ZvarByteStringSlice(Ty *b, Ti start, Ti end, int dn) {
 Ty *newb;
 Ti is;
 Ti ie;
 if (b == NULL) {
  if (dn) return NULL;
  ZthrowCstringNil("using slice() on NIL");
 }
 is = start < 0 ? b->byteSize + start : start;
 ie = end < 0 ? b->byteSize + end : end;
 if (is < 0) is = 0;
 if (is > b->byteSize) is = b->byteSize;
 if (ie < is - 1) ie = is - 1;
 if (ie >= b->byteSize) ie = b->byteSize - 1;
 newb = Za(sizeof(Ty));
 newb->byteSize = ie - is + 1;
 newb->charSize = -1;
 if (newb->byteSize < sizeof(void*)) {
  /* put data in tiny[] */
  ZbyteStringWriteTo(b, newb->tiny, is, newb->byteSize);
  newb->tiny[newb->byteSize] = 0;
  newb->flags = ZbyteStringT_tiny;
 } else {
  /* use a Tv */
  Tv *pieceval = Za(sizeof(Tv));
  newb->data = pieceval;
  newb->flags = ZbyteStringT_pieceval;
  pieceval->data = ZvarByteStringPtr(b);
  pieceval->offset = is;
  pieceval->space = b->byteSize;
 }
 return newb;
}
"'')
      }
      fragments.add(NEW(Declaration.varByteStringSlice, writeVarByteStringSlice)
          .setDependencies([%string_h, Declaration.throwCstringNil,
                            %piecevalType, %byteStringPtr, %byteStringWriteTo]))

      PROC writeVarStringSlice(WriteC gen, IO.File fd)
        fd.write(''"
Ty *ZvarStringSlice(Ty *b, Ti start, Ti end, int dn) {
 Ti is;
 Ti ie;
 Tc *p;
 if (b == NULL) {
  if (dn) return NULL;
  ZthrowCstringNil("using slice() on NIL");
 }
 p = ZvarByteStringPtr(b);
 is = start < 0 ? ZChar2ByteIdxEnd(p, b->byteSize, -start) : ZChar2ByteIdx(p, b->byteSize, start);
 ie = end < 0 ? ZChar2ByteIdxEnd(p, b->byteSize, -end - 1) - 1 : ZChar2ByteIdx(p, b->byteSize, end + 1) - 1;
 if (ie < 0) {
  Ty *newb = Za(sizeof(Ty));
  newb->tiny[0] = 0;
  newb->flags = ZbyteStringT_tiny;
  return newb;
 }
 if (is < 0) is = 0;
 return ZvarByteStringSlice(b, is, ie, dn);
}
"'')
      }
      fragments.add(NEW(Declaration.varStringSlice, writeVarStringSlice)
          .setDependencies([%string_h, Declaration.throwCstringNil,
                            Declaration.varByteStringSlice, %byteStringPtr,
                            %char2byteIdx, %char2byteIdxEnd]))

      PROC writeBytesSlice(WriteC gen, IO.File fd)
        fd.write(''"
Tc *ZbyteStringSlice(Tc *b, Ti start, Ti end, int dn) {
 Tc *p;
 Ti is;
 Ti ie;
 Ti len;
 Tc *r;
 if (b == NULL) {
  if (dn) return NULL;
  ZthrowCstringNil("using slice() on NIL");
 }
 len = ZstringSizePtr(b, &p);
 is = start < 0 ? len + start : start;
 if (is < 0) is = 0;
 ie = end < 0 ? len + end : end;
 if (ie >= len) ie = len - 1;
 if (ie < 0 || ie < is) r = ZnewString((Tc*)"", 0);
 else r = ZnewString(p + is,  ie - is + 1);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.byteStringSlice, writeBytesSlice)
          .setDependencies([%string_h, Declaration.throwCstringNil]))

      PROC writeVarStringConcatAssign(WriteC gen, IO.File fd)
        fd.write(''"
void ZvarStringConcatAssign(Ty *b, Tc *r) {
 Tc *p;
 Ti r_len;
 Ti len;
 if (b == NULL) ZthrowCstringNil("Concatenating to NIL");
 if (r == NULL) ZthrowCstringNil("Concatenating NIL to a string");
 r_len = ZstringSizePtr(r, &p);
 len = b->byteSize + r_len;
 if (len < sizeof(void*)) {
  if ((b->flags & ZbyteStringT_mask) != ZbyteStringT_tiny) {
   ZbyteStringWriteTo(b, b->tiny, 0, b->byteSize);
   b->flags = ZbyteStringT_tiny;
  }
  memmove(b->tiny + b->byteSize, p, r_len + 1);
 } else {
  /* TODO: when b is immutable can use a Tcd */
  /* TODO: when b is Tp with space write there */
  /* put data in Tp */
  int zlen = len + 10;
  Tp *piece = Za(sizeof(Tp) + zlen);
  Tc *zp = (Tc*)piece + sizeof(Tp);
  piece->space = zlen - 1;
  ZbyteStringWriteTo(b, zp, 0, b->byteSize);
  memmove(zp + b->byteSize, p, r_len + 1);
  b->data = piece;
  b->flags = ZbyteStringT_piece;
 }
 b->byteSize = len;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringConcatAssign,
                                                   writeVarStringConcatAssign)
          .setDependencies([%string_h, %varByteStringType, %pieceType, %byteStringWriteTo,
                            Declaration.throwCstringNil]))

      PROC writeConcatVarStringBB(WriteC gen, IO.File fd)
        fd.write(''"
Ty *ZconcatVarStringBB(Ty *le, Ty *ri) {
 Ty *r;
 Ti len;
 if (le == NULL) ZthrowCstringNil("Concatenating to NIL");
 if (ri == NULL) ZthrowCstringNil("Concatenating NIL to a string");
 r = (Ty *)Za(sizeof(Ty));
 len = le->byteSize + ri->byteSize;
 if (len < sizeof(void*)) {
  r->flags = ZbyteStringT_tiny;
  ZbyteStringWriteTo(le, r->tiny, 0, le->byteSize);
  ZbyteStringWriteTo(ri, r->tiny + le->byteSize, 0, ri->byteSize);
  r->tiny[len] = 0;
 } else {
  /* TODO: when le and/or ri is immutable can use a Tcd */
  /* put data in Tp */
  int zlen = len + 10;
  Tp *piece = Za(sizeof(Tp) + zlen);
  Tc *zp = (Tc*)piece + sizeof(Tp);
  piece->space = zlen - 1;
  piece->offset = 0;
  ZbyteStringWriteTo(le, zp, 0, le->byteSize);
  ZbyteStringWriteTo(ri, zp + le->byteSize, 0, ri->byteSize);
  zp[len] = 0;
  r->data = piece;
  r->flags = ZbyteStringT_piece;
 }
 r->byteSize = len;
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.concatVarStringBB, writeConcatVarStringBB)
          .setDependencies([%string_h, %varByteStringType, %pieceType, %byteStringWriteTo,
                            Declaration.throwCstringNil]))

      PROC writeConcatVarStringBV(WriteC gen, IO.File fd)
        fd.write(''"
Ty *ZconcatVarStringBV(Ty *le, Tc *ri) {
 Ty *r;
 Tc *p;
 Ti r_len;
 Ti len;
 if (le == NULL) ZthrowCstringNil("Concatenating to NIL");
 if (ri == NULL) ZthrowCstringNil("Concatenating NIL to a string");
 r = (Ty *)Za(sizeof(Ty));
 r_len = ZstringSizePtr(ri, &p);
 len = le->byteSize + r_len;

 if (len < sizeof(void*)) {
  r->flags = ZbyteStringT_tiny;
  ZbyteStringWriteTo(le, r->tiny, 0, le->byteSize);
  memmove(r->tiny + le->byteSize, p, r_len + 1);
 } else {
  /* TODO: when le is immutable can use a Tcd */
  /* put data in Tp */
  int zlen = len + 10;
  Tp *piece = Za(sizeof(Tp) + zlen);
  Tc *zp = (Tc*)piece + sizeof(Tp);
  piece->space = zlen - 1;
  ZbyteStringWriteTo(le, zp, 0, le->byteSize);
  memmove(zp + le->byteSize, p, r_len + 1);
  r->data = piece;
  r->flags = ZbyteStringT_piece;
 }
 r->byteSize = len;
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.concatVarStringBV, writeConcatVarStringBV)
          .setDependencies([%string_h, %varByteStringType, %pieceType, %byteStringWriteTo,
                            Declaration.throwCstringNil]))

      PROC writeConcatVarStringVB(WriteC gen, IO.File fd)
        fd.write(''"
Ty *ZconcatVarStringVB(Tc *le, Ty *ri) {
 Ty *r;
 Tc *p;
 Ti l_len;
 Ti len;
 if (le == NULL) ZthrowCstringNil("Concatenating to NIL");
 if (ri == NULL) ZthrowCstringNil("Concatenating NIL to a string");
 r = (Ty *)Za(sizeof(Ty));
 l_len = ZstringSizePtr(le, &p);
 len = l_len + ri->byteSize;
 if (len < sizeof(void*)) {
  r->flags = ZbyteStringT_tiny;
  memmove(r->tiny, p, l_len);
  ZbyteStringWriteTo(ri, r->tiny + l_len, 0, ri->byteSize);
  r->tiny[len] = 0;
 } else {
  /* TODO: when le is immutable can use a Tcd */
  /* put data in Tp */
  int zlen = len + 10;
  Tp *piece = Za(sizeof(Tp) + zlen);
  Tc *zp = (Tc*)piece + sizeof(Tp);
  piece->space = zlen - 1;
  piece->offset = 0;
  memmove(zp, p, l_len);
  ZbyteStringWriteTo(ri, zp + l_len, 0, ri->byteSize);
  zp[len] = 0;
  r->data = piece;
  r->flags = ZbyteStringT_piece;
 }
 r->byteSize = len;
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.concatVarStringVB, writeConcatVarStringVB)
          .setDependencies([%string_h, %varByteStringType, %pieceType, %byteStringWriteTo,
                            Declaration.throwCstringNil]))

      PROC writeConcatVarStringVV(WriteC gen, IO.File fd)
        fd.write(''"
Ty *ZconcatVarStringVV(Tc *le, Tc *ri) {
 Ty *r;
 Tc *l_p;
 Ti l_len;
 Tc *r_p;
 Ti r_len;
 Ti len;
 if (le == NULL) ZthrowCstringNil("Concatenating to NIL");
 if (ri == NULL) ZthrowCstringNil("Concatenating NIL to a varString");
 r = (Ty *)Za(sizeof(Ty));
 l_len = ZstringSizePtr(le, &l_p);
 r_len = ZstringSizePtr(ri, &r_p);
 len = l_len + r_len;
 if (len < sizeof(void*)) {
  r->flags = ZbyteStringT_tiny;
  memmove(r->tiny, l_p, l_len);
  memmove(r->tiny + l_len, r_p, r_len + 1);
 } else {
#if 0
  /* do not create a Cord for now */
  Tcd *l_cord = ZcordFromBytesval(le);
  Tcd *r_cord = ZcordFromBytesval(ri);
  r->flags = ZbyteStringT_cord;
  r->data = l_cord;
  l_cord->next = r_cord;
#else
  int zlen = len + 10;
  Tp *piece = Za(sizeof(Tp) + zlen);
  Tc *zp = (Tc*)piece + sizeof(Tp);
  piece->space = zlen - 1;
  memmove(zp, l_p, l_len);
  memmove(zp + l_len, r_p, r_len + 1);
  r->data = piece;
  r->flags = ZbyteStringT_piece;
#endif
 }
 r->byteSize = len;
 return r;
}
"'')
# not used
#Tcd *ZcordFromBytesval(Tc *bv) {
#  Tcd *r = Za(sizeof(Tcd));
#  Tc *p;
#  r->type = ZbyteStringT_string;
#  r->byteSize = ZstringSizePtr(bv, &p);
#  r->data = p;
#  return r;
#}
      }
      fragments.add(NEW(Declaration.concatVarStringVV, writeConcatVarStringVV)
          .setDependencies([%string_h, %varByteStringType, %pieceType, %byteStringWriteTo,
                            Declaration.throwCstringNil]))

      PROC writePtrToInt(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZptrToInt(Tc *s, int t, Ti def) {
 Ti r;
 char *p = (char*)s;
 if ((*p < '0' || *p > '9') && *p != '-') {
  if (t == 1) ZthrowCstringBadValue("toInt(): argument does not start with a digit or -");
  return def;
 }
 sscanf(p, ZINT_FORMAT, &r);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.ptrToInt, writePtrToInt)
          .setDependencies([Declaration.throwCstringBadValue]))

      PROC writePtrQuotedToInt(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZptrQuotedToInt(Tc *s, int t, Ti def) {
 Ti r = 0;
 Ti m = 1;
 Tc *p = s;
 if (*p == '-') { ++p; m = -1; }
 if (*p < '0' || *p > '9') {
  if (t == 1) ZthrowCstringBadValue("quotedToInt(): argument does not start with a digit or -");
  return def;
 }
 for ( ; *p != 0; ++p) {
  if (*p >= '0' && *p <= '9')
   r = r * 10 + (*p - '0');
  else if (*p != '\'' && *p != '_')
   break;
 }
 return r * m;
}
"'')
      }
      fragments.add(NEW(%ptrQuotedToInt, writePtrQuotedToInt))

      PROC writePtrBinToInt(WriteC gen, IO.File fd)
        # TODO: throw exception if illegal char found.
        fd.write(''"
Ti ZptrBinToInt(Tc *s, int t, Ti def) {
 Ti r = 0;
 if (*s < '0' || *s > '1') {
  if (t == 1) ZthrowCstringBadValue("binToInt(): argument does not start with 0 or 1");
  return def;
 }
 if (s != NULL) {
  Tc *p;
  for (p = s; *p != 0; ++p) {
   if (*p == '0')
    r <<= 1;
   else if (*p == '1')
    r = (r << 1) + 1;
   else
    break;
  }
 }
 return r;
}
"'')
      }
      fragments.add(NEW(%ptrBinToInt, writePtrBinToInt))

      PROC writePtrQuotedBinToInt(WriteC gen, IO.File fd)
        # TODO: throw exception if illegal char found.
        fd.write(''"
Ti ZptrQuotedBinToInt(Tc *s, int t, Ti def) {
 Ti r = 0;
 Tc *p;
 if (*s < '0' || *s > '1') {
  if (t == 1) ZthrowCstringBadValue("quotedBinToInt(): argument does not start with 0 or 1");
  return def;
 }
 for (p = s; *p != 0; ++p) {
  if (*p == '0')
   r <<= 1;
  else if (*p == '1')
   r = (r << 1) + 1;
  else if (*p != '\'' && *p != '_')
   break;
 }
 return r;
}
"'')
      }
      fragments.add(NEW(%ptrQuotedBinToInt, writePtrQuotedBinToInt))

      PROC writePtrHexToInt(WriteC gen, IO.File fd)
        # TODO: should argument to sscanf() be unsigned?
        fd.write(''"
Ti ZptrHexToInt(Tc *s, int t, Ti def) {
 Ti r;
 char *p = (char *)s;
 if (p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) p += 2;
 if ((*p < '0' || *p > '9') && (*p < 'a' || *p > 'f') && (*p < 'A' || *p > 'F')) {
  if (t == 1) ZthrowCstringBadValue("hexToInt(): argument does not start with a hex digit");
  return def;
 }
 sscanf(p, ZINT_XFORMAT, &r);
 return r;
}
"'')
      }
      fragments.add(NEW(%ptrHexToInt, writePtrHexToInt))

      PROC writePtrQuotedHexToInt(WriteC gen, IO.File fd)
        # TODO: throw exception if illegal char found.
        fd.write(''"
Ti ZptrQuotedHexToInt(Tc *s, int t, Ti def) {
 Ti r = 0;
 Tc *p = s;
 if (p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) p += 2;
 if ((*p < '0' || *p > '9') && (*p < 'a' || *p > 'f') && (*p < 'A' || *p > 'F')) {
  if (t == 1) ZthrowCstringBadValue("hexToInt(): argument does not start with a hex digit");
  return def;
 }
 for (; *p != 0; ++p) {
  if (*p >= '0' && *p <= '9')
   r = r * 16 + (*p - '0');
  else if (*p >= 'a' && *p <= 'f')
   r = r * 16 + (*p - 'a' + 10);
  else if (*p >= 'A' && *p <= 'F')
   r = r * 16 + (*p - 'A' + 10);
  else if (*p != '\'' && *p != '_')
   break;
 }
 return r;
}
"'')
    }
      fragments.add(NEW(%ptrQuotedHexToInt, writePtrQuotedHexToInt))

      PROC writeIntCompare(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZintCompare(Ti a, Ti b) {
 return a == b ? 0 : a < b ? -1 : 1;
}
"'')
      }
      fragments.add(NEW(%intCompare, writeIntCompare))

      PROC writeNatCompare(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZnatCompare(Tu a, Tu b) {
 return a == b ? 0 : a < b ? -1 : 1;
}
"'')
      }
      fragments.add(NEW(%natCompare, writeNatCompare))

      PROC writeFloatCompare(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZfloatCompare(Tf a, Tf b) {
 return a == b ? 0 : a < b ? -1 : 1;
}
"'')
      }
      fragments.add(NEW(%floatCompare, writeFloatCompare))

      PROC writeStringToInt(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringToInt(Tc *p, int t, Ti def) {
 Tc *s;
 Ti r;
 if (p == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using toInt() on NIL");
 }
 (void)ZstringSizePtr(p, &s);
 r = ZptrToInt(s, t, def);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringToInt, writeStringToInt)
          .setDependencies([Declaration.ptrToInt,
                            Declaration.throwCstringNil]))

      PROC writeStringQuotedToInt(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringQuotedToInt(Tc *p, int t, Ti def) {
 Tc *s;
 Ti r;
 if (p == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using quotedToInt() on NIL");
 }
 (void)ZstringSizePtr(p, &s);
 r = ZptrQuotedToInt(s, t, def);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringQuotedToInt, writeStringQuotedToInt)
          .setDependencies([%ptrQuotedToInt, Declaration.throwCstringNil]))

      PROC writeStringBinToInt(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringBinToInt(Tc *p, int t, Ti def) {
 Tc *s;
 Ti r;
 if (p == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using binToInt() on NIL");
 }
 (void)ZstringSizePtr(p, &s);
 r = ZptrBinToInt(s, t, def);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringBinToInt, writeStringBinToInt)
          .setDependencies([%ptrBinToInt, Declaration.throwCstringNil]))

      PROC writeStringQuotedBinToInt(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringQuotedBinToInt(Tc *p, int t, Ti def) {
 Tc *s;
 Ti r;
 if (p == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using quotedBinToInt() on NIL");
 }
 (void)ZstringSizePtr(p, &s);
 r = ZptrQuotedBinToInt(s, t, def);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringQuotedBinToInt,
                                                    writeStringQuotedBinToInt)
          .setDependencies([%ptrQuotedBinToInt,
                            Declaration.throwCstringNil]))

      PROC writeStringHexToInt(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringHexToInt(Tc *p, int t, Ti def) {
 Tc *s;
 Ti r;
 if (p == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using hexToInt() on NIL");
 }
 (void)ZstringSizePtr(p, &s);
 r = ZptrHexToInt(s, t, def);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringHexToInt, writeStringHexToInt)
          .setDependencies([%ptrHexToInt,
                            Declaration.throwCstringNil]))

      PROC writeStringQuotedHexToInt(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZstringQuotedHexToInt(Tc *p, int t, Ti def) {
 Tc *s;
 Ti r;
 if (p == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using quotedhexToInt() on NIL");
 }
 (void)ZstringSizePtr(p, &s);
 r = ZptrQuotedHexToInt(s, t, def);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.stringQuotedHexToInt,
                                                    writeStringQuotedHexToInt)
          .setDependencies([%ptrQuotedHexToInt,
                            Declaration.throwCstringNil]))

      PROC writeVarStringToInt(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarStringToInt(Ty *b, int t, Ti def) {
 Tc *s;
 Ti r;
 if (b == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using toInt() on NIL");
 }
 s = ZvarByteStringPtr(b);
 r = ZptrToInt(s, t, def);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringToInt, writeVarStringToInt)
          .setDependencies([Declaration.ptrToInt, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writeVarStringQuotedToInt(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarStringQuotedToInt(Ty *b, int t, Ti def) {
 Tc *s;
 Ti r;
 if (b == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using quotedToInt() on NIL");
 }
 s = ZvarByteStringPtr(b);
 r = ZptrQuotedToInt(s, t, def);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringQuotedToInt,
                                                    writeVarStringQuotedToInt)
          .setDependencies([%ptrQuotedToInt, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writeVarStringBinToInt(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarStringBinToInt(Ty *b, int t, Ti def) {
 Tc *s;
 Ti r;
 if (b == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using binToInt() on NIL");
 }
 s = ZvarByteStringPtr(b);
 r = ZptrBinToInt(s, t, def);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringBinToInt, writeVarStringBinToInt)
          .setDependencies([%ptrBinToInt, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writeVarStringQuotedBinToInt(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarStringQuotedBinToInt(Ty *b, int t, Ti def) {
 Tc *s;
 Ti r;
 if (b == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using quotedBinToInt() on NIL");
 }
 s = ZvarByteStringPtr(b);
 r = ZptrQuotedBinToInt(s, t, def);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringQuotedBinToInt,
                                                 writeVarStringQuotedBinToInt)
          .setDependencies([%ptrQuotedBinToInt, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writeVarStringHexToInt(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarStringHexToInt(Ty *b, int t, Ti def) {
 Tc *s;
 Ti r;
 if (b == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using hexToInt() on NIL");
 }
 s = ZvarByteStringPtr(b);
 r = ZptrHexToInt(s, t, def);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringHexToInt, writeVarStringHexToInt)
          .setDependencies([%ptrHexToInt, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writeVarStringQuotedHexToInt(WriteC gen, IO.File fd)
        fd.write(''"
Ti ZvarStringQuotedHexToInt(Ty *b, int t, Ti def) {
 Tc *s;
 Ti r;
 if (b == NULL) {
  if (t & 2) return def;
  ZthrowCstringNil("using quotedhexToInt() on NIL");
 }
 s = ZvarByteStringPtr(b);
 r = ZptrQuotedHexToInt(s, t, def);
 return r;
}
"'')
      }
      fragments.add(NEW(Declaration.varStringQuotedHexToInt,
                                                 writeVarStringQuotedHexToInt)
          .setDependencies([%ptrQuotedHexToInt, %byteStringPtr,
                            Declaration.throwCstringNil]))

      PROC writeItemToString(WriteC gen, IO.File fd)
        # This code uses TYPE_NUMBERS, keep in sync!
        fd.write(''"
void ZitemToString(Tt *type, int useq, Tz val, Tg *ga);

void ZobjectToString(Tto *typearg, void *ptrarg, Tg *ga) {
 Tto *type = typearg;
 void *ptr = ptrarg;
 To *to;
 int cnt;
 if (type == NULL && ptr != NULL) {
  type = ((Tto*)ZiobjType(ptr));
  ptr = ((Tr*)ptr)->ptr;
 }
 if (ptr == NULL "'')
        IF gen.manageMemory()
          fd.write("|| ((Zoh*)ptr)->np == NULL ")
        }
        fd.write(''") {
  ga_append(ga, "{NIL}");
 } else {
  int i;
  int first = 1;
  if (type->ToString != NULL) {
   Tc *p = ((Tc * (*)(void *))type->ToString)(ptr);
   ga_append(ga, ZgetCstring(p));
   return;
  }
  to = type->to;
  ga_append(ga, "{");
  cnt = to[0].off;
  for (i = 1; i <= cnt; ++i) {
   Tz val;
   void *vptr = ptr + to[i].off;

   if (!first) ga_append(ga, ", ");
   first = 0;
   ga_append(ga, type->names[i - 1]);
   ga_append(ga, ": ");
   switch (to[i].type->nr) {
    case 0:
    case 24:
    case 25:
     val = (Tz)*((Ti*)vptr); break;
    case 10:
     val = (Tz)(Ti)*((Tu*)vptr); break;
    case 1:
     val = (Tz)(Ti)*((char*)vptr); break;
    case 11:
     val = (Tz)(Ti)*((Tc*)vptr); break;
    case 2:
     val = (Tz)(Ti)*((Ti16*)vptr); break;
    case 12:
     val = (Tz)(Ti)*((Tu16*)vptr); break;
    case 3:
     val = (Tz)(Ti)*((Ti32*)vptr); break;
    case 13:
     val = (Tz)(Ti)*((Tu32*)vptr); break;
    case 21:
    case 22:
    case 23:
     val = (Tz)(Ti)*((int*)vptr); break;
    case 80:
    case 82:
    case 83:
     val = (Tz)*((Tf*)vptr); break;
    case 81:
     val = (Tz)(Tf)*((Tf32*)vptr); break;
    default:
     val = (Tz)*(((void**)vptr)); break;
   }
   ZitemToString(to[i].type, 1, val, ga);
  }
  ga_append(ga, "}");
 }
}

Tc *ZobjectToStringval(Tto *type, void *ptr) {
 Tg ga;"'')
        IF !gen.manageMemory()
          fd.write(''"
 Tc *r;"'')
        }
        fd.write(''"
 ga.data = NULL;
 ga.used = 0;
 ++"'' .. gen.getEnvCode() .. ''"->tosNr;
 ZobjectToString(type, ptr, &ga);"'')
        IF gen.manageMemory()
          fd.write(''"
 return ZnewString(ga.data, ga.used);"'')
        ELSE
          fd.write(''"
 r = ZnewString(ga.data, ga.used);
 Zfree(ga.data - ZOH_OFF);
 return r;"'')
        }
        fd.write(''"
}"'')
        fd.write(''"
Tc *ZiobjectToStringval(Tr tr) {
 Tg ga;"'')
        IF !gen.manageMemory()
          fd.write(''"
 Tc *r;"'')
        }
        fd.write(''"
 ga.data = NULL;
 ga.used = 0;
 ++"'' .. gen.getEnvCode() .. ''"->tosNr;
 ZobjectToString((Tto*)tr.table[0], tr.ptr, &ga);"'')
        IF gen.manageMemory()
          fd.write(''"
 return ZnewString(ga.data, ga.used);"'')
        ELSE
          fd.write(''"
 r = ZnewString(ga.data, ga.used);
 Zfree(ga.data - ZOH_OFF);
 return r;"'')
        }
        fd.write(''"
}"'')
      fd.write(''"

void ZitemToString(Tt *type, int useq, Tz val, Tg *ga) {
 char buf[30];
 if (type->nr < 100) {
  switch (type->nr) {
   case 0:
   case 1:
   case 2:
   case 3:
   case 25:
    sprintf(buf, ZINT_FORMAT, val.ival);
    ga_append(ga, buf);
    break;
   case 10:
    sprintf(buf, ZNAT_FORMAT, (Tu)val.ival);
    ga_append(ga, buf);
    break;
   case 11:
    sprintf(buf, ZNAT_FORMAT, (Tu)(Tc)val.ival);
    ga_append(ga, buf);
    break;
   case 12:
    sprintf(buf, ZNAT_FORMAT, (Tu)(Tu16)val.ival);
    ga_append(ga, buf);
    break;
   case 13:
    sprintf(buf, ZNAT_FORMAT, (Tu)(Tu32)val.ival);
    ga_append(ga, buf);
    break;
   case 21: ga_append(ga, val.ival ? "TRUE" : "FALSE"); break;
   case 22: ga_append(ga, val.ival ? "OK" : "FAIL"); break;
   case 23:
    if (type->ToString == NULL) {
     ga_append(ga, "-enum");
     if (type->name) {
      ga_append(ga, " ");
      ga_append(ga, ZgetCstring(type->name));
     }
     ga_append(ga, "-");
    } else {
     ga_append(ga, ((char * (*)(Te))type->ToString)(val.ival));
    }
    break;
   case 80:
   case 81:
   case 82:
   case 83:
    sprintf(buf, ZFLOAT_FORMAT, val.fval);"'')
        IF Config.isMingw || Config.portable
          fd.write(''"
#ifdef __MINGW32__
    ZcorrFloatStr(buf, NULL);
#endif"'')
        }
        fd.write(''"
    ga_append(ga, buf);
    break;
  }
 } else {
  void *ptr = val.ptr;
  if (ptr == NULL) ga_append(ga, "NIL");
  else switch (type->nr) {
   case 200:
   case 201: {
     Tc *p;
     (void)ZstringSizePtr(ptr, &p);
     if (useq) ga_append(ga, "\"");
     ga_append(ga, (char *)p);
     if (useq) ga_append(ga, "\"");
    }
    break;"'')
        IF gen.isDeclUsed(Declaration.array)
          fd.write(''"
   case 300:
    ZArrayToStringGa((Ta *)ptr, 1, ga);
    break;"'')
        }
        IF gen.isDeclUsed(Declaration.list)
          fd.write(''"
   case 301:
    ZListToStringGa((Tl *)ptr, 1, ga);
    break;"'')
        }
        IF gen.isDeclUsed(Declaration.dict)
          fd.write(''"
   case 302:
    ZDictToStringGa((Td *)ptr, 1, 1, ga);
    break;"'')
        }
        fd.write(''"
   case 310:
    ga_append(ga, "-varString-");
    break;
   case 311:
    ga_append(ga, "-varByteString-");
    break;
   case 320:
    if (type->ToString == NULL) ga_append(ga, "-tuple-");
    else {
     Tc *p = ((Tc * (*)(void *))type->ToString)(ptr);
     ga_append(ga, ZgetCstring(p));
    }
    break;
   case 330:
    ga_append(ga, "-proc/func-");
    break;"'')

        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
   case 360:
    ZitemToString(((Tx*)ptr)->type, useq, ((Tx*)ptr)->u, ga);
    break;"'')
        }
        fd.write(''"
   case 390:
    ZobjectToString(((Tto*)type), ptr, ga);
    break;
   case 391:
    ZobjectToString((Tto*)((Tr*)ptr)->table[0], ((Tr*)ptr)->ptr, ga);
    break;
  }
 }
}
"'')
      }
      fragments.add(NEW(Declaration.itemToString, writeItemToString)
          .setDependencies([%int2string, %corrFloatStr, %getCstring]))

      PROC writeDynToString(WriteC gen, IO.File fd)
        fd.write(''"
Tc *ZdynToString(Tx arg) {
 Tg ga;"'')
        IF !gen.manageMemory()
          fd.write(''"
 Tc *r;"'')
        }
        fd.write(''"
 ga.data = NULL;
 ga.used = 0;
 ++"'' .. gen.getEnvCode() .. ''"->tosNr;
 ZitemToString(arg.type, 0, arg.u, &ga);"'')
        IF gen.manageMemory()
          fd.write(''"
 return ZnewString(ga.data, ga.used);"'')
        ELSE
          fd.write(''"
 r = ZnewString(ga.data, ga.used);
 Zfree(ga.data - ZOH_OFF);
 return r;"'')
        }
        fd.write(''"
}
"'')
      }
      fragments.add(NEW(%dynToString, writeDynToString)
          .setDependencies([%garray,
                            Declaration.itemToString]))

      PROC writeDynSize(WriteC gen, IO.File fd)
        # This code uses TYPE_NUMBERS, keep in sync!
        fd.write(''"
Ti ZdynSize(Tx arg) {
 Tc *p;
 Ti len;
 if (arg.type->nr >= 200 && arg.u.ptr == NULL) return 0;
 switch (arg.type->nr) {
  case 0:
  case 10: return 8;
  case 1:
  case 11: return 1;
  case 2:
  case 12: return 2;
  case 3:
  case 13: return 4;
  case 21:
  case 22: return 1;
  case 23: return 4;
  case 25: return 8;
  case 80:
  case 82:
  case 83: return 8;
  case 81: return 4;

  case 101: return sizeof(Tt);

  case 200:
   len = ZstringSizePtr(arg.u.ptr, &p);
   return Zutf8size(p, len);
  case 201: return ZstringSizePtr(arg.u.ptr, &p);"'')
        IF gen.isDeclUsed(Declaration.array)
          fd.write(''"
  case 300: return ((Ta*)arg.u.ptr)->size[0];"'')
        }
        IF gen.isDeclUsed(Declaration.list)
          fd.write(''"
  case 301: return ((Tl*)arg.u.ptr)->itemCount;"'')
        }
        IF gen.isDeclUsed(Declaration.dict)
          fd.write(''"
  case 302: return ((Td*)arg.u.ptr)->used;"'')
        }
        fd.write(''"
  case 310: return ZvarStringSize(arg.u.ptr);
  case 322: return ((Ty*)arg.u.ptr)->byteSize;

  case 360: return ZdynSize(*(Tx*)arg.u.ptr);

  case 390:
  case 391:
    if (((Tto*)arg.type)->Size != NULL)
     return ((Ti (*)(void *))((Tto*)arg.type)->Size)(arg.u.ptr);
    ZthrowDyn(Zstr("object does not support Size()"));
 }
 return 0;
}
"'')
      }
      fragments.add(NEW(Declaration.dynSize, writeDynSize)
          .setDependencies([Declaration.varStringSize,
                            Declaration.throwDyn]))

      PROC writeItemEqual(WriteC gen, IO.File fd)
        # This code uses TYPE_NUMBERS, keep in sync!
        fd.write(''"
int ZitemEqual(Tt *aType, Tz aVal, Tt *bType, Tz bVal) {
 if (aType->nr == bType->nr) {
  switch (aType->nr) {
   case 0:
   case 1:
   case 2:
   case 3:
   case 10:
   case 11:
   case 12:
   case 13:
   case 22:
    return aVal.ival == bVal.ival;

   case 21:
    return !aVal.ival == !bVal.ival;

   case 23:
   case 25:
     return aVal.ival == bVal.ival && aType == bType;

   case 24:
   case 101:
     return aType == bType;

   case 80:
   case 81:
   case 82:
   case 83:
    return aVal.fval == bVal.fval;

   case 200:
   case 201:
    return ZstringCmp(aVal.ptr, bVal.ptr) == 0;"'')

        IF gen.isDeclUsed(Declaration.array)
          fd.write(''"
   case 300: {
    Ta *ah = aVal.ptr;
    Ta *bh = bVal.ptr;
    int i;
    if (ah == NULL || bh == NULL) return 0;
    if (ah->dim != bh->dim) return 0;
    if (ah->size[0] != bh->size[0]) return 0;
    for (i = 0; i < ah->size[0]; ++i)
     if  (ZitemEqual(ah->itemType, ZArrayGetTz(ah, i), bh->itemType, ZArrayGetTz(bh, i)) == 0) return 0;
   }"'')
        }
        IF gen.isDeclUsed(Declaration.list)
          fd.write(''"
   case 301: {
    Tl *ah = aVal.ptr;
    Tl *bh = bVal.ptr;
    int i;
    if (ah == NULL || bh == NULL) return ah == bh;
    if (ah->itemCount != bh->itemCount) return 0;
    for (i = 0; i < ah->itemCount; i++)
     if (!ZitemEqual(ah->itemType, ZListGetTz(ah, i), bh->itemType, ZListGetTz(bh, i))) return 0;
   }"'')
        }
        IF gen.isDeclUsed(Declaration.dict)
          fd.write(''"
   case 302: {
    Td *ah = aVal.ptr;
    Td *bh = bVal.ptr;
    if (ah == NULL || bh == NULL) return ah == bh;
    return ZDictEqual(ah, bh);
   }
"'')
        }
        fd.write(''"
   case 310:
   case 311:
    ZthrowInternal(Zstr("Sorry, varString/varByteString compare not implemented yet"));
    return 0;

   case 320:
    ZthrowInternal(Zstr("Sorry, tuple compare not implemented yet"));
    return 0;

   case 330:
    ZthrowInternal(Zstr("Sorry, proc/func compare not implemented yet"));
    return 0;"'')

        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
   case 360: {
    Tx *a = aVal.ptr;
    Tx *b = bVal.ptr;
    return ZitemEqual(a->type, a->u, b->type, b->u);
   }"'')
        }
        fd.write(''"
   case 390:
    if (aType != bType) return 0;
    if (((Tto*)aType)->Equal != NULL)
     return ((int (*)(void *, void *))((Tto*)aType)->Equal)(aVal.ptr, bVal.ptr);
    if (((Tto*)aType)->Compare != NULL)
     return ((int (*)(void *, void *))((Tto*)aType)->Compare)(aVal.ptr, bVal.ptr) == 0;
    ZthrowDyn(Zstr("object does not support Equal() nor Compare()"));

   case 391:
    /* TODO */
    ZthrowDyn(Zstr("iobjec equal not supported yet"));
    return aType == bType;
  }
 }"'')
        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
 if (bType->nr == 360) {
  Tx *b = bVal.ptr;
  return ZitemEqual(aType, aVal, b->type, b->u);
 }"'')
        }
        fd.write(''"
 switch (aType->nr) {
  case 0:
  case 1:
  case 2:
  case 3:
  case 10:
  case 11:
  case 12:
  case 13:
   switch (bType->nr) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 10:
    case 11:
    case 12:
    case 13:
     return aVal.ival == bVal.ival;
    case 80:
    case 81:
    case 82:
    case 83:
     return aVal.ival == bVal.fval;
   }
   return 0;
  case 80:
  case 81:
  case 82:
  case 83:
   switch (bType->nr) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 10:
    case 11:
    case 12:
    case 13:
     return aVal.fval == bVal.ival;
    case 80:
    case 81:
    case 82:
    case 83:
     return aVal.fval == bVal.fval;
   }
   return 0;
  case 320:
   ZthrowInternal(Zstr("Sorry, tuple compare not implemented yet"));
   return 0;"'')
        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
  case 360: {
   Tx *a = aVal.ptr;
   return ZitemEqual(a->type, a->u, bType, bVal);
  }"'')
        }
        fd.write(''"
 }
 return 0;
}"'')
      }
      fragments.add(NEW(Declaration.itemEqual, writeItemEqual)
          .setDependencies([Declaration.throwInternal,
                            Declaration.throwDyn]))

      PROC writeDynEqual(WriteC gen, IO.File fd)
        fd.write(''"
int ZdynEqual(Tx a, Tx b) {
 return ZitemEqual(a.type, a.u, b.type, b.u);
}
int ZdynEqualOne(Tx a, Tz v, Tt *type) {
 return ZitemEqual(a.type, a.u, type, v);
}"'')
      }
      fragments.add(NEW(Declaration.dynEqual, writeDynEqual)
          .setDependencies([Declaration.throwInternal,
                            Declaration.itemEqual,
                            Declaration.throwDyn]))

      PROC writeItemCompare(WriteC gen, IO.File fd)
        fd.write(''"
int ZitemCompare(Tt *aType, Tz aVal, Tt *bType, Tz bVal) {
 if (aType->nr == bType->nr) {
  switch (aType->nr) {
   case 0:
   case 1:
   case 2:
   case 3:
   case 10:
   case 11:
   case 12:
   case 13:
   case 22:
    return aVal.ival == bVal.ival ? 0 : aVal.ival > bVal.ival ? 1 : -1;

   case 21:
    return !aVal.ival == !bVal.ival ? 0 : aVal.ival > bVal.ival ? 1 : -1;

   case 23:
   case 25:
     return aVal.ival == bVal.ival && aType == bType ? 0 : 1;

   case 24:
   case 101:
     return aType == bType ? 0 : 1;

   case 80:
   case 81:
   case 82:
   case 83:
    return aVal.fval == bVal.fval ? 0 : aVal.fval > bVal.fval ? 1 : -1;

   case 200:
   case 201:
    return ZstringCmp(aVal.ptr, bVal.ptr);"'')

        IF gen.isDeclUsed(Declaration.array)
          fd.write(''"
   case 300: {
    Ta *ah = aVal.ptr;
    Ta *bh = bVal.ptr;
    int i;
    if (ah == NULL || bh == NULL) return 0;
    if (ah->dim != bh->dim) return 0;
    for (i = 0; i < ah->size[0] && i < bh->size[0]; ++i) {
     int v = ZitemCompare(ah->itemType, ZArrayGetTz(ah, i), bh->itemType, ZArrayGetTz(bh, i));
     if (v != 0) return v;
    }
    if (ah->size[0] == bh->size[0]) return 0;
    return ah->size[0] > bh->size[0] ? 1 : -1;
   }"'')
        }
        IF gen.isDeclUsed(Declaration.list)
          fd.write(''"
   case 301: {
    Tl *ah = aVal.ptr;
    Tl *bh = bVal.ptr;
    int i;
    if (ah == NULL || bh == NULL) return ah == bh;
    for (i = 0; i < ah->itemCount; i++) {
     int v = ZitemEqual(ah->itemType, ZListGetTz(ah, i), bh->itemType, ZListGetTz(bh, i));
     if (v != 0) return v;
    }
    if (ah->itemCount == bh->itemCount) return 0;
    return ah->itemCount > bh->itemCount ? 1 : -1;
   }"'')
        }
        IF gen.isDeclUsed(Declaration.dict)
          fd.write(''"
   case 302: {
    Td *ah = aVal.ptr;
    Td *bh = bVal.ptr;
    if (ah == NULL || bh == NULL) return ah == bh;
    return ZDictCompare(ah, bh);
   }
"'')
        }
        fd.write(''"
   case 310:
   case 311:
    ZthrowInternal(Zstr("Sorry, varString/varByteString compare not implemented yet"));
    return 0;

   case 320:
    ZthrowInternal(Zstr("Sorry, tuple compare not implemented yet"));
    return 0;

   case 330:
    ZthrowInternal(Zstr("Sorry, proc/func compare not implemented yet"));
    return 0;"'')

        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
   case 360: {
    Tx *a = aVal.ptr;
    Tx *b = bVal.ptr;
    return ZitemCompare(a->type, a->u, b->type, b->u);
   }"'')
        }
        fd.write(''"
   case 390:
    if (aType != bType) return 0;
    if (((Tto*)aType)->Compare != NULL)
     return ((int (*)(void *, void *))((Tto*)aType)->Compare)(aVal.ptr, bVal.ptr);
    ZthrowDyn(Zstr("object does not support Compare()"));

   case 391:
    /* TODO */
    ZthrowDyn(Zstr("iobjec equal not supported yet"));
    return aType != bType;
  }
 }"'')
        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
 if (bType->nr == 360) {
  Tx *b = bVal.ptr;
  return ZitemCompare(aType, aVal, b->type, b->u);
 }"'')
        }
        fd.write(''"
 switch (aType->nr) {
  case 0:
  case 1:
  case 2:
  case 3:
  case 10:
  case 11:
  case 12:
  case 13:
   switch (bType->nr) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 10:
    case 11:
    case 12:
    case 13:
     return aVal.ival == bVal.ival ? 0 : aVal.ival > bVal.ival ? 1 : -1;
   }
   return 0;
  case 80:
  case 81:
  case 82:
  case 83:
   switch (bType->nr) {
    case 80:
    case 81:
    case 82:
    case 83:
     return aVal.fval == bVal.fval ? 0 : aVal.fval == bVal.fval ? 1 : -1;
   }
   return 0;
  case 320:
   ZthrowInternal(Zstr("Sorry, tuple compare not implemented yet"));
   return 0;"'')
        IF gen.isDeclUsed(Type.aDyn)
          fd.write(''"
  case 360: {
   Tx *a = aVal.ptr;
   return ZitemCompare(a->type, a->u, bType, bVal);
  }"'')
        }
        fd.write(''"
 }
 return 0;
}"'')
      }
      fragments.add(NEW(Declaration.itemCompare, writeItemCompare)
          .setDependencies([Declaration.throwInternal,
                            Declaration.throwDyn]))

      PROC writeDynCompare(WriteC gen, IO.File fd)
        fd.write(''"
int ZdynCompare(Tx a, Tx b) {
 return ZitemCompare(a.type, a.u, b.type, b.u);
}
int ZdynCompareOne(Tx a, Tz v, Tt *type) {
 return ZitemCompare(a.type, a.u, type, v);
}"'')
      }
      fragments.add(NEW(Declaration.dynCompare, writeDynCompare)
          .setDependencies([Declaration.throwInternal,
                            Declaration.itemCompare,
                            Declaration.throwDyn]))

      PROC writeTypeCompare(WriteC gen, IO.File fd)
        fd.write(''"
int ZtypeCompare(Tt *a, Tt *b) {
 return a == b ? 0 : (Tip)a > (Tip)b ? 1 : -1;
}"'')
      }
      fragments.add(NEW(%typeCompare, writeTypeCompare))

      PROC writeCopyItems(WriteC gen, IO.File fd)
        # Copy |len| items from one list or array to another list or array.
        # Allows for assigning different item sizes, e.g. int8 to int.
        # TODO: conversion between objects and iobjects of differe types.
        # Return non-zero for success, zero if copy is not possible.
        fd.write(''"
int ZcopyItems(Tt *toType, int toSize, void *toPtr, Ti toOff, Tt *fromType, int fromSize, void *fromPtr, Ti fromOff, Ti len) {
 Ti i;
 if (toType == fromType || (toType->nr >= 100 && fromType->nr >= 100)) {
  memmove((char*)toPtr + toOff * toSize, (char*)fromPtr + fromOff * fromSize, len * toSize);
  return 1;
 }
 if (fromType->nr >= 100 || toType->nr >= 100) return 0;
 for (i = 0; i < len; ++i) {
  Ti iv;
  Tf fv;
  switch (fromType->nr) {
   case 0:
   case 24:
   case 25:
    iv = ((Ti*)fromPtr)[fromOff + i]; fv = iv; break;
   case 1:
    iv = ((char*)fromPtr)[fromOff + i]; fv = iv; break;
   case 2:
    iv = ((Ti16*)fromPtr)[fromOff + i]; fv = iv; break;
   case 3:
    iv = ((Ti32*)fromPtr)[fromOff + i]; fv = iv; break;
   case 10:
    iv = ((Tu*)fromPtr)[fromOff + i]; fv = iv; break;
   case 11:
    iv = ((Tc*)fromPtr)[fromOff + i]; fv = iv; break;
   case 12:
    iv = ((Tu16*)fromPtr)[fromOff + i]; fv = iv; break;
   case 13:
    iv = ((Tu32*)fromPtr)[fromOff + i]; fv = iv; break;
   case 21:
   case 22:
   case 23:
    iv = ((int*)fromPtr)[fromOff + i]; fv = iv; break;
   case 80:
   case 82:
   case 83:
    fv = ((Tf*)fromPtr)[fromOff + i]; iv = fv; break;
   case 81:
    fv = ((Tf32*)fromPtr)[fromOff + i]; iv = fv; break;
  }
  switch (toType->nr) {
   case 0:
   case 10:
   case 24:
   case 25:
    ((Ti*)toPtr)[toOff + i] = iv; break;
   case 1:
   case 11:
    ((char*)toPtr)[toOff + i] = iv; break;
   case 2:
   case 12:
    ((Ti16*)toPtr)[toOff + i] = iv; break;
   case 3:
   case 13:
    ((Ti32*)toPtr)[toOff + i] = iv; break;
   case 21:
   case 22:
   case 23:
    ((int*)toPtr)[toOff + i] = iv; break;
   case 80:
   case 82:
   case 83:
    ((Tf*)toPtr)[toOff + i] = fv; break;
   case 81:
    ((Tf32*)toPtr)[toOff + i] = fv; break;
  }
 }
 return 1;
}"'')
      }
      fragments.add(NEW(%copyItems, writeCopyItems))

      PROC writeDeferFunctions(WriteC gen, IO.File fd)
        # Catch exceptions thrown by the callback, report them and continue.
        string ewrite = DeclStore.getPName("MEModule", "FwriteToStderr")
        fd.write(''"
void ZdeferAdd(Tl *l, Tcb *cb) {
 if ("'')
        IF gen.hasNpField()
          fd.write("l->np")
        ELSE
          fd.write("l->itemType")
        }
        fd.write(''" == NULL) ZListInit(l, (Tt*)&cb__T);
 ZLap(l, (Tz)(void*)cb);
}
void ZdeferCall(Tl *l) {
 if ("'')
        IF gen.hasNpField()
          fd.write("l->np")
        ELSE
          fd.write("l->itemType")
        }
        fd.write(''" != NULL) {
  Tn *e = "'' .. gen.getEnvCode() .. ''";
  int i;
  while (l->itemCount > 0) {
   int try_index = e->tryCtxUsed;
   Zsf *tf = "'' .. gen.topFrameName() .. ''";
   ZtryDeeper(e, "'' .. gen.topFrameName() .. ''");
   if (setjmp(e->tryCtx[try_index].jmpBuf) == 0) {
    while (l->itemCount > 0) {
     Tcb *item = l->items[l->empty + l->itemCount - 1];
     ZListClearItem(l, -1);
     ((void (*)(Tcb *))item->cfunc)(item);
    }
   } else {
    "'' .. gen.topFrameName() .. ''" = tf;
    "'' .. ewrite .. ''"(e->thrown[--e->thrownUsed]);
   }
   e->tryCtxUsed = try_index;
  }
 }
}"'')
      }
      fragments.add(NEW(Declaration.defer, writeDeferFunctions)
          .setDependencies([WriteListC.listInit,
                            WriteListC.listAdd,
                            WriteListC.listClearItem,
                            Declaration.list])
          .setDecl("void ZdeferCall(Tl *l);"))


    }  # end of initFragments()

    string cThisName = "t"
    string cReturnName = "r"

    list<proc<WriteC, Output>> mainEarlyinitWriters = NEW()
    list<proc<WriteC, Output>> mainInitWriters = NEW()
    list<proc<WriteC, IO.File>> declWriters = NEW()
    list<proc<WriteC, IO.File>> bodyWriters = NEW()

    FUNC genExpr(Zui.Expression expr, SContext ctx) Type
      RETURN Generate.genExpr(expr, ctx)
    }
    FUNC genExpr(Zui.Expression expr, SContext ctx, Type destType) Type
      RETURN Generate.genExpr(expr, ctx, destType)
    }

    # Method declarations which are used as-is, for which we should generate a
    # static struct with zero extra arguments, if actually used.
    set<Declaration> directRefs = NEW()

    # Register that |decl| is a method which is used as a direct reference,
    # thus as a callback with zero extra arguments.
    PROC useDirectRef(Declaration decl)
      directRefs.set(decl)
    }

    # Return the direct reference name for |name|.
    FUNC directRefName(string name) string
      RETURN "ZCB_" .. name
    }

    # Declarations used to mark items as used.
    # NOTE: Only for items that do not, directly or indirectly, depend on
    # library code. These are marked as used after writing the library code,
    # thus it's too late to mark the library dependencies as used.
    Declaration %allocObjectRef = NEW("allocObjectRef")
    Declaration %noAllocObjectRef = NEW("noAllocObjectRef")
    Declaration %iobject2noalloc = NEW("iobject2noalloc")
    Declaration %deref = NEW("deref")

    Declaration %varByteStringCheckUtf8 = NEW("varByteStringCheckUtf8")
    Declaration %forEnum = NEW("forEnum")
    Declaration %forStringStruct = NEW("forStringStruct")
    Declaration %forArray = NEW("forArray")

    Declaration %concat3 = NEW("concat3")
    Declaration %concat5 = NEW("concat5")
    Declaration %concat8 = NEW("concat8")
    Declaration %concat12 = NEW("concat12")

    Declaration %forList = NEW("forList")
    Declaration %forListIobj = NEW("forListIobj")
    Declaration %forListDyn = NEW("forListDyn")
    Declaration %forListEnum = NEW("forListEnum")
    Declaration %forListFloat = NEW("forListFloat")
    Declaration %forListInt = NEW("forListInt")
    Declaration %forListPtr = NEW("forListPtr")
    Declaration %forListIobjKey = NEW("forListIobjKey")
    Declaration %forListDynKey = NEW("forListDynKey")
    Declaration %forListEnumKey = NEW("forListEnumKey")
    Declaration %forListFloatKey = NEW("forListFloatKey")
    Declaration %forListIntKey = NEW("forListIntKey")
    Declaration %forListPtrKey = NEW("forListPtrKey")

    Declaration %forDict = NEW("forDict")
    Declaration %forRange = NEW("forRange")
    Declaration %garray = NEW("garray")
    Declaration %cordType = NEW("cordType")
    Declaration %varByteStringType = NEW("varByteStringType")
    Declaration %piecevalType = NEW("piecevalType")
    Declaration %pieceType = NEW("pieceType")
    Declaration %cstring = NEW("cstring")
    Declaration %byteStringCopyMutable = NEW("byteStringCopyMutable")
    Declaration %byteStringPtr = NEW("byteStringPtr")
    Declaration %byteStringWriteTo = NEW("byteStringWriteTo")
    Declaration %char2byteIdx = NEW("char2byteIdx")
    Declaration %char2byteIdxEnd = NEW("char2byteIdxEnd")
    Declaration %varStringAddBytes = NEW("varStringAddBytes")
    Declaration %iobjType = NEW("iobjType")
    Declaration %noAllocClear = NEW("noAllocClear")
    Declaration %noAllocNil = NEW("noAllocNil")
    Declaration %noAllocNilIobj = NEW("noAllocNilIobj")

    Declaration %utf8size = NEW("utf8size")
    Declaration %stringSize = NEW("stringSize")

    Declaration %getCstring = NEW("getCstring")
    Declaration %varString2string = NEW("varString2string")
    Declaration %string2varString = NEW("string2varString")

    Declaration %bool2string = NEW("bool2string")
    Declaration %status2string = NEW("status2string")
    Declaration %int2string = NEW("int2string")
    Declaration %stringFormat = NEW("stringFormat")
    Declaration %intFormat = NEW("intFormat")
    Declaration %nat2string = NEW("nat2string")
    Declaration %natFormat = NEW("natFormat")
    Declaration %float2string = NEW("float2string")
    Declaration %floatFormat = NEW("floatFormat")
    Declaration %corrFloatStr = NEW("corrFloatStr")
    Declaration %dynType = NEW("dynType")
    Declaration %dynToString = NEW("dynToString")
    Declaration %enum2string = NEW("enum2string")
    Declaration %enumFromString = NEW("enumFromString")
    Declaration %bool2varString = NEW("bool2varString")
    Declaration %status2varString = NEW("status2varString")
    Declaration %int2varString = NEW("int2varString")

    Declaration %ptrQuotedToInt = NEW("ptrQuotedToInt")

    Declaration %stringCmp = NEW("stringCmp")
    Declaration %varByteStringCmp = NEW("varByteStringCmp")
    Declaration %varByteStringSet = NEW("varByteStringSet")

    Declaration %stringFindLen = NEW("stringFindLen")
    Declaration %stringFindLastLen = NEW("stringFindLastLen")
    Declaration %byteStringFindC = NEW("byteStringFindC")
    Declaration %byteStringFindLastC = NEW("byteStringFindLastC")
    Declaration %toCharBuf = NEW("toCharBuf")

    Declaration %ptrFindChar2 = NEW("ptrFindChar2")
    Declaration %ptrFindLastChar2 = NEW("ptrFindLastChar2")

    Declaration %fromChar = NEW("fromChar")
    Declaration %typeInRange = NEW("typeInRange")
    Declaration %stringSplitLen = NEW("stringSplitLen")

    Declaration %byteStringCheckUtf8 = NEW("byteStringCheckUtf8")
    Declaration %intAsByteString = NEW("intAsByteString")
    Declaration %intCompare = NEW("intCompare")
    Declaration %natCompare = NEW("natCompare")
    Declaration %floatCompare = NEW("floatCompare")
    Declaration %typeCompare = NEW("typeCompare")

    Declaration %ptrBinToInt = NEW("ptrBinToInt")
    Declaration %ptrQuotedBinToInt = NEW("ptrQuotedBinToInt")
    Declaration %ptrHexToInt = NEW("ptrHexToInt")
    Declaration %ptrQuotedHexToInt = NEW("ptrQuotedHexToInt")

    Declaration %stringToArray = NEW("stringToArray")
    Declaration %stringFromArray = NEW("stringFromArray")
    Declaration %stringToFloat = NEW("stringToFloat")

    Declaration %stringToLower = NEW("stringToLower")
    Declaration %stringToUpper = NEW("stringToUpper")
    Declaration %varStringToLower = NEW("varStringToLower")
    Declaration %varStringToUpper = NEW("varStringToUpper")

    Declaration %copyItems = NEW("copyItems")
    Declaration %finishIobj = NEW("finishIobj")

    # C header files.
    # Note: The following are always included:
    # stdio.h, stdlib.h, signal.h
    Declaration %fcntl = NEW("fcntl")
    Declaration %errno = NEW("errno")
    Declaration %dirent = NEW("dirent")
    Declaration %unistd = NEW("unistd")
    Declaration %limits = NEW("limits")
    Declaration %sys_types = NEW("sys_types")
    Declaration %sys_stat = NEW("sys_stat")
    Declaration %sys_wait = NEW("sys_wait")
    Declaration %string_h = NEW("string_h")
    Declaration %ctype_h = NEW("ctype_h")
    Declaration %termios = NEW("termios")
    Declaration %time_h = NEW("time_h")
    Declaration %sys_time = NEW("sys_time")
    Declaration %socket = NEW("socket")
    Declaration %hostname = NEW("hostname")
    Declaration %pthread = NEW("pthread")
    Declaration %math = NEW("math")
    Declaration %windows_h = NEW("windows_h")
    Declaration %setjmp_h = NEW("setjmp_h")

    Declaration %zfree = NEW("zfree")

    bool mathUsed  # math.h used somewhere

    # Return the list of items that can be used in >>> uses().
    FUNC getUsesDeclarations() list<Declaration>
      RETURN [%fcntl, %errno, %dirent, %unistd, %limits, Declaration.gcRun,
              %getCstring, %sys_types, %sys_stat, %sys_wait, %string_h,
              %ctype_h, %termios, %time_h, %sys_time, %socket, %hostname,
              %pthread, Declaration.throwThread, %windows_h, %setjmp_h]
    }

    # Get the __T type name used for container items and dict keys:
    # 0  any kind of value type
    # &string__T       string - length field first
    # &byteString__T   byteString - length field first
    # &iobj__T         iobject
    # &{name}__T       object
    # "&name__T"       other reference type, not in managed memory
    FUNC getTname(Type type, SContext ctx) string
      IF type == NIL
        RETURN "0"
      }
      RETURN "(Tt*)&" .. type.getTypeName(ctx) .. "__T"
    }

    # Generate an argument for |expr| with destination type "Tz", unless it's
    # an iobject.
    PROC writeTzOrIobjArg(Type type, Zui.Expression expr, SContext ctx)
      IF type.getTtype() == Type.Enum.iobject
                                           || type.getTtype() == Type.Enum.dyn
        Generate.genTopExprDoConv(expr, ctx, type)
      ELSE
        WriteC.genTzArg(type, expr, ctx)
      }
    }

    # Generate an argument for |expr| with destination type "Tz".
    # When the type is an iobject, put its address in the .ptr field.
    PROC genTzArg(Type type, Zui.Expression expr, SContext ctx)
      # If the type is NIL just use some type so that we can give error
      # messages.
      Type valType = type ?: Type.anInt
      ctx.out.write("(Tz)")
      IF valType.isFloatType()
        ctx.out.write("(Tf)")
      ELSEIF valType.isValueType()
        ctx.out.write("(Ti)")
      ELSE
        ctx.out.write("(void*)")
        IF type?.getTtype() == Type.Enum.iobject
          ctx.out.write("&")
        }
      }
      Generate.genTopExprDoConv(expr, ctx, valType)
    }

    # Generate the start of using a temp var.
    # Zimbu code: foo = expr ->  foo = NEW(); foo = expr;
    # Zimbu code:       expr ->  (t1 = NEW(), t1 = expr, t1)
    FUNC genTempUseStart(Zui.Expression expr, string typeName,
                     bool &useTempVar, string &separator, SContext ctx) string
      string name
      VAR exprExt = ZuiExpressionExt.get(expr)
      IF exprExt.tempDecl != NIL
        name = exprExt.tempDecl.pName
        useTempVar = TRUE
      ELSEIF exprExt.toplevelVar != NIL
        # Use the LHS of assignment as the temp var.
        name = exprExt.toplevelVar
        separator = "; "
      ELSE
        # Must be outside of a method, e.g., in initialization.
        name = getUid(ctx.scope.ToString())
        ctx.outs.varOut.writeIndent(ctx.scope.depth)
        ctx.outs.varOut.write(typeName .. name .. ";\n")
        useTempVar = TRUE
      }
      IF useTempVar
        ctx.out.write("(" .. name .. " = ")
      }
      RETURN name
    }

  } # SHARED

}
